              	; --------------------------------------
              	; zasm: assemble "clock.s"
              	; date: 2020-04-02 14:33:59
              	; --------------------------------------


0001:         	#define serial_loading 1
              	
              	#target ROM
              	#include "platform.inc"
              	;---- Oscillator frequencies (in Hz)
              	;     * FSYS is the primary system oscillator which drives the CPU.
              	;     * FCTC is a secondary oscillator external to the CTC which can
              	;       be prescaled and is fed in to the TRG1 input.
              	;     * FUART is the frequency fed into the SIO clock inputs for baud
              	;       rate generation.
8D80:         	FSYS                    .equ  6000000
8000:         	FCTC                    .equ  4096000
8000:         	FUART                   .equ  7372800
              	
              	;---- Memory sizes (in bytes)
              	;     Define the start (base) and size of ROMs and RAM.
              	#if defined(serial_loading)
6000:         	ROM_BASE                .equ  0x6000
1800:         	ROM_SZ                  .equ  6144
              	
7800:         	RAM_BASE                .equ  0x7800
0700:         	RAM_SZ                  .equ  1792
              	#else
              	ROM_BASE                .equ  0
              	ROM_SZ                  .equ  24576
              	
              	RAM_BASE                .equ  0x6000
              	RAM_SZ                  .equ  8192
              	#endif
              	
C000:         	TZ_ROM_BASE             .equ  0xC000
2000:         	TZ_ROM_SZ               .equ  8192
              	
E000:         	CHAR_ROM_BASE           .equ  0xE000
2000:         	CHAR_ROM_SZ             .equ  8192
              	
              	;---- Vector interrupt page number
              	;     Forms the most significant byte of the interrupt vector address
              	;     for Mode 2 interrupts.
0061:         	VECTOR_INT_PG           .equ  (ROM_BASE+0x100)>>8
              	
              	; END platform.inc
              	#include "ctc.inc"
0001:         	CTC_CTL_WORD            .equ  0x1   ; This is a control word
0002:         	CTC_CTL_SW_RESET        .equ  0x2   ; Perform SW reset on channel
0004:         	CTC_CTL_TCONST          .equ  0x4   ; Time constant follows
0008:         	CTC_CTL_CLKTRG_ST       .equ  0x8   ; CLK/TRG pulse starts timer
0010:         	CTC_CTL_RISE            .equ  0x10  ; CLK/TRG rising edge
0020:         	CTC_CTL_PS_256          .equ  0x20  ; Prescaler of 256
0040:         	CTC_CTL_CTR_MODE        .equ  0x40  ; Channel in counter mode
0080:         	CTC_CTL_INT_EN          .equ  0x80  ; Enable interrupt on this channel
              	
              	; END ctc.inc
              	#include "rtc.inc"
0040:         	RTC_ALM_ALM0            .equ  0x40
0080:         	RTC_ALM_ALM1            .equ  0x80
              	
0000:         	RTC_RS_NONE             .equ  0
0010:         	RTC_RS_30_5175US        .equ  0x01 << 4
0020:         	RTC_RS_61_035US         .equ  0x02 << 4
0030:         	RTC_RS_122_070US        .equ  0x03 << 4
0040:         	RTC_RS_244_141US        .equ  0x04 << 4
0050:         	RTC_RS_488_281US        .equ  0x05 << 4
0060:         	RTC_RS_976_5625US       .equ  0x06 << 4
0070:         	RTC_RS_1_95315MS        .equ  0x07 << 4
0080:         	RTC_RS_3_90625MS        .equ  0x08 << 4
0090:         	RTC_RS_7_8125MS         .equ  0x09 << 4
00A0:         	RTC_RS_15_625MS         .equ  0x0A << 4
00B0:         	RTC_RS_31_25MS          .equ  0x0B << 4
00C0:         	RTC_RS_62_5MS           .equ  0x0C << 4
00D0:         	RTC_RS_125MS            .equ  0x0D << 4
00E0:         	RTC_RS_250MS            .equ  0x0E << 4
00F0:         	RTC_RS_500MS            .equ  0x0F << 4
              	
0000:         	RTC_WD_1_5SEC           .equ  0
0010:         	RTC_WD_23_4375MS        .equ  0x01 << 4
0020:         	RTC_WD_46_875MS         .equ  0x02 << 4
0030:         	RTC_WD_93_75MS          .equ  0x03 << 4
0040:         	RTC_WD_187_5MS          .equ  0x04 << 4
0050:         	RTC_WD_375MS            .equ  0x05 << 4
0060:         	RTC_WD_750MS            .equ  0x06 << 4
0070:         	RTC_WD_3S               .equ  0x07 << 4
              	
0001:         	RTC_INT_ABE             .equ  0x01
0002:         	RTC_INT_PWRIE           .equ  0x02
0004:         	RTC_INT_PIE             .equ  0x04
0008:         	RTC_INT_AIE             .equ  0x08
              	
0001:         	RTC_FLAG_BVF            .equ  0x01
0002:         	RTC_FLAG_PWRF           .equ  0x02
0004:         	RTC_FLAG_PF             .equ  0x04
0008:         	RTC_FLAG_AF             .equ  0x08
              	
0001:         	RTC_CTRL_DSE            .equ  0x01
0002:         	RTC_CTRL_24HR           .equ  0x02
0004:         	RTC_CTRL_RUN_BAT        .equ  0x04
0008:         	RTC_CTRL_UTI            .equ  0x08
              	
              	; END rtc.inc
              	#include "clock.inc"
              	;---------------------------------------------------------------------
              	;                 PERIPHERAL CONFIGURATION & IO PORTS                :
              	;---------------------------------------------------------------------
              	
              	; CTC channel addresses
0000:         	CTC_CH0           .equ  0
0001:         	CTC_CH1           .equ  0x01
0002:         	CTC_CH2           .equ  0x02
0003:         	CTC_CH3           .equ  0x03
              	
              	; CTC channel configuration
0001:         	CTC_CH0_CFG       .equ  CTC_CTL_WORD
00A5:         	CTC_CH1_CFG       .equ  CTC_CTL_INT_EN | CTC_CTL_PS_256 | CTC_CTL_TCONST | CTC_CTL_WORD
00A5:         	CTC_CH2_CFG       .equ  CTC_CTL_INT_EN | CTC_CTL_PS_256 | CTC_CTL_TCONST | CTC_CTL_WORD
00C5:         	CTC_CH3_CFG       .equ  CTC_CTL_INT_EN | CTC_CTL_CTR_MODE | CTC_CTL_TCONST | CTC_CTL_WORD
              	
0017:         	CTC_CH1_TCONST    .equ  FSYS / 256 / 1000
00EA:         	CTC_CH2_TCONST    .equ  FSYS / 256 / 100
0001:         	CTC_CH3_TCONST    .equ  0x01
              	
              	; Watchdog poke register
0004:         	WDT_POKE          .equ  0x04
              	
              	; Buttons and switches
0008:         	BTN_REG           .equ  0x08        ; Buttons
0001:         	BTN_UP            .equ  0x01        ;    Up button mask
0002:         	BTN_DN            .equ  0x02        ;    Down button mask
0004:         	BTN_ENT           .equ  0x04        ;    Enter button mask
0008:         	BTN_ESC           .equ  0x08        ;    Escape button mask
000F:         	BTN_ALL           .equ  0x0F        ;    All buttons mask
0000:         	BTN_UP_BIT        .equ  0           ;    Up button bit
0001:         	BTN_DN_BIT        .equ  1           ;    Down button bit
0002:         	BTN_ENT_BIT       .equ  2           ;    Enter button bit
0003:         	BTN_ESC_BIT       .equ  3           ;    Escape button bit
0009:         	TZ_SW1_REG        .equ  0x09        ; Switches 1 (timezone 1)
000A:         	TZ_SW2_REG        .equ  0x0A        ; Switches 2 (timezone 2)
000B:         	TZ_SW3_REG        .equ  0x0B        ; Switches 3 (timezone 3)
000C:         	OUTPUT_REG        .equ  0x0C        ; Outputs, e.g. beeper
              	
              	; RTC register addresses
0010:         	RTC_SEC           .equ  0x10
0011:         	RTC_SEC_ALM       .equ  0x11
0012:         	RTC_MIN           .equ  0x12
0013:         	RTC_MIN_ALM       .equ  0x13
0014:         	RTC_HRS           .equ  0x14
0015:         	RTC_HRS_ALM       .equ  0x15
0016:         	RTC_DAY           .equ  0x16
0017:         	RTC_DAY_ALM       .equ  0x17
0018:         	RTC_DOW           .equ  0x18
0019:         	RTC_MON           .equ  0x19
001A:         	RTC_YEAR          .equ  0x1A
001B:         	RTC_RATES         .equ  0x1B
001C:         	RTC_INTS          .equ  0x1C
001D:         	RTC_FLAGS         .equ  0x1D
001E:         	RTC_CTRL          .equ  0x1E
              	
00C0:         	RTC_ALM_CFG       .equ  RTC_ALM_ALM1 | RTC_ALM_ALM0
0000:         	RTC_RATES_CFG     .equ  RTC_WD_1_5SEC | RTC_RS_NONE
0008:         	RTC_INTS_CFG      .equ  RTC_INT_AIE
0006:         	RTC_CTRL_CFG      .equ  RTC_CTRL_RUN_BAT | RTC_CTRL_24HR
              	
              	; Display registers
0020:         	DISP_DATA         .equ  0x20        ; Display data register
0021:         	DISP_CTRL         .equ  0x21        ; Display control register
              	
              	;---------------------------------------------------------------------
              	;                         TASK/APP CONSTANTS                         :
              	;---------------------------------------------------------------------
              	
              	; Apps differ from tasks in that tasks can be (de)scheduled, while
              	; apps are scheduled at boot and dont become descheduled. They share
              	; common infrastructure, however.
              	
0001:         	TASK_BUTTON_RD          .equ  1     ; Button reader
0002:         	TASK_WD_POKE            .equ  2     ; Poke the watchdog
0003:         	APP_CLOCK               .equ  3     ; Clock application
0004:         	APP_CONFIGR             .equ  4     ; Configuration application
0005:         	TASK_DISPLAY            .equ  5     ; Display updater
              	
              	;---------------------------------------------------------------------
              	;                           MISCELLANEOUS                            :
              	;---------------------------------------------------------------------
00DE:         	DEBUG_PORT              .equ  0xDE
              	
              	;---------------------------------------------------------------------
              	;                              MACROS                                :
              	;---------------------------------------------------------------------
              	
              	;---------------------------------------------------------------------
              	;     schedule_task                                                  :
              	;                                                                    :
              	; Description                                                        :
              	;     Schedule a task to be run at the next iteration of the main    :
              	;     loop.                                                          :
              	;                                                                    :
              	;     This is achieved by loading a positive value (the task number  :
              	;     itself, which is used as an offset) into the task's scheduling :
              	;     byte.                                                          :
              	;                                                                    :
              	; Parameters                                                         :
              	;     task_num  Task number to schedule                              :
              	;                                                                    :
              	;---------------------------------------------------------------------
              	schedule_task .macro task_num
              	      push  HL
              	
              	      ld    HL, task_sched+&task_num
              	      ld    (HL), &task_num
              	
              	      pop   HL
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     deschedule_task                                                :
              	;                                                                    :
              	; Description                                                        :
              	;     De-schedule a task to prevent it from running during future    :
              	;     iterations of the main loop.                                   :
              	;                                                                    :
              	;     This is achieved by loading a value of zero into the task's    :
              	;     scheduling byte.                                               :
              	;                                                                    :
              	; Parameters                                                         :
              	;     task_num  Task number to deschedule                            :
              	;---------------------------------------------------------------------
              	deschedule_task .macro task_num
              	      push  HL
              	
              	      ld    HL, task_sched+&task_num
              	      ld    (HL), 0
              	
              	      pop   HL
              	      .endm
              	
              	
              	
              	;---------------------------------------------------------------------
              	;     run_task                                                       :
              	;                                                                    :
              	; Description                                                        :
              	;     Runs a task if it has been scheduled.                          :
              	;                                                                    :
              	;     A task is scheduled if its task scheduling byte contains any   :
              	;     non-zero value.                                                :
              	;                                                                    :
              	; Parameters                                                         :
              	;     task_num    Task number to run                                 :
              	;     call_label  If scheduled, the label to CALL                    :
              	;---------------------------------------------------------------------
              	run_task .macro task_num, call_label
              	      ld    HL, task_sched+&task_num
              	      ld    A, (HL)
              	      or    A, A
              	
              	      call  NZ, &call_label
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     set_state                                                      :
              	;                                                                    :
              	; Description                                                        :
              	;     Update the value of a state machine variable.                  :
              	;                                                                    :
              	; Parameters                                                         :
              	;     sm     Destination state machine variable                      :
              	;     state  State to be loaded                                      :
              	;---------------------------------------------------------------------
              	set_state .macro sm, state
              	      push  AF
              	
              	      ld    A, &state
              	      ld    (&sm), A
              	
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     mtx_trylock                                                    :
              	;                                                                    :
              	; Description                                                        :
              	;     Attempts to acquire the mutex pointed to by the mutex          :
              	;     parameter. If the mutex cannot be immediately acquired         :
              	;     mtx_trylock will return 0, otherwise the mutex will be         :
              	;     acquired and a non-zero value will be returned.                :
              	;                                                                    :
              	;     Interrupt safe: interrupts are disabled throughout the         :
              	;                     critical code path, and restored to original   :
              	;                     state upon completion.                         :
              	;                                                                    :
              	; Parameters                                                         :
              	;     mutex     Address of mutex to acquire                          :
              	;     task_num  The task number that wants to acquire the mutex      :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  0 if lock not acquired, or task_num if acquired             :
              	;     F  Z flag is set or cleared based on value of A                :
              	;---------------------------------------------------------------------
              	mtx_trylock .macro mutex, task_num
              	      push  HL
              	
              	      ld    A, I                    ; IFF2 to P/V flag
              	      push  AF                      ; Save flags
              	      di                            ; Ensure interrupts disabled
              	
              	      ld    HL, &mutex
              	      ld    A, (HL)                 ; Check current mutex owner
              	      or    A, A
              	      jr    Z, $+9                  ; If zero, acquire it
              	
              	      cp    A, &task_num            ; If not zero, do we own it?
              	      jr    Z, $+8                  ; Yes if Z, return mutex value
              	
              	      xor   A, A                    ; No otherwise, return 0
              	      jr    $+5                     ; Go to done
              	
              	      ld    A, &task_num            ; Acquire by loading task_num into
              	      ld    (HL), A                 ; mutex
              	
              	      pop   HL                      ; F into L
              	      bit   2, L                    ; Test IFF2 flag
              	      jr    Z, $+3                  ; If IFF2 was not set, go to done
              	      ei                            ; Re-enable interrupts
              	
              	      pop   HL                      ; Done
              	
              	      or    A, A                    ; Set Z flag according to A
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     mtx_unlock                                                     :
              	;                                                                    :
              	; Description                                                        :
              	;     Releases a mutual exclusion lock.                              :
              	;                                                                    :
              	;     Interrupt safe: interrupts are disabled throughout the         :
              	;                     critical code path, and restored to original   :
              	;                     state upon completion.                         :
              	;                                                                    :
              	; Parameters                                                         :
              	;     mutex     Address of mutex to unlock                           :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;---------------------------------------------------------------------
              	mtx_unlock .macro mutex
              	      push  AF
              	      push  HL
              	
              	      ld    A, I                    ; IFF2 to P/V flag
              	      push  AF                      ; Save flags
              	      di                            ; Ensure interrupts disabled
              	
              	      xor   A, A                    ; Load zero to unlock the mutex
              	      ld    (&mutex), A
              	
              	      pop   HL                      ; F into L
              	      bit   2, L                    ; Test IFF2 flag
              	      jr    Z, $+3                  ; If IFF2 was not set, go to done
              	      ei                            ; Re-enable interrupts
              	
              	      pop   HL                      ; Done
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     mtx_owned                                                      :
              	;                                                                    :
              	; Description                                                        :
              	;     Returns non-zero if the task indicated by the task_num param   :
              	;     owns the mutex. If that task does not hold the mutex, zero is  :
              	;     returned.                                                      :
              	;                                                                    :
              	;     Interrupt safe: interrupts are disabled throughout the         :
              	;                     critical code path, and restored to original   :
              	;                     state upon completion.                         :
              	;                                                                    :
              	; Parameters                                                         :
              	;     mutex     Address of mutex to check ownership of               :
              	;     task_num  The task number to compare                           :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  0 if lock not owned, or task_num if owned                   :
              	;     F  Z flag is set or cleared based on value of A                :
              	;---------------------------------------------------------------------
              	mtx_owned .macro mutex, task_num
              	      push  HL
              	
              	      ld    A, I                    ; IFF2 to P/V flag
              	      push  AF                      ; Save flags
              	      di                            ; Ensure interrupts disabled
              	
              	      ld    A, (&mutex)             ; Compare the value stored in
              	      cp    A, &task_num            ; (mutex) with task_num.
              	      jr    Z, $+3
              	
              	      xor   A, A                    ; Not equal, return 0
              	
              	      pop   HL                      ; F into L
              	      bit   2, L                    ; Test IFF2 flag
              	      jr    Z, $+3                  ; If IFF2 was not set, go to done
              	      ei                            ; Re-enable interrupts
              	
              	      pop   HL                      ; Done
              	
              	      or    A, A
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     sem_post                                                       :
              	;                                                                    :
              	; Description                                                        :
              	;     Increment (unlock) a semaphore.                                :
              	;                                                                    :
              	;     Interrupt safe: interrupts are disabled throughout the         :
              	;                     critical code path, and restored to original   :
              	;                     state upon completion.                         :
              	;                                                                    :
              	; Parameters                                                         :
              	;     sem       Address of semaphore to increment (unlock)           :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;---------------------------------------------------------------------
              	sem_post .macro sem
              	      push  AF
              	      push  HL
              	
              	      ld    A, I                    ; IFF2 to P/V flag
              	      push  AF                      ; Save flags
              	      di                            ; Ensure interrupts disabled
              	
              	      ld    HL, &sem
              	      inc   (HL)
              	
              	      pop   HL                      ; F into L
              	      bit   2, L                    ; Test IFF2 flag
              	      jr    Z, $+3                  ; If IFF2 was not set, go to done
              	      ei                            ; Re-enable interrupts
              	
              	      pop   HL
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     sem_trywait                                                    :
              	;                                                                    :
              	; Description                                                        :
              	;     sem_trywait decrements (locks) the semaphore only if the value :
              	;     is non-zero. Otherwise, the semaphore is not decremented and   :
              	;     an error (0) is returned.                                      :
              	;                                                                    :
              	;     Interrupt safe: interrupts are disabled throughout the         :
              	;                     critical code path, and restored to original   :
              	;                     state upon completion.                         :
              	;                                                                    :
              	; Parameters                                                         :
              	;     sem       Address of semaphore to increment (unlock)           :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  0 if semaphore locked, or semaphore value pre-decrement     :
              	;     F  Z flag is set or cleared based on value of A                :
              	;---------------------------------------------------------------------
              	sem_trywait .macro sem
              	      push  HL
              	
              	      ld    A, I                    ; IFF2 to P/V flag
              	      push  AF                      ; Save flags
              	      di                            ; Ensure interrupts disabled
              	
              	      ld    HL, &sem
              	      ld    A, (HL)                 ; Load semaphore value for return
              	      or    A, A                    ; Semaphore value greater than 0?
              	      jr    Z, $+3                  ; If Z, return 0, go to done
              	
              	      dec   (HL)                    ; Decrement semaphore
              	
              	      pop   HL                      ; F into L
              	      bit   2, L                    ; Test IFF2 flag
              	      jr    Z, $+3                  ; If IFF2 was not set, go to done
              	      ei                            ; Re-enable interrupts
              	
              	      pop   HL                      ; Done
              	
              	      or    A, A                    ; Set Z flag according to A
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     set_valid_btn_mask                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Update the valid button mask to a new value.                   :
              	;                                                                    :
              	;     Presumably this is done while switching between states in an   :
              	;     app or task, so to prevent any unacknowledged or very recent   :
              	;     button presses being immediately acted upon within the new     :
              	;     state, those button presses are nulled out and made            :
              	;     acknowledged. Therefore the user will need to release those    :
              	;     button(s) before they can be re-recognised as new presses.     :
              	;                                                                    :
              	; Parameters                                                         :
              	;     mask  New button mask to apply                                 :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;---------------------------------------------------------------------
              	set_valid_btn_mask .macro mask
              	      push  AF
              	      push  BC
              	
              	      ld    A, (btn_state)          ; Ack all un-ack'd buttons by
              	      ld    B, A                    ; OR'ing them with all ack'd
              	      ld    A, (btn_ack)            ; buttons.
              	      or    A, B
              	      ld    (btn_ack), A
              	
              	      ld    A, &mask
              	      ld    (btn_valid), A          ; Load new mask
              	
              	      pop   BC
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     ack_btn                                                        :
              	;                                                                    :
              	; Description                                                        :
              	;     Acknowledge a button press by setting its appropriate bit in   :
              	;     the btn_ack variable.                                          :
              	;---------------------------------------------------------------------
              	ack_btn .macro button
              	      push  HL
              	
              	      ld    HL, btn_ack             ; Ack the button
              	      set   &button, (HL)
              	
              	      pop   HL
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     rtc_update_lock                                                :
              	;                                                                    :
              	; Description                                                        :
              	;     Set the Update Transfer Inhibit bit of the RTC control         :
              	;     register.                                                      :
              	;                                                                    :
              	;     Prevents the RTC from updating public registers while they are :
              	;     being read by an application.                                  :
              	;---------------------------------------------------------------------
              	rtc_update_lock .macro
              	      push  AF
              	
              	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
              	      out   (RTC_CTRL), A
              	
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     rtc_update_unlock                                              :
              	;                                                                    :
              	; Description                                                        :
              	;     Clear the Update Transfer Inhibit bit of the RTC control       :
              	;     register.                                                      :
              	;                                                                    :
              	;     Allows the RTC to update public registers so that their new    :
              	;     values may be read by an application.                          :
              	;---------------------------------------------------------------------
              	rtc_update_unlock .macro
              	      push  AF
              	
              	      ld    A, RTC_CTRL_CFG
              	      out   (RTC_CTRL), A
              	
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     get_jp_table_entry                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Using A as an index, return the value of a double word from    :
              	;     the supplied table to be used as an address to perform a jump. :
              	;                                                                    :
              	;     The value of A is doubled and added to the supplied table      :
              	;     address.                                                       :
              	;                                                                    :
              	; Parameters                                                         :
              	;     table  Address of the table to return entry from               :
              	;                                                                    :
              	; Returns                                                            :
              	;     HL  Address at index in jump table                             :
              	;---------------------------------------------------------------------
              	get_jp_table_entry .macro table
              	      push DE
              	
              	      ld    D, 0                    ; DE becomes offset by doubling A
              	      ld    E, A
              	      sla   E
              	      rl    D
              	
              	      ld    HL, &table              ; HL = pointer to jump table
              	      add   HL, DE                  ; Add offset to pointer
              	
              	      ld    E, (HL)                 ; Load HL pair into DE
              	      inc   HL
              	      ld    D, (HL)
              	
              	      ex    DE, HL                  ; DE becomes HL for return
              	
              	      pop   DE
              	      .endm
              	
              	; END clock.inc
              	
7800:         	#data RAM, RAM_BASE, RAM_SZ-256
7E00:         	#data _INITIALIZED, *, 256
6000:         	#code ROM, ROM_BASE, ROM_SZ-256
7700:         	#code _INITIALIZER, *, 256
              	
              	#code ROM
              	;---------------------------------------------------------------------
              	;                           RESTART VECTORS                          :
              	;---------------------------------------------------------------------
              	      .org ROM_BASE
6000: C30062  	      jp    proc_test
              	
6003: FFFFFFFF	      .org ROM_BASE+0x8             ; RST1
6007: FF      	
6008: 76      	      halt
              	
6009: FFFFFFFF	      .org ROM_BASE+0x10            ; RST2
600D: FFFFFF  	
6010: 76      	      halt
              	
6011: FFFFFFFF	      .org ROM_BASE+0x18            ; RST3
6015: FFFFFF  	
6018: 76      	      halt
              	
6019: FFFFFFFF	      .org ROM_BASE+0x20            ; RST4
601D: FFFFFF  	
6020: 76      	      halt
              	
6021: FFFFFFFF	      .org ROM_BASE+0x28            ; RST5
6025: FFFFFF  	
6028: 76      	      halt
              	
6029: FFFFFFFF	      .org ROM_BASE+0x30            ; RST6
602D: FFFFFF  	
6030: 76      	      halt
              	
6031: FFFFFFFF	      .org ROM_BASE+0x38            ; RST7
6035: FFFFFF  	
6038: 76      	      halt
              	
              	
              	;---------------------------------------------------------------------
              	;                          INTERRUPT VECTORS                         :
              	;---------------------------------------------------------------------
6039: FFFFFFFF	      .org ROM_BASE+0x66
603D: FF...   	
6066:         	nmi_vector
6066: 76      	      halt
              	
6067: FFFFFFFF	      .org VECTOR_INT_PG<<8
606B: FF...   	
6100:         	int_vector_table
6100: 0073    	      .dw   ctc_ch0_isr
6102: 8073    	      .dw   ctc_ch1_isr
6104: 0074    	      .dw   ctc_ch2_isr
6106: 8074    	      .dw   ctc_ch3_isr
              	
              	
              	;---------------------------------------------------------------------
              	;     Z80 Processor Test                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Verify Z80 flags, registers (except IX/IY) and conditional     :
              	;     jumps, including all shadow register pairs.                    :
              	;                                                                    :
              	;     Adapted from IBM 5150 BIOS.                                    :
              	;---------------------------------------------------------------------
6108: FFFFFFFF	      .align 0x100
610C: FF...   	
6200:         	proc_test
              	#local
6200: F3      	      di                            ; Ensure interrupts disabled
              	
              	;---- First tests for normal flags register
6201:         	next_regs
6201: AF      	      xor   A, A
6202: 387E    	      jr    C, proc_test_err        ; Carry should be clear
6204: E28262  	      jp    PO, proc_test_err       ; Parity should be even
6207: 2079    	      jr    NZ, proc_test_err       ; Result should be zero
6209: FA8262  	      jp    M, proc_test_err        ; Result should be positive
              	
620C: D601    	      sub   A, 1
620E: 3072    	      jr    NC, proc_test_err       ; Carry should be set
6210: EA8262  	      jp    PE, proc_test_err       ; Parity should be odd
6213: 286D    	      jr    Z, proc_test_err        ; Result should be non-zero
6215: F28262  	      jp    P, proc_test_err        ; Result should be negative
              	
6218: 3E01    	      ld    A, 0x01
621A: CB3F    	      srl   A
621C: 3064    	      jr    NC, proc_test_err       ; Carry should be set
621E: 2062    	      jr    NZ, proc_test_err       ; Result should be zero
              	
6220: CB17    	      rl    A
6222: 385E    	      jr    C, proc_test_err        ; Carry should be clear
6224: 285C    	      jr    Z, proc_test_err        ; Result should be non-zero
              	
              	;---- Repeat tests for shadow flags register
6226: 08      	      ex    AF, AF'
6227: AF      	      xor   A, A
6228: 3858    	      jr    C, proc_test_err        ; Carry should be clear
622A: E28262  	      jp    PO, proc_test_err       ; Parity should be even
622D: 2053    	      jr    NZ, proc_test_err       ; Result should be zero
622F: FA8262  	      jp    M, proc_test_err        ; Result should be positive
              	
6232: D601    	      sub   A, 1
6234: 304C    	      jr    NC, proc_test_err       ; Carry should be set
6236: EA8262  	      jp    PE, proc_test_err       ; Parity should be odd
6239: 2847    	      jr    Z, proc_test_err        ; Result should be non-zero
623B: F28262  	      jp    P, proc_test_err        ; Result should be negative
              	
623E: 3E01    	      ld    A, 0x01
6240: CB3F    	      srl   A
6242: 303E    	      jr    NC, proc_test_err       ; Carry should be set
6244: 203C    	      jr    NZ, proc_test_err       ; Result should be zero
              	
6246: CB17    	      rl    A
6248: 3838    	      jr    C, proc_test_err        ; Carry should be clear
624A: 2836    	      jr    Z, proc_test_err        ; Result should be non-zero
              	
              	;---- Load a test pattern through all registers
624C: 3EFF    	      ld    A, 0xFF                 ; Setup one's pattern in A
624E: 37      	      scf
              	
624F: ED47    	      ld    I, A                    ; Write pattern through all regs
6251: ED57    	      ld    A, I
              	
6253:         	write_pattern
6253: 6F      	      ld    L, A
6254: 65      	      ld    H, L
6255: 5C      	      ld    E, H
6256: 53      	      ld    D, E
6257: 4A      	      ld    C, D
6258: 41      	      ld    B, C
6259: 78      	      ld    A, B
625A: D9      	      exx
625B: 6F      	      ld    L, A
625C: 65      	      ld    H, L
625D: 5C      	      ld    E, H
625E: 53      	      ld    D, E
625F: 4A      	      ld    C, D
6260: 41      	      ld    B, C
6261: 3008    	      jr    NC, proc_test_done
6263: 08      	      ex    AF, AF'
6264: 78      	      ld    A, B
6265: EEFF    	      xor   A, 0xFF                 ; Pattern make it through all regs
6267: 2019    	      jr    NZ, proc_test_err       ; If no, go to error
6269: 18E8    	      jr    write_pattern
              	
626B:         	proc_test_done
626B: B7      	      or    A, A                    ; Resulting pattern is zero?
626C: C28262  	      jp    NZ, proc_test_err       ; If no, go to error
              	
626F: 310000  	      ld    SP, 0                   ; Test all zeroes in SP
6272: 39      	      add   HL, SP
6273: 7C      	      ld    A, H
6274: B5      	      or    A, L
6275: 200B    	      jr    NZ, proc_test_err
              	
6277: 31FFFF  	      ld    SP, 0xFFFF              ; Test all ones in SP
627A: 39      	      add   HL, SP
627B: 7C      	      ld    A, H
627C: AD      	      xor   A, L
627D: 2003    	      jr    NZ, proc_test_err
              	
627F: C38362  	      jp    mem_test
              	
6282:         	proc_test_err
6282: 76      	      halt                          ; Halt on error
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     RAM Test                                                       :
              	;                                                                    :
              	; Description                                                        :
              	;     Performs a read/write storage test on RAM address space as     :
              	;     defined by RAM_BASE and RAM_SZ variables.                      :
              	;                                                                    :
              	;     Writes a series of patterns (0xAA, 0x55, 0xFF, 0x01 and 0x00)  :
              	;     and reads them back to check for errors.                       :
              	;                                                                    :
              	;     !!! DESTROYS CONTENTS OF ENTIRE MEMORY BLOCK !!!               :
              	;---------------------------------------------------------------------
6283:         	mem_test
              	#local
6283: D9      	      exx
6284: 21A462  	      ld    HL, mem_test_patterns   ; Shadow HL holds ptr to patterns
6287: D9      	      exx
              	
6288: 0605    	      ld    B, 5                    ; B holds outer loop (pattern) ctr
              	
628A:         	mem_test_next
628A: 210078  	      ld    HL, RAM_BASE            ; Pointer to start of RAM
628D: 110007  	      ld    DE, RAM_SZ              ; Inner loop counter (size of RAM)
              	
6290: D9      	      exx
6291: 7E      	      ld    A, (HL)                 ; Get test pattern for this round
6292: 23      	      inc   HL                      ; Inc pointer to next test pattern
6293: D9      	      exx
              	
6294:         	mem_test_loop
6294: 77      	      ld    (HL), A                 ; Store pattern in memory
6295: AE      	      xor   A, (HL)                 ; XOR pattern out of memory
6296: 200B    	      jr    NZ, mem_test_err        ; If not zero, error
              	
6298: 23      	      inc   HL                      ; Inc pointer to next memory loc
6299: 1B      	      dec   DE                      ; Dec inner loop
              	
629A: 7A      	      ld    A, D                    ; Inner loop counter at zero?
629B: B3      	      or    A, E
629C: 20F6    	      jr    NZ, mem_test_loop       ; No if NZ, next memory loc
              	
629E: 10EA    	      djnz  mem_test_next           ; Loop for next pattern
              	
62A0: C30063  	      jp    init                    ; All tests complete, init
              	
62A3:         	mem_test_err
62A3: 76      	      halt                          ; Halt on error
              	
62A4: AA55FF01	mem_test_patterns       .dm   0xAA, 0x55, 0xFF, 0x01, 0
62A8: 00      	
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;                          APPLICATION CODE                          :
              	;---------------------------------------------------------------------
              	#data RAM
              	; Mutexes
7800: 00      	foreground_mtx          .db 0       ; Which task owns the foreground.
              	                                    ; The foreground task can read
              	                                    ; buttons and update display row
              	                                    ; data.
              	
              	; Semaphores
7801: 00      	clock_app_sem           .db 0
7802: 00      	configr_app_sem         .db 0
7803: 00      	clock_upd_req_sem       .db 0
7804: 00      	clock_upd_sem           .db 0
              	
7805: 00000000	      .align 0x10
7809: 00...   	
7810: 00000000	task_sched              .ds 16      ; Each byte corresponds to one app
7814: 00...   	
              	                                    ; or task. A non-zero value
              	                                    ; indicates the app/task is
              	                                    ; scheduled to run.
              	
              	; Display row/dot point buffers - keep each block contiguous!
              	      .align 0x8
7820: 00000000	display_row1            .ds 8       ; Working buffers.
7824: 00000000	
7828: 00000000	display_row2            .ds 8       ; Display rows will be refreshed
782C: 00000000	
7830: 00000000	display_row3            .ds 8       ; using the data held in these
7834: 00000000	
7838: 00      	display_dp1             .db 0       ; buffers.
7839: 00      	display_dp2             .db 0
783A: 00      	display_dp3             .db 0
              	
783B: 00000000	      .align 0x8
783F: 00      	
7840: 00000000	staging_row1            .ds 8       ; Staging buffers.
7844: 00000000	
7848: 00000000	staging_row2            .ds 8       ; New data to be displayed can be
784C: 00000000	
7850: 00000000	staging_row3            .ds 8       ; staged in these buffers, then
7854: 00000000	
7858: 00      	staging_dp1             .db 0       ; copied to the working buffers
7859: 00      	staging_dp2             .db 0       ; when ready for display.
785A: 00      	staging_dp3             .db 0
              	
              	#code ROM
62A9: FFFFFFFF	      .align 0x100
62AD: FF...   	
6300:         	init
              	
6300: 31007E  	      ld    SP, RAM_end             ; SP to top of RAM, below init'd
              	
6303: 010001  	      ld    BC, _INITIALIZER_size   ; Copy initialised RAM from ROM
6306: 11007E  	      ld    DE, _INITIALIZED
6309: 210077  	      ld    HL, _INITIALIZER
630C: CD0075  	      call  memcpy
              	
630F: AF      	      xor   A, A
6310: D3DE    	      out   (DEBUG_PORT), A         ; Clear debug port display
              	
              	      ; Zeroise RAM, -2 to save return addr on stack
6312: 01FE05  	      ld    BC, RAM_size-2
6315: 210078  	      ld    HL, RAM_BASE
6318: CD4075  	      call  memset
              	
              	;---- Configure CTC channels
              	
              	      ; Configures CTC interrupt vector
631B: AF      	      xor   A, A
631C: D300    	      out   (CTC_CH0), A
              	
              	      ; Configures CTC Ch 1 - ~1ms delay for display refresh
631E: 3EA5    	      ld    A, CTC_CH1_CFG
6320: D301    	      out   (CTC_CH1), A
6322: 3E17    	      ld    A, CTC_CH1_TCONST
6324: D301    	      out   (CTC_CH1), A
              	
              	      ; Configures CTC Ch 2 - ~10ms delay for scheduling various tasks
6326: 3EA5    	      ld    A, CTC_CH2_CFG
6328: D302    	      out   (CTC_CH2), A
632A: 3EEA    	      ld    A, CTC_CH2_TCONST
632C: D302    	      out   (CTC_CH2), A
              	
              	      ; Configures CTC Ch 3 as downcounter for RTC interrupt
632E: 3EC5    	      ld    A, CTC_CH3_CFG
6330: D303    	      out   (CTC_CH3), A
6332: 3E01    	      ld    A, CTC_CH3_TCONST
6334: D303    	      out   (CTC_CH3), A
              	
              	;---- Configure the RTC
6336: 3E00    	      ld    A, RTC_RATES_CFG        ; WD and periodic int rates
6338: D31B    	      out   (RTC_RATES), A
633A: 3E08    	      ld    A, RTC_INTS_CFG         ; Interrupt enables
633C: D31C    	      out   (RTC_INTS), A
633E: 3E06    	      ld    A, RTC_CTRL_CFG         ; Control flags
6340: D31E    	      out   (RTC_CTRL), A
              	
6342: AF      	      xor   A, A                    ; Configure alarm to occur each
6343: D311    	      out    (RTC_SEC_ALM), A       ; minute at 0 seconds.
6345: 3EC0    	      ld    A, RTC_ALM_CFG
6347: D313    	      out    (RTC_MIN_ALM), A
6349: D315    	      out    (RTC_HRS_ALM), A
634B: D317    	      out    (RTC_DAY_ALM), A
              	
634D: DB1D    	      in    A, (RTC_FLAGS)          ; Read RTC flags to clear them
              	
              	      ; Configure and enable Z80 vectored interrupts
634F: ED5E    	      im    2
6351: 3E61    	      ld    A, VECTOR_INT_PG
6353: ED47    	      ld    I, A
6355: FB      	      ei
              	
              	;---- Schedule applications to run
              	      schedule_task APP_CLOCK
6356: E5      	      push  HL
              	
6357: 211378  	      ld    HL, task_sched+APP_CLOCK
635A: 3603    	      ld    (HL), APP_CLOCK
              	
635C: E1      	      pop   HL
              	      schedule_task APP_CONFIGR
635D: E5      	      push  HL
              	
635E: 211478  	      ld    HL, task_sched+APP_CONFIGR
6361: 3604    	      ld    (HL), APP_CONFIGR
              	
6363: E1      	      pop   HL
              	
6364: C30064  	      jp    main_loop
              	
              	;---- Main application loop
              	;     Runs all scheduled tasks and applications.
6367: FFFFFFFF	      .align 0x100
636B: FF...   	
6400:         	main_loop
              	      ; Inputs
              	      run_task TASK_BUTTON_RD, button_rd_task
6400: 211178  	      ld    HL, task_sched+TASK_BUTTON_RD
6403: 7E      	      ld    A, (HL)
6404: B7      	      or    A, A
              	
6405: C40065  	      call  NZ, button_rd_task
              	
              	      ; Applications
              	      run_task APP_CLOCK, clock_app
6408: 211378  	      ld    HL, task_sched+APP_CLOCK
640B: 7E      	      ld    A, (HL)
640C: B7      	      or    A, A
              	
640D: C40068  	      call  NZ, clock_app
              	      run_task APP_CONFIGR, configr_app
6410: 211478  	      ld    HL, task_sched+APP_CONFIGR
6413: 7E      	      ld    A, (HL)
6414: B7      	      or    A, A
              	
6415: C4006D  	      call  NZ, configr_app
              	
              	      ; Outputs
              	      run_task TASK_DISPLAY, display_task
6418: 211578  	      ld    HL, task_sched+TASK_DISPLAY
641B: 7E      	      ld    A, (HL)
641C: B7      	      or    A, A
              	
641D: C40066  	      call  NZ, display_task
              	
              	      ; Other
              	      run_task TASK_WD_POKE, wd_poke_task
6420: 211278  	      ld    HL, task_sched+TASK_WD_POKE
6423: 7E      	      ld    A, (HL)
6424: B7      	      or    A, A
              	
6425: C40067  	      call  NZ, wd_poke_task
              	
6428: 76      	      halt
              	
6429: 18D5    	      jr    main_loop
              	
              	
              	;---------------------------------------------------------------------
              	;     Button Reader Task                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Read in the state of any pressed buttons to provide input to   :
              	;     any task that is interested.                                   :
              	;                                                                    :
              	;     Reads the button input register, masks out invalid buttons,    :
              	;     masks out button presses that have already been acknowledged,  :
              	;     debounces new button presses, and sets flags for newly         :
              	;     registered button presses.                                     :
              	;---------------------------------------------------------------------
              	#data RAM
785B: 00      	btn_valid               .db 0       ; Valid button mask
785C: 00      	btn_ack                 .db 0       ; Acknowledged button presses
785D: 00      	btn_state               .db 0       ; Serviceable buttons!
785E: 00      	btn_debounce            .db 0       ; Buttons presses being debounced
785F: 00      	btn_flags               .db 0       ; Button reader task flags
              	
              	#code ROM
642B: FFFFFFFF	      .align 0x100
642F: FF...   	
6500:         	button_rd_task
              	#local
6500: 3E01    	      ld    A, 0x01                 ; For extra button debouncing,
6502: 215F78  	      ld    HL, btn_flags           ; only run task every other time.
6505: AE      	      xor   A, (HL)                 ; Invert bit 0 of flags and test
6506: CB46    	      bit   0, (HL)
6508: 201B    	      jr    NZ, done                ; If bit is 0, run task
              	
650A: DB08    	      in    A, (BTN_REG)            ; Read in button state
650C: 2F      	      cpl                           ; Buttons pull down, make positive
              	
650D: 215B78  	      ld    HL, btn_valid           ; Mask out invalid buttons
6510: A6      	      and   A, (HL)
6511: 47      	      ld    B, A                    ; B is valid buttons only
              	
6512: 215C78  	      ld    HL, btn_ack             ; Make mask to hide serviced btns
6515: A6      	      and   A, (HL)
6516: 4F      	      ld    C, A                    ; C is mask
              	
6517: A8      	      xor   A, B                    ; Remove svcd btns, leave unsvcd
6518: 47      	      ld    B, A                    ; B is now unserviced buttons only
6519: B1      	      or    A, C                    ; Make mask to clear old ACKs
              	
651A: A6      	      and   A, (HL)                 ; Clear ACKs from released btns
651B: 77      	      ld    (HL), A
              	
651C: 215E78  	      ld    HL, btn_debounce        ; De-bounce button presses
651F: 7E      	      ld    A, (HL)
6520: A0      	      and   A, B
6521: 325D78  	      ld    (btn_state), A
6524: 70      	      ld    (HL), B
              	
6525:         	done
              	      deschedule_task TASK_BUTTON_RD
6525: E5      	      push  HL
              	
6526: 211178  	      ld    HL, task_sched+TASK_BUTTON_RD
6529: 3600    	      ld    (HL), 0
              	
652B: E1      	      pop   HL
              	
652C: C9      	      ret
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     Display update task                                            :
              	;                                                                    :
              	; Description                                                        :
              	;     Applications write only to the staging display buffers, but    :
              	;     the ISR that updates the physical displays takes its input     :
              	;     from the working display buffers.                              :
              	;                                                                    :
              	;     This task implements a display update effect which mimicks the :
              	;     displays of the DSKY, part of the Apollo Guidance Computer,    :
              	;     whereby the contents of the displays appear to transition      :
              	;     slowly.                                                        :
              	;---------------------------------------------------------------------
              	#data RAM
7860: 00      	display_ctr             .db 0       ; Counter for current character
7861: 00      	display_status          .db 0       ; Display updater status register
7862: 00      	display_syncd           .db 0       ; If zero, working == staging
7863: 00      	display_effect          .db 0       ; Display update effect:
              	                                    ; LSb 0: DSKY effect
              	                                    ; Anything else, no effect
              	
              	#code ROM
652D: FFFFFFFF	      .align 0x100
6531: FF...   	
6600:         	display_task
              	#local
6600: 3A6378  	      ld    A, (display_effect)
6603: CB47    	      bit   0, A
6605: 200E    	      jr    NZ, dsky_effect
              	
              	      ; No effect - copy the staging buffers to working buffers
6607: 011B00  	      ld    BC, 27
660A: 112078  	      ld    DE, display_row1
660D: 214078  	      ld    HL, staging_row1
6610: CD0075  	      call  memcpy
              	
6613: 1829    	      jr    done
              	
6615:         	dsky_effect
6615: 216178  	      ld    HL, display_status      ; Skip every other iteration
6618: 7E      	      ld    A, (HL)
6619: EE01    	      xor   A, 0x01
661B: 77      	      ld    (HL), A
661C: CB47    	      bit   0, A
661E: 201E    	      jr    NZ, done
              	
6620: AF      	      xor   A, A
6621: 57      	      ld    D, A
              	
6622: 3A6078  	      ld    A, (display_ctr)        ; Load display position counter
6625: 5F      	      ld    E, A                    ; DE is offset
              	
6626: 214078  	      ld    HL, staging_row1        ; Source pointer
6629: 19      	      add   HL, DE
662A: E5      	      push  HL                      ; Save for later
              	
662B: 212078  	      ld    HL, display_row1        ; Destination pointer
662E: 19      	      add   HL, DE
662F: EB      	      ex    DE, HL                  ; Restore source pointer
6630: E1      	      pop   HL
              	
6631: 7E      	      ld    A, (HL)
6632: 12      	      ld    (DE), A
              	
6633: 216078  	      ld    HL, display_ctr         ; Increment display position ctr
6636: 34      	      inc   (HL)
6637: 7E      	      ld    A, (HL)
6638: FE1B    	      cp    A, 27                   ; Overflowed to 27?
663A: 2002    	      jr    NZ, done
              	
663C: AF      	      xor   A, A                    ; Yes, reset back to zero
663D: 77      	      ld    (HL), A
              	
663E:         	done
              	      deschedule_task TASK_DISPLAY
663E: E5      	      push  HL
              	
663F: 211578  	      ld    HL, task_sched+TASK_DISPLAY
6642: 3600    	      ld    (HL), 0
              	
6644: E1      	      pop   HL
              	
6645: C9      	      ret
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     Watchdog Poke Task                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     The watchdog, contained in the RTC, should be poked every so   :
              	;     often to prevent it from asserting the RST/ signal and causing :
              	;     a processor reset.                                             :
              	;                                                                    :
              	;     This is achieved very simply by issuing an IO read or write to :
              	;     the watchdog peripheral address.                               :
              	;---------------------------------------------------------------------
              	#data RAM
              	#code ROM
6646: FFFFFFFF	      .align 0x100
664A: FF...   	
6700:         	wd_poke_task
              	#local
6700: D304    	      out   (WDT_POKE), A
              	
              	      deschedule_task TASK_WD_POKE
6702: E5      	      push  HL
              	
6703: 211278  	      ld    HL, task_sched+TASK_WD_POKE
6706: 3600    	      ld    (HL), 0
              	
6708: E1      	      pop   HL
              	
6709: C9      	      ret
              	#endlocal
              	
              	
              	#include "clock_app.s"
              	;---------------------------------------------------------------------
              	;     Clock Application                                              :
              	;                                                                    :
              	; Description                                                        :
              	;     This task is scheduled at boot and should not be descheduled.  :
              	;                                                                    :
              	;     This task runs as an application of sorts. It reads the        :
              	;     registers of the RTC to get UTC time, and then for each of the :
              	;     configured timezones (according to DIP switch settings),       :
              	;     calculates the appropriate offsets from UTC to show those      :
              	;     timezones on each row of the display.                          :
              	;                                                                    :
              	;     The task self determines if it should run, signalled by the    :
              	;     foreground mutex either being null or owned.                   :
              	;---------------------------------------------------------------------
              	
              	; State machine states
0000:         	CLOCK_APP_START         .equ  0
0001:         	CLOCK_UPDATE            .equ  0x01
0002:         	CLOCK_IDLE              .equ  0x02
0003:         	CLOCK_EXIT              .equ  0x03
              	
              	#data RAM
7864: 00      	clock_state             .db 0       ; State machine value
              	
7865: 00      	clock_tz1_sw            .db 0       ; Timezone switch settings
7866: 00      	clock_tz2_sw            .db 0
7867: 00      	clock_tz3_sw            .db 0
              	
7868: 00      	clock_rtc_min           .db 0       ; Copy of RTC registers
7869: 00      	clock_rtc_hrs           .db 0
786A: 00      	clock_rtc_day           .db 0
786B: 00      	clock_rtc_dow           .db 0
786C: 00      	clock_rtc_mon           .db 0
786D: 00      	clock_rtc_year          .db 0
              	
786E: 00      	clock_tz_min            .db 0       ; These variables hold the values
786F: 00      	clock_tz_hrs            .db 0       ; being computed for the current
7870: 00      	clock_tz_day            .db 0       ; row of the display.
7871: 00      	clock_tz_dow            .db 0
7872: 00      	clock_tz_mon            .db 0
7873: 00      	clock_tz_days_in_mon    .db 0       ; Days in month for this row
              	
7874: 00      	clock_row               .db 0       ; Display row being computed
              	
7875: 0000    	tz_sw_ptr               .dw 0
7877: 0000    	tz_rom_ptr              .dw 0       ; Pointer to TZ ROM entry
7879: 0000    	row_buf_ptr             .dw 0       ; Pointer to display row buffer
787B: 0000    	day_array_ptr           .dw 0       ; Pointer to array of days in mon
              	
787D: 00      	row_carrys              .db 0       ; Keep track of carrys:
              	                                    ; 0: Minutes
              	                                    ; 1: Hours (affects day)
              	                                    ; 2: Days (affects month)
              	                                    ; 3: Month (affects year)
              	
787E: 00      	row_borrows             .db 0       ; Keep track of borrows:
              	                                    ; 0: Minutes
              	                                    ; 1: Hours (affects day)
              	                                    ; 2: Days (affects month)
              	                                    ; 3: Month (affects year)
              	
787F: 00      	row_flags               .db 0       ; Flags used during row work:
              	                                    ; 0: DST hour match
              	                                    ; 1: DST day match
              	                                    ; 2: DST month match
              	                                    ; 3:
              	                                    ; 4:
              	                                    ; 5:
              	                                    ; 6:
              	                                    ; 7: Apply DST
              	
              	#data _INITIALIZED
              	#code _INITIALIZER
              	
              	#code ROM
670A: FFFFFFFF	      .align 0x100
670E: FF...   	
6800:         	clock_app
              	      ; Try to lock the foreground mutex if it is available, or return
              	      mtx_trylock foreground_mtx, APP_CLOCK
6800: E5      	      push  HL
              	
6801: ED57    	      ld    A, I                    ; IFF2 to P/V flag
6803: F5      	      push  AF                      ; Save flags
6804: F3      	      di                            ; Ensure interrupts disabled
              	
6805: 210078  	      ld    HL, foreground_mtx
6808: 7E      	      ld    A, (HL)                 ; Check current mutex owner
6809: B7      	      or    A, A
680A: 2807    	      jr    Z, $+9                  ; If zero, acquire it
              	
680C: FE03    	      cp    A, APP_CLOCK            ; If not zero, do we own it?
680E: 2806    	      jr    Z, $+8                  ; Yes if Z, return mutex value
              	
6810: AF      	      xor   A, A                    ; No otherwise, return 0
6811: 1803    	      jr    $+5                     ; Go to done
              	
6813: 3E03    	      ld    A, APP_CLOCK            ; Acquire by loading task_num into
6815: 77      	      ld    (HL), A                 ; mutex
              	
6816: E1      	      pop   HL                      ; F into L
6817: CB55    	      bit   2, L                    ; Test IFF2 flag
6819: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
681B: FB      	      ei                            ; Re-enable interrupts
              	
681C: E1      	      pop   HL                      ; Done
              	
681D: B7      	      or    A, A                    ; Set Z flag according to A
681E: C8      	      ret   Z
              	
              	      ; Check semaphore to determine if clock app should run
              	      sem_trywait clock_app_sem
681F: E5      	      push  HL
              	
6820: ED57    	      ld    A, I                    ; IFF2 to P/V flag
6822: F5      	      push  AF                      ; Save flags
6823: F3      	      di                            ; Ensure interrupts disabled
              	
6824: 210178  	      ld    HL, clock_app_sem
6827: 7E      	      ld    A, (HL)                 ; Load semaphore value for return
6828: B7      	      or    A, A                    ; Semaphore value greater than 0?
6829: 2801    	      jr    Z, $+3                  ; If Z, return 0, go to done
              	
682B: 35      	      dec   (HL)                    ; Decrement semaphore
              	
682C: E1      	      pop   HL                      ; F into L
682D: CB55    	      bit   2, L                    ; Test IFF2 flag
682F: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
6831: FB      	      ei                            ; Re-enable interrupts
              	
6832: E1      	      pop   HL                      ; Done
              	
6833: B7      	      or    A, A                    ; Set Z flag according to A
6834: C8      	      ret   Z
              	
              	      ; Get jump table entry and jump to state
6835: 3A6478  	      ld    A, (clock_state)
6838: B7      	      or    A, A
6839: 2812    	      jr    Z, clock_app_start
              	
              	      get_jp_table_entry clock_jp_tbl
683B: D5      	      push DE
              	
683C: 1600    	      ld    D, 0                    ; DE becomes offset by doubling A
683E: 5F      	      ld    E, A
683F: CB23    	      sla   E
6841: CB12    	      rl    D
              	
6843: 211E6C  	      ld    HL, clock_jp_tbl              ; HL = pointer to jump table
6846: 19      	      add   HL, DE                  ; Add offset to pointer
              	
6847: 5E      	      ld    E, (HL)                 ; Load HL pair into DE
6848: 23      	      inc   HL
6849: 56      	      ld    D, (HL)
              	
684A: EB      	      ex    DE, HL                  ; DE becomes HL for return
              	
684B: D1      	      pop   DE
684C: E9      	      jp    (HL)
              	
              	;---- State 00 -------------------------------------------------------
              	;     This is where the app starts from fresh.
684D:         	clock_app_start
684D: 3E00    	      ld    A, 0                    ; Blank display buffers
684F: 011B00  	      ld    BC, 27
6852: 214078  	      ld    HL, staging_row1
6855: CD4075  	      call  memset
              	
6858: AF      	      xor   A, A                    ; Reset clock semaphores
6859: 3A0378  	      ld    A, (clock_upd_req_sem)
685C: 3A0478  	      ld    A, (clock_upd_sem)
              	
685F: 3E01    	      ld    A, 0x01                 ; Use DSKY display update effect
6861: 326378  	      ld    (display_effect), A
              	
              	      set_valid_btn_mask BTN_ESC
6864: F5      	      push  AF
6865: C5      	      push  BC
              	
6866: 3A5D78  	      ld    A, (btn_state)          ; Ack all un-ack'd buttons by
6869: 47      	      ld    B, A                    ; OR'ing them with all ack'd
686A: 3A5C78  	      ld    A, (btn_ack)            ; buttons.
686D: B0      	      or    A, B
686E: 325C78  	      ld    (btn_ack), A
              	
6871: 3E08    	      ld    A, BTN_ESC
6873: 325B78  	      ld    (btn_valid), A          ; Load new mask
              	
6876: C1      	      pop   BC
6877: F1      	      pop   AF
              	      set_state clock_state, CLOCK_UPDATE
6878: F5      	      push  AF
              	
6879: 3E01    	      ld    A, CLOCK_UPDATE
687B: 326478  	      ld    (clock_state), A
              	
687E: F1      	      pop   AF
              	
687F: C9      	      ret
              	
              	;---- State 01 -------------------------------------------------------
              	;     This is the state in which the clock display is updated with the
              	;     current time.
              	;
              	;     This state is always executed when the clock app starts, to fill
              	;     the display with the configured times, and then once per minute
              	;     as signalled by the clock_upd_sem semaphore containing a
              	;     non-zero value.
              	;
              	;     The clock_upd_req_sem semaphore is set at the end of this state
              	;     to request that the clock_upd_sem semaphore be incremented by
              	;     the RTC per-minute ISR.
6880:         	clock_update
              	#local
              	;---- Reset counters, pointers etc as required for a fresh run
6880: AF      	      xor   A, A
6881: 327478  	      ld    (clock_row), A          ; Display row starts at 0
              	
6884: 216578  	      ld    HL, clock_tz1_sw        ; Timezone switch pointer
6887: 227578  	      ld    (tz_sw_ptr), HL
              	
688A: 214078  	      ld    HL, staging_row1        ; Display row buffer pointer
688D: 227978  	      ld    (row_buf_ptr), HL
              	
              	;---- Read in timezone switch settings
6890: 0E09    	      ld    C, TZ_SW1_REG
6892: 216578  	      ld    HL, clock_tz1_sw
              	
6895: EDA2    	      ini                           ; Timezone 1 switch
6897: 0C      	      inc   C
6898: EDA2    	      ini                           ; Timezone 2 switch
689A: 0C      	      inc   C
689B: EDA2    	      ini                           ; Timezone 3 switch
              	
              	;---- Read in time from RTC
689D: 3E0E    	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
689F: D31E    	      out   (RTC_CTRL), A
              	
68A1: 0E12    	      ld    C, RTC_MIN
68A3: 216878  	      ld    HL, clock_rtc_min
              	
68A6: EDA2    	      ini                           ; Minutes register
68A8: 0C      	      inc   C                       ; Inc twice to skip alarm reg
68A9: 0C      	      inc   C
68AA: EDA2    	      ini                           ; Hours register
68AC: 0C      	      inc   C                       ; Inc twice to skip alarm reg
68AD: 0C      	      inc   C
68AE: EDA2    	      ini                           ; Day register
68B0: 0C      	      inc   C                       ; Inc twice to skip alarm reg
68B1: 0C      	      inc   C
68B2: EDA2    	      ini                           ; Day of week register
68B4: 0C      	      inc   C
68B5: EDA2    	      ini                           ; Month register
68B7: 0C      	      inc   C
68B8: EDA2    	      ini                           ; Year register
              	
68BA: 3E06    	      ld    A, RTC_CTRL_CFG
68BC: D31E    	      out   (RTC_CTRL), A
              	
              	
              	;---- Main loop for computing display rows
68BE:         	row_loop
68BE: AF      	      xor   A, A                    ; Reset row borrows/carrys/flags
68BF: 327F78  	      ld    (row_flags), A
              	
              	      ; Calculate pointer to TZ ROM entry for current row
68C2: 2A7578  	      ld    HL, (tz_sw_ptr)         ; Get value of timezone switches
68C5: 7E      	      ld    A, (HL)                 ; for this row
68C6: 2F      	      cpl                           ; Switches pull down, so invert
68C7: E67F    	      and   A, 0x7F                 ; MSb is reserved
              	
68C9: 2100C0  	      ld    HL, TZ_ROM_BASE         ; Compute pointer to TZ ROM entry.
68CC: 5F      	      ld    E, A                    ; HL is base of TZ ROM, DE will be
68CD: AF      	      xor   A, A                    ; offset.
              	
68CE: CB23    	      sla   E                       ; Each entry is 32 bytes, so shift
68D0: 17      	      rla                           ; left 5 bits
68D1: CB23    	      sla   E
68D3: 17      	      rla
68D4: CB23    	      sla   E
68D6: 17      	      rla
68D7: CB23    	      sla   E
68D9: 17      	      rla
68DA: CB23    	      sla   E
68DC: 17      	      rla
              	
68DD: 57      	      ld    D, A
68DE: 19      	      add   HL, DE
              	
68DF: 227778  	      ld    (tz_rom_ptr), HL        ; Save pointer, and xfer to IX
68E2: E5      	      push  HL
68E3: DDE1    	      pop   IX
              	
              	      ; Process this timezone setting?
68E5: DD7E00  	      ld    A, (IX+0)               ; Entry contains data?
68E8: FEFF    	      cp    A, 0xFF
68EA: CAA86B  	      jp    Z, row_loop_done        ; No if 0xFF, skip row
              	
68ED: CB47    	      bit   0, A                    ; If bit 0 is set, this is a TZ
68EF: CAA86B  	      jp    Z, row_loop_done        ; Skip if not a TZ
              	
              	      ; Take a copy of all of the RTC time registers
68F2: 216878  	      ld    HL, clock_rtc_min
68F5: 116E78  	      ld    DE, clock_tz_min
68F8: 010500  	      ld    BC, 5
68FB: CD0075  	      call  memcpy
              	
              	
              	      ; Execution can be diverted to this point from later in the
              	      ; program, if all of the DST match flags have been set. This
              	      ; causes an additional hour to be added onto the time that was
              	      ; computed during the first pass, which then also compensates
              	      ; for any additional hour/day/month carrys that may occurr as a
              	      ; result.
68FE:         	begin_computation
68FE: AF      	      xor   A, A                    ; Reset row borrows/carrys/flags.
68FF: 327D78  	      ld    (row_carrys), A         ; Do that here so that bor/car
6902: 327E78  	      ld    (row_borrows), A        ; from pre-DST computation do not
              	                                    ; apply twice.
              	
              	
              	;---- Compute minutes for current timezone ---------------------------
              	      ; Functionality not implemented at this time.
6905: 00      	      nop
              	
              	
              	;---- Compute hours for current timezone -----------------------------
6906: 3A6F78  	      ld    A, (clock_tz_hrs)       ; Load hours BCD into A
6909: E67F    	      and   A, 0x7F                 ; Remove AM/PM bit (working in
              	                                    ; 24hr time)
              	
690B: 0E24    	      ld    C, 0x24
              	
690D: DD4606  	      ld    B, (IX+6)               ; Load hrs offset from TZ ROM
              	
6910: 217F78  	      ld    HL, row_flags           ; If the "Apply DST" flag is set,
6913: CB7E    	      bit   7, (HL)                 ; replace offset with 1 to move
6915: 2802    	      jr    Z, $+4                  ; clock forward.
6917: 0601    	      ld    B, 0x01
              	
6919: 80      	      add   A, B                    ; Add offset to hours
691A: 27      	      daa
              	
691B: F22E69  	      jp    P, no_hrs_borrow        ; If positive, check for overflow
              	
691E: 81      	      add   A, C                    ; Result was negative, so add 24
691F: 27      	      daa
6920: 217E78  	      ld    HL, row_borrows         ; Record a borrow (-1 day)
6923: CBCE    	      set   1, (HL)
              	
6925: F5      	      push  AF
6926: 215078  	      ld    HL, staging_row3
6929: 3642    	      ld    (HL), 'B'
692B: F1      	      pop   AF
              	
692C: 180A    	      jr    no_hrs_carry
              	
692E:         	no_hrs_borrow
692E: B9      	      cp    A, C                    ; Has result overflowed hour 24?
692F: 3807    	      jr    C, no_hrs_carry         ; If C, result < 24
              	
6931: 91      	      sub   A, C                    ; Result overflowed, sub 24
6932: 27      	      daa
6933: 217D78  	      ld    HL, row_carrys          ; Record a carry (+1 day)
6936: CBCE    	      set   1, (HL)
              	
6938:         	no_hrs_carry
6938: 326F78  	      ld    (clock_tz_hrs), A       ; Store hours back
              	
              	
              	;---- Compute day of month -------------------------------------------
              	      ; First check for leap year
693B: 21306C  	      ld    HL, days_common_year    ; Default to common year array
              	
693E: 3A6D78  	      ld    A, (clock_rtc_year)     ; Load year BCD into A
6941: E603    	      and   0x03
6943: 2003    	      jr    NZ, not_leap_year       ; If zero, in a leap year
              	
6945: 21406C  	      ld    HL, days_leap_year      ; Override to leap year array
              	
6948:         	not_leap_year
              	      ; Load number of days in month from array
6948: 3A7278  	      ld    A, (clock_tz_mon)       ; Load month BCD into A
694B: CDA76C  	      call  bcd_to_dec
694E: 3D      	      dec   A                       ; Sub 1 for offset into array
694F: 1600    	      ld    D, 0                    ; DE becomes array offset
6951: 5F      	      ld    E, A
6952: 19      	      add   HL, DE                  ; Add offset to pointer
6953: 46      	      ld    B, (HL)                 ; B is number of days in month
6954: 227B78  	      ld    (day_array_ptr), HL     ; Save pointer
              	
              	      ; Store the number of days in the month for use later on
6957: 217378  	      ld    HL, clock_tz_days_in_mon
695A: 70      	      ld    (HL), B
              	
              	      ; Apply borrow/carry to day of month
695B: 3A7078  	      ld    A, (clock_tz_day)       ; Load day BCD into A
              	
695E: 217E78  	      ld    HL, row_borrows         ; Test hrs borrow bit
6961: CB4E    	      bit   1, (HL)
              	
6963: 2813    	      jr    Z, no_day_borrow        ; If Z, no borrow
              	
6965: 217178  	      ld    HL, clock_tz_dow        ; Decrement the day-of-week
6968: 35      	      dec   (HL)
6969: 2002    	      jr    NZ, $+4
696B: 3607    	      ld    (HL), 0x07
              	
696D: 3D      	      dec   A                       ; Hrs borrow, dec to prev day
696E: 27      	      daa
              	
696F: 202A    	      jr    NZ, day_continue        ; If day is 0, record borrow
              	
              	      ; Day is left at zero and will be corrected when calculating new
              	      ; month from borrow.
6971: 217E78  	      ld    HL, row_borrows         ; Record a borrow (-1 month)
6974: CBD6    	      set   2, (HL)
              	
6976: 1823    	      jr    day_continue
              	
6978:         	no_day_borrow
6978: 217D78  	      ld    HL, row_carrys          ; Test hrs carry bit
697B: CB4E    	      bit   1, (HL)
              	
697D: 281C    	      jr    Z, day_continue         ; If Z, no carry
              	
697F: 4F      	      ld    C, A                    ; Save A while incrementing DOW
              	
6980: 217178  	      ld    HL, clock_tz_dow        ; Increment the day-of-week
6983: 7E      	      ld    A, (HL)
6984: 3C      	      inc   A
6985: E607    	      and   0x07
6987: 2002    	      jr    NZ, $+4                 ; If NZ, still in valid range 1..7
6989: 3E01    	      ld    A, 0x01                 ; Inc reached zero, reset to 1
698B: 77      	      ld    (HL), A
              	
698C: 79      	      ld    A, C                    ; Restore A
698D: 3C      	      inc   A                       ; Hrs carry, inc to next day
698E: 27      	      daa
              	
698F: B8      	      cp    A, B                    ; Overflowed num of days in month?
6990: 3809    	      jr    C, day_continue         ; C if A < B
6992: 2807    	      jr    Z, day_continue         ; Z if A == B
              	
6994: 3E01    	      ld    A, 0x01                 ; On carry, day can be set to 1
              	
6996: 217D78  	      ld    HL, row_carrys          ; Record a carry (+1 month)
6999: CBD6    	      set   2, (HL)
              	
699B:         	day_continue
699B: 327078  	      ld    (clock_tz_day), A       ; Store day back
              	
              	
              	;---- Compute month --------------------------------------------------
699E: 3A7278  	      ld    A, (clock_tz_mon)       ; Load month BCD into A
              	
69A1: 217E78  	      ld    HL, row_borrows         ; Test day borrow bit
69A4: CB56    	      bit   2, (HL)
              	
69A6: 2821    	      jr    Z, no_mon_borrow        ; If Z, no borrow
              	
              	      ; If a day borrow occurred, the month number needs to be
              	      ; decremented, and the day reset to the last day of the new
              	      ; month. So, fix month number first...
              	
69A8: 3D      	      dec   A                       ; Decrement month number
69A9: 27      	      daa
              	
69AA: 2002    	      jr    NZ, mon_borrow_fix_day  ; Did it hit zero?
              	
69AC: 3E12    	      ld    A, 0x12                 ; Reset back to month 12
              	
69AE:         	mon_borrow_fix_day
69AE: 327278  	      ld    (clock_tz_mon), A       ; Store month back now
              	
              	      ; Now use the new month number to apply the correct day number
              	
69B1: CDA76C  	      call  bcd_to_dec
69B4: 3D      	      dec   A                       ; Sub 1 for offset into array
69B5: 1600    	      ld    D, 0                    ; DE becomes array offset
69B7: 5F      	      ld    E, A
              	
69B8: 2A7B78  	      ld    HL, (day_array_ptr)
69BB: 7D      	      ld    A, L
69BC: E6F0    	      and   A, 0xF0
69BE: 6F      	      ld    L, A
              	
69BF: 19      	      add   HL, DE                  ; Add offset to pointer
69C0: 7E      	      ld    A, (HL)
69C1: 327078  	      ld    (clock_tz_day), A       ; Save corrected day number
69C4: 327378  	      ld    (clock_tz_days_in_mon), A
              	
69C7: 1824    	      jr    no_mon_carry
              	
69C9:         	no_mon_borrow
69C9: 217D78  	      ld    HL, row_carrys          ; Test day carry bit
69CC: CB56    	      bit   2, (HL)
              	
69CE: 281D    	      jr    Z, no_mon_carry         ; If Z, no carry
              	
69D0: 3C      	      inc   A                       ; Day carry, inc to next month
69D1: 27      	      daa
69D2: 327278  	      ld    (clock_tz_mon), A       ; Store month back now
              	
69D5: FE13    	      cp    A, 0x13                 ; Overflowed to 13?
69D7: 2014    	      jr    NZ, no_mon_carry        ; No if NZ, all done
              	
69D9: 3E01    	      ld    A, 0x01                 ; On overflow, reset to month 1
69DB: 327278  	      ld    (clock_tz_mon), A       ; Store month back now
              	
              	      ; Now need to load and store the number of days in this month
69DE: 2A7B78  	      ld    HL, (day_array_ptr)
69E1: CDA76C  	      call  bcd_to_dec
69E4: 3D      	      dec   A
69E5: 1600    	      ld    D, 0
69E7: 5F      	      ld    E, A
69E8: 19      	      add   HL, DE
69E9: 7E      	      ld    A, (HL)
69EA: 327378  	      ld    (clock_tz_days_in_mon), A
              	
69ED:         	no_mon_carry
              	
69ED: 3A7F78  	      ld    A, (row_flags)          ; If the "Apply DST" flag is set,
69F0: CB7F    	      bit   7, A                    ; skip to display_row because it
69F2: C2F96A  	      jp    NZ, display_row         ; is not neccessary to recompute
              	                                    ; whether DST is in effect.
              	
              	      ; At this stage the correct time and date for the timezone has
              	      ; been computed, and now can determine if DST is in effect for
              	      ; this timezone.
              	
              	      ; First, does DST even apply in this timezone?
69F5: DD7E0A  	      ld    A, (IX+10)              ; Load DST start options
69F8: B7      	      or    A, A
69F9: CAF96A  	      jp    Z, display_row          ; DST does not apply if it doesnt
              	                                    ; start, show info on display row
              	
              	
              	;---- DST check #1: within the months that DST applies? --------------
              	      ;
              	      ; This is a definitive test to determine if DST SHOULD be in
              	      ; effect.
              	      ;
              	      ; To achieve this, first work out the order of the start and end
              	      ; months, e.g. if the end month is lower than the start month
              	      ; then they should be reversed, and then check if the current
              	      ; month falls within that range.
69FC: DD4607  	      ld    B, (IX+7)               ; Load start month from TZ ROM
69FF: DD4E0B  	      ld    C, (IX+11)              ; Load end month from TZ ROM
6A02: C5      	      push  BC                      ; Save these for later
              	
6A03: 78      	      ld    A, B
6A04: B9      	      cp    A, C
6A05: 3810    	      jr    C, dst_end_mon_higher
              	
              	      ; End month is lower than start month, add 12 to reverse order
6A07: 79      	      ld    A, C
6A08: 1612    	      ld    D, 0x12
6A0A: 82      	      add   A, D
6A0B: 27      	      daa
6A0C: 4F      	      ld    C, A
              	
6A0D: 3A7278  	      ld    A, (clock_tz_mon)       ; Must also offset current month,
6A10: B8      	      cp    A, B                    ; but only if less than the start
6A11: 3007    	      jr    NC, check1              ; month.
              	
6A13: 82      	      add   A, D
6A14: 27      	      daa
              	
6A15: 1803    	      jr    check1
              	
6A17:         	dst_end_mon_higher
6A17: 3A7278  	      ld    A, (clock_tz_mon)       ; Load current month unaffected
              	
6A1A:         	check1
6A1A: B8      	      cp    A, B
6A1B: 283B    	      jr    Z, check_start_cond     ; cur_mon == start_mon
6A1D: 380F    	      jr    C, check1_done          ; cur_mon < start_mon
              	
6A1F: B9      	      cp    A, C
6A20: CAA36A  	      jp    Z, check_end_cond       ; cur_mon == end_mon
6A23: 3009    	      jr    NC, check1_done         ; cur_mon > end_mon
              	
              	      ; At this point DST is definitively IN EFFECT
6A25: 3E07    	      ld    A, 0x07                 ; Set all match flags
6A27: 327F78  	      ld    (row_flags), A
6A2A: C1      	      pop   BC                      ; No longer needed
              	
6A2B: C3EA6A  	      jp    check_for_dst
              	
6A2E:         	check1_done
              	
              	
              	;---- DST check #2: outside the months that DST applies? -------------
              	      ;
              	      ; This is a definitive test to determine if DST SHOULD NOT be in
              	      ; effect.
              	      ;
              	      ; This is achieved in a similar way to the first check, except
              	      ; this time we reverse the order of start/end months if the
              	      ; start month is lower than the end month.
              	
6A2E: C1      	      pop   BC                      ; Restore original star/end months
6A2F: C5      	      push  BC                      ; Save them again
              	
6A30: 78      	      ld    A, B
6A31: B9      	      cp    A, C
6A32: 300F    	      jr    NC, nodst_start_mon_higher
              	
              	      ; Start month is lower than end month, add 12 to reverse order
6A34: 1612    	      ld    D, 0x12
6A36: 82      	      add   A, D
6A37: 27      	      daa
6A38: 47      	      ld    B, A
              	
6A39: 3A7278  	      ld    A, (clock_tz_mon)       ; Must also offset current month,
6A3C: B9      	      cp    A, C                    ; but only if less than the end
6A3D: 3007    	      jr    NC, check2              ; month.
              	
6A3F: 82      	      add   A, D
6A40: 27      	      daa
              	
6A41: 1803    	      jr    check2
              	
6A43:         	nodst_start_mon_higher
6A43: 3A7278  	      ld    A, (clock_tz_mon)       ; Load current month unaffected
              	
6A46:         	check2
6A46: B9      	      cp    A, C
6A47: 285A    	      jr    Z, check_end_cond       ; cur_mon == end_mon
6A49: 380D    	      jr    C, check_start_cond     ; cur_mon < end_mon
              	
6A4B: B8      	      cp    A, B
6A4C: 280A    	      jr    Z, check_start_cond     ; cur_mon == start_mon
6A4E: 3008    	      jr    NC, check_start_cond    ; cur_mon > start_mon
              	
              	      ; At this point DST is definitively NOT IN EFFECT
6A50: AF      	      xor   A, A                    ; Clear all match flags
6A51: 327F78  	      ld    (row_flags), A
6A54: C1      	      pop   BC                      ; No longer needed
              	
6A55: C3F96A  	      jp    display_row
              	
              	
              	;---- DST check #3: Progressively check start conditions -------------
6A58:         	check_start_cond
6A58: C1      	      pop   BC
6A59: C5      	      push  BC
6A5A: 3A7278  	      ld    A, (clock_tz_mon)
              	
6A5D: B8      	      cp    A, B                    ; In start month?
6A5E: 2043    	      jr    NZ, check_end_cond      ; No if NZ (should be end month)
              	
              	      ; Yes - In start month
6A60: 3A7278  	      ld    A, (clock_tz_mon)
6A63: 217F78  	      ld    HL, row_flags
6A66: CBD6    	      set   2, (HL)                 ; Set month match flag
6A68: C1      	      pop   BC                      ; No longer need this on stack
              	
6A69: 3A7078  	      ld    A, (clock_tz_day)       ; Load current day into B
6A6C: 47      	      ld    B, A
              	
6A6D: DD4E0A  	      ld    C, (IX+10)              ; Load start options from TZ ROM
              	
6A70: CB41    	      bit   0, C                    ; If bit 0 of start options was
6A72: 2805    	      jr    Z, check3_last_sun      ; set, find the day number of the
6A74: CD706C  	      call  find_first_sunday       ; first Sunday of the month
6A77: 1810    	      jr    check3_match_day
              	
6A79:         	check3_last_sun
6A79: CB49    	      bit   1, C                    ; If bit 1 of the start options
6A7B: 2805    	      jr    Z, check3_second_sun    ; was set, find the day number of
6A7D: CD8B6C  	      call  find_last_sunday        ; the last Sunday of the month
6A80: 1807    	      jr    check3_match_day
              	
6A82:         	check3_second_sun
6A82: CB51    	      bit   2, C                    ; If bit 2 of start options was
6A84: 281D    	      jr    Z, check_end_cond       ; set, find the day number of the
6A86: CDA06C  	      call  find_second_sunday      ; second Sunday of the month. If
              	                                    ; bit 2 not set, some other bit is
              	                                    ; and that is unhandled (no DST).
              	
6A89:         	check3_match_day
              	      ; There are 3 tests for matching the day:
              	      ;
              	      ; 1. Day of month is less than start day, no DST
              	      ; 2. Day of month is same as start day, maybe no DST just yet
              	      ;    (depends on final check of hours)
              	      ; 3. Day of month is greater than start day, DST in effect
6A89: B8      	      cp    A, B
6A8A: 2808    	      jr    Z, check3_day_equal     ; Maybe in effect
6A8C: 306B    	      jr    NC, display_row         ; Less than, not in effect
              	
              	      ; Day is greater than start day, DST is IN EFFECT. Set remaining
              	      ; match flags
6A8E: CBC6    	      set   0, (HL)
6A90: CBCE    	      set   1, (HL)
              	
6A92: 1856    	      jr    check_for_dst
              	
6A94:         	check3_day_equal
6A94: CBCE    	      set   1, (HL)                 ; Day matches, set match flag
              	
              	      ; Final check for starting DST is if the starting hour has been
              	      ; reached.
6A96: 3A6F78  	      ld    A, (clock_tz_hrs)
6A99: DD4609  	      ld    B, (IX+9)               ; Load start hour from TZ ROM
              	
6A9C: B8      	      cp    A, B
6A9D: 385A    	      jr    C, display_row          ; Hour is less than start, no DST
              	
6A9F: CBC6    	      set   0, (HL)                 ; Hour matches, set match flag
              	
6AA1: 1847    	      jr    check_for_dst
              	
              	
              	;---- DST check #4: Progressively check end conditions ---------------
6AA3:         	check_end_cond
6AA3: C1      	      pop   BC                      ; POP but dont PUSH again
6AA4: 3A7278  	      ld    A, (clock_tz_mon)
              	
6AA7: B9      	      cp    A, C                    ; In end month?
6AA8: 204F    	      jr    NZ, display_row         ; No if NZ (should have been?)
              	
              	      ; Yes - In end month
6AAA: 3A7278  	      ld    A, (clock_tz_mon)
6AAD: 217F78  	      ld    HL, row_flags
6AB0: CBD6    	      set   2, (HL)                 ; Set month match flag
              	
6AB2: 3A7078  	      ld    A, (clock_tz_day)       ; Load current day into B
6AB5: 47      	      ld    B, A
              	
6AB6: DD4E0E  	      ld    C, (IX+14)              ; Load end options from TZ ROM
              	
6AB9: CB41    	      bit   0, C                    ; If bit 0 of end options was set,
6ABB: 2805    	      jr    Z, check4_last_sun      ; find the day number of the first
6ABD: CD706C  	      call  find_first_sunday       ; Sunday of the month
6AC0: 1807    	      jr    check4_match_day
              	
6AC2:         	check4_last_sun
6AC2: CB49    	      bit   1, C                    ; If bit 1 of the start options
6AC4: 2833    	      jr    Z, display_row          ; was set, find the day number of
6AC6: CD8B6C  	      call  find_last_sunday        ; the last Sunday of the month. If
              	                                    ; bit 1 not set, some other bit is
              	                                    ; and that is unhandled (no DST).
              	
6AC9:         	check4_match_day
              	      ; There are 3 tests for matching the day:
              	      ;
              	      ; 1. Day of month is less than end day, DST in effect
              	      ; 2. Day of month is same as end day, DST may have ended
              	      ;    (depends on final check of hours)
              	      ; 3. Day of month is greater than end day, no DST
6AC9: B8      	      cp    A, B
6ACA: 2808    	      jr    Z, check4_day_equal     ; Maybe ended
6ACC: 381C    	      jr    C, check_for_dst        ; Greater than, not in effect
              	
              	      ; Day is less than end day, DST is IN EFFECT. Set remaining
              	      ; match flags
6ACE: CBC6    	      set   0, (HL)
6AD0: CBCE    	      set   1, (HL)
              	
6AD2: 1816    	      jr    check_for_dst
              	
6AD4:         	check4_day_equal
6AD4: CBCE    	      set   1, (HL)                 ; Day matches, set match flag
              	
              	      ; Final check for ending DST is if the ending hour has been
              	      ; reached.
6AD6: 3A6F78  	      ld    A, (clock_tz_hrs)
6AD9: DD460D  	      ld    B, (IX+13)              ; Load end hour from TZ ROM
              	
6ADC: 3C      	      inc   A                       ; What would the time be with DST?
6ADD: 27      	      daa
              	
6ADE: FE24    	      cp    A, 0x24                 ; Reset on overflow
6AE0: 2001    	      jr    NZ, $+3
6AE2: AF      	      xor   A, A
              	
6AE3: B8      	      cp    A, B
6AE4: 2813    	      jr    Z, display_row          ; cur_hour == end_hour, no DST
6AE6: 3011    	      jr    NC, display_row         ; cur_hour > end_hour, no DST
              	
6AE8: CBC6    	      set   0, (HL)                 ; Hour <, set match flag
              	
              	
              	;---- Check DST match flags ------------------------------------------
6AEA:         	check_for_dst
6AEA: 3A7F78  	      ld    A, (row_flags)
6AED: FE07    	      cp    A, 7                    ; Are all DST flags set?
6AEF: 2008    	      jr    NZ, display_row         ; No if NZ, update row display
              	
6AF1: CBFF    	      set   7, A                    ; Set "Apply DST" flag
6AF3: 327F78  	      ld    (row_flags), A
6AF6: C3FE68  	      jp    begin_computation       ; Re-run computation to add 1 hour
              	
              	
              	;---- Enable dimming, and display time or date on a row --------------
6AF9:         	display_row
              	      ; Enable dimming of the display if configured
6AF9: DB08    	      in    A, (BTN_REG)            ; Read buttons and switches
6AFB: 2F      	      cpl                           ; Buttons pull down, make positive
6AFC: 1F      	      rra                           ; Move upper nibble to lower
6AFD: 1F      	      rra
6AFE: 1F      	      rra
6AFF: 1F      	      rra
6B00: E603    	      and   A, 0x03                 ; 2 LSbs are row dimming selector
6B02: 3C      	      inc   A                       ; Testing, row to 1
6B03: 47      	      ld    B, A                    ; Save for later
              	
6B04: 3A7478  	      ld    A, (clock_row)          ; Get display row counter and INC.
6B07: 3C      	      inc   A                       ; Row counter range is 0..2, so
              	                                    ; make comparable to switch config
              	                                    ; which is 1..3. Switches set to 0
              	                                    ; means dimming not enabled.
              	
6B08: B8      	      cp    A, B                    ; Compare row ctr with switches
6B09: 2015    	      jr    NZ, no_dimming          ; No match or dimming not enabled
              	
              	      ; Dimming enabled on this row. Dimming in effect between 2100
              	      ; and 0600 hours.
6B0B: 3A6F78  	      ld    A, (clock_tz_hrs)       ; Load hours for this row
              	
6B0E: FE21    	      cp    A, 0x21
6B10: 2806    	      jr    Z, dimming_on           ; hour == 2100
6B12: 3004    	      jr    NC, dimming_on          ; hour > 2100
              	
6B14: FE06    	      cp    A, 0x06
6B16: 3004    	      jr    NC, dimming_off         ; hour >= 0600
              	
6B18:         	dimming_on
6B18: 3E01    	      ld    A, 0x01                 ; Enable dimming
6B1A: 1801    	      jr    apply_dimming
              	
6B1C:         	dimming_off
6B1C: AF      	      xor   A, A
              	
6B1D:         	apply_dimming
6B1D: 328A78  	      ld    (disp_dim), A
              	
6B20:         	no_dimming
              	      ; The MSb switch position indicates if the row should be
              	      ; displaying a time (low) or date (high)
6B20: 2A7578  	      ld    HL, (tz_sw_ptr)         ; Get value of timezone switches
6B23: 7E      	      ld    A, (HL)                 ; for this row
6B24: 2F      	      cpl                           ; Switches pull down, so invert
6B25: CB7F    	      bit   7, A
              	
6B27: 203F    	      jr    NZ, display_date
              	
              	
              	;---- Time display ---------------------------------------------------
6B29:         	display_time
              	      ; Load the name of the timezone into the beginning of this row
6B29: 2A7978  	      ld    HL, (row_buf_ptr)       ; Row pointer to DE
6B2C: EB      	      ex    DE, HL
6B2D: 2A7778  	      ld    HL, (tz_rom_ptr)        ; TZ ROM pointer to HL, TZ name
6B30: 23      	      inc   HL                      ; begins from second byte
6B31: 010300  	      ld    BC, 3
6B34: CD2075  	      call  strncpy
              	
6B37: EB      	      ex    DE, HL                  ; Save ptr for later
6B38: E5      	      push  HL
              	
              	      ; If in DST, add a + to indicate it
6B39: 217F78  	      ld    HL, row_flags
6B3C: 3E20    	      ld    A, ' '
              	
6B3E: CB7E    	      bit   7, (HL)
6B40: 2802    	      jr    Z, $+4
6B42: 3E2B    	      ld    A, '+'
              	
6B44: E1      	      pop   HL                      ; Restore ptr
6B45: 77      	      ld    (HL), A
6B46: 23      	      inc   HL
              	
              	      ; Place hours and minutes into display buffer
6B47: 3A6F78  	      ld    A, (clock_tz_hrs)       ; Hours value, in BCD
6B4A: 0602    	      ld    B, 2
              	
6B4C:         	hrs_min_to_buf
6B4C: 4F      	      ld    C, A                    ; Save a copy
              	
6B4D: 1F      	      rra                           ; Tens digit is upper nibble, move
6B4E: 1F      	      rra                           ; to lower nibble
6B4F: 1F      	      rra
6B50: 1F      	      rra
6B51: E607    	      and   A, 0x07                 ; Remove AM/PM, keep only 3 LSb's
6B53: C630    	      add   A, 0x30                 ; Add 0x30 to make ASCII char val
6B55: 77      	      ld    (HL), A                 ; Store char val into disp buf
6B56: 23      	      inc   HL
              	
6B57: 79      	      ld    A, C                    ; Units digit
6B58: E60F    	      and   A, 0x0F
6B5A: C630    	      add   A, 0x30
6B5C: 77      	      ld    (HL), A
6B5D: 23      	      inc   HL
              	
6B5E: 3A6E78  	      ld    A, (clock_tz_min)       ; Load mins value for next iter
              	
6B61: 10E9    	      djnz  hrs_min_to_buf
              	
6B63: 227978  	      ld    (row_buf_ptr), HL       ; Save updated row buffer pointer
              	                                    ; which now points to the next row
6B66: 1840    	      jr    row_loop_done
              	
              	
              	;---- Date display ---------------------------------------------------
6B68:         	display_date
6B68: 2A7978  	      ld    HL, (row_buf_ptr)       ; Row buffer is destination
6B6B: EB      	      ex    DE, HL
              	
6B6C: 3A7178  	      ld    A, (clock_tz_dow)       ; DOW forms offset after << 2
6B6F: 17      	      rla
6B70: 17      	      rla
6B71: E61C    	      and   0x1C
              	
6B73: 21506C  	      ld    HL, short_day_names     ; Add offset to L
6B76: 0600    	      ld    B, 0
6B78: 4F      	      ld    C, A
6B79: 09      	      add   HL, BC
              	
6B7A: 010300  	      ld    BC, 3                   ; Copy day name to start of row
6B7D: CD2075  	      call  strncpy
              	
6B80: EB      	      ex    DE, HL
              	
              	      ; Place month and day number into display buffer
6B81: 3A7278  	      ld    A, (clock_tz_mon)       ; Month value, in BCD
6B84: 0602    	      ld    B, 2
              	
6B86:         	mon_day_to_buf
6B86: 4F      	      ld    C, A                    ; Save a copy
              	
6B87: 1F      	      rra                           ; Tens digit is upper nibble, move
6B88: 1F      	      rra                           ; to lower nibble
6B89: 1F      	      rra
6B8A: 1F      	      rra
6B8B: E603    	      and   A, 0x03                 ; Keep only 2 LSb's
6B8D: C630    	      add   A, 0x30                 ; Add 0x30 to make ASCII char val
6B8F: 77      	      ld    (HL), A                 ; Store char val into disp buf
6B90: 23      	      inc   HL
              	
6B91: 79      	      ld    A, C                    ; Units digit
6B92: E60F    	      and   A, 0x0F
6B94: C630    	      add   A, 0x30
6B96: 77      	      ld    (HL), A
6B97: 23      	      inc   HL
              	
6B98: 78      	      ld    A, B                    ; Only add / between mon and day
6B99: 3D      	      dec   A
6B9A: 2807    	      jr    Z, mon_day_dec
              	
6B9C: 3E2F    	      ld    A, '/'                  ; Add / to separate mon and day
6B9E: 77      	      ld    (HL), A
6B9F: 23      	      inc   HL
              	
6BA0: 3A7078  	      ld    A, (clock_tz_day)       ; Load day number for next iter
              	
6BA3:         	mon_day_dec
6BA3: 10E1    	      djnz  mon_day_to_buf
              	
6BA5: 227978  	      ld    (row_buf_ptr), HL       ; Save updated row buffer pointer
              	                                    ; which now points to the next row
              	
              	
              	;---- Row loop complete ----------------------------------------------
6BA8:         	row_loop_done
              	      ; Increment various pointers, counters, etc
6BA8: 217578  	      ld    HL, tz_sw_ptr           ; Next timezone switch
6BAB: 34      	      inc   (HL)
              	
6BAC: 217478  	      ld    HL, clock_row           ; Increment row counter itself
6BAF: 34      	      inc   (HL)
6BB0: 7E      	      ld    A, (HL)
              	
              	      ; Iterate again if row counter < 3
6BB1: FE03    	      cp    A, 3
6BB3: C2BE68  	      jp    NZ, row_loop
              	
              	      sem_post clock_upd_req_sem
6BB6: F5      	      push  AF
6BB7: E5      	      push  HL
              	
6BB8: ED57    	      ld    A, I                    ; IFF2 to P/V flag
6BBA: F5      	      push  AF                      ; Save flags
6BBB: F3      	      di                            ; Ensure interrupts disabled
              	
6BBC: 210378  	      ld    HL, clock_upd_req_sem
6BBF: 34      	      inc   (HL)
              	
6BC0: E1      	      pop   HL                      ; F into L
6BC1: CB55    	      bit   2, L                    ; Test IFF2 flag
6BC3: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
6BC5: FB      	      ei                            ; Re-enable interrupts
              	
6BC6: E1      	      pop   HL
6BC7: F1      	      pop   AF
              	      set_state clock_state, CLOCK_IDLE
6BC8: F5      	      push  AF
              	
6BC9: 3E02    	      ld    A, CLOCK_IDLE
6BCB: 326478  	      ld    (clock_state), A
              	
6BCE: F1      	      pop   AF
              	
6BCF: C9      	      ret
              	#endlocal
              	
              	;---- State 02 -------------------------------------------------------
              	;     The clock app idles in this state while waiting for one of two
              	;     events to happen:
              	;
              	;     1. Esc button is pressed, and the app is exited
              	;     2. clock_upd_sem contains a non-zero value, and the displays
              	;        are updated
6BD0:         	clock_idle
              	#local
6BD0: 3A5D78  	      ld    A, (btn_state)          ; Check if the escape button is
6BD3: CB5F    	      bit   BTN_ESC_BIT, A          ; pressed, if so, proceed to exit
6BD5: 280F    	      jr    Z, check_semaphore
              	
              	      ack_btn BTN_ESC_BIT
6BD7: E5      	      push  HL
              	
6BD8: 215C78  	      ld    HL, btn_ack             ; Ack the button
6BDB: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
6BDD: E1      	      pop   HL
              	      set_state clock_state, CLOCK_EXIT
6BDE: F5      	      push  AF
              	
6BDF: 3E03    	      ld    A, CLOCK_EXIT
6BE1: 326478  	      ld    (clock_state), A
              	
6BE4: F1      	      pop   AF
              	
6BE5: C9      	      ret
              	
6BE6:         	check_semaphore
              	      sem_trywait clock_upd_sem     ; Check clock_upd_sem and proceed
6BE6: E5      	      push  HL
              	
6BE7: ED57    	      ld    A, I                    ; IFF2 to P/V flag
6BE9: F5      	      push  AF                      ; Save flags
6BEA: F3      	      di                            ; Ensure interrupts disabled
              	
6BEB: 210478  	      ld    HL, clock_upd_sem
6BEE: 7E      	      ld    A, (HL)                 ; Load semaphore value for return
6BEF: B7      	      or    A, A                    ; Semaphore value greater than 0?
6BF0: 2801    	      jr    Z, $+3                  ; If Z, return 0, go to done
              	
6BF2: 35      	      dec   (HL)                    ; Decrement semaphore
              	
6BF3: E1      	      pop   HL                      ; F into L
6BF4: CB55    	      bit   2, L                    ; Test IFF2 flag
6BF6: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
6BF8: FB      	      ei                            ; Re-enable interrupts
              	
6BF9: E1      	      pop   HL                      ; Done
              	
6BFA: B7      	      or    A, A                    ; Set Z flag according to A
6BFB: C8      	      ret   Z                       ; to update clock display if > 0
              	
              	      set_state clock_state, CLOCK_UPDATE
6BFC: F5      	      push  AF
              	
6BFD: 3E01    	      ld    A, CLOCK_UPDATE
6BFF: 326478  	      ld    (clock_state), A
              	
6C02: F1      	      pop   AF
              	
6C03: C9      	      ret
              	#endlocal
              	
              	;---- State 03 -------------------------------------------------------
              	;     Exit the config app by releasing the foreground mutex.
6C04:         	clock_exit_app
              	      set_state clock_state, CLOCK_APP_START
6C04: F5      	      push  AF
              	
6C05: 3E00    	      ld    A, CLOCK_APP_START
6C07: 326478  	      ld    (clock_state), A
              	
6C0A: F1      	      pop   AF
              	      mtx_unlock foreground_mtx
6C0B: F5      	      push  AF
6C0C: E5      	      push  HL
              	
6C0D: ED57    	      ld    A, I                    ; IFF2 to P/V flag
6C0F: F5      	      push  AF                      ; Save flags
6C10: F3      	      di                            ; Ensure interrupts disabled
              	
6C11: AF      	      xor   A, A                    ; Load zero to unlock the mutex
6C12: 320078  	      ld    (foreground_mtx), A
              	
6C15: E1      	      pop   HL                      ; F into L
6C16: CB55    	      bit   2, L                    ; Test IFF2 flag
6C18: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
6C1A: FB      	      ei                            ; Re-enable interrupts
              	
6C1B: E1      	      pop   HL                      ; Done
6C1C: F1      	      pop   AF
              	
6C1D: C9      	      ret
              	
              	; State machine jump table
6C1E: 4D68    	clock_jp_tbl            .dw   clock_app_start
6C20: 8068    	                        .dw   clock_update
6C22: D06B    	                        .dw   clock_idle
6C24: 046C    	                        .dw   clock_exit_app
              	
              	; Days per month in a common year - keep aligned to 16 bytes
6C26: FFFFFFFF	      .align 0x10
6C2A: FF...   	
6C30: 31283130	days_common_year        .dm   0x31, 0x28, 0x31, 0x30, 0x31, 0x30
6C34: 3130    	
6C36: 31313031	                        .dm   0x31, 0x31, 0x30, 0x31, 0x30, 0x31
6C3A: 3031    	
              	
              	; Days per month in a leap year - keep aligned to 16 bytes
6C3C: FFFFFFFF	      .align 0x10
6C40: 31293130	days_leap_year          .dm   0x31, 0x29, 0x31, 0x30, 0x31, 0x30
6C44: 3130    	
6C46: 31313031	                        .dm   0x31, 0x31, 0x30, 0x31, 0x30, 0x31
6C4A: 3031    	
              	
              	; Short day of week names - keep aligned to 16 bytes
6C4C: FFFFFFFF	      .align 0x10
6C50: 00000000	short_day_names         .text 0, 0, 0, 0        ; Null entry
6C54: 53550000	                        .text 'SU', 0, 0        ; Each day name takes
6C58: 4D4F0000	                        .text 'MO', 0, 0        ; 4 bytes to that the
6C5C: 54550000	                        .text 'TU', 0, 0        ; day number can be
6C60: 57450000	                        .text 'WE', 0, 0        ; simply shifted by
6C64: 54480000	                        .text 'TH', 0, 0        ; two places to the
6C68: 46520000	                        .text 'FR', 0, 0        ; left for its offset.
6C6C: 53410000	                        .text 'SA', 0, 0
              	
              	
              	;---------------------------------------------------------------------
              	;     find_first_sunday                                              :
              	;                                                                    :
              	; Description                                                        :
              	;     Finds the day number of the first Sunday in a month.           :
              	;                                                                    :
              	;     Takes no parameters, but uses timezone row variables and       :
              	;     returns the result in A.                                       :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  Day number of first Sunday in BCD                           :
              	;---------------------------------------------------------------------
6C70:         	find_first_sunday
              	#local
6C70: C5      	      push  BC
              	
6C71: 3A7178  	      ld    A, (clock_tz_dow)       ; Day of week into B
6C74: 3D      	      dec   A                       ; Make day of week range 0..6
6C75: 47      	      ld    B, A
              	
6C76: 3A7078  	      ld    A, (clock_tz_day)       ; Day of month into A
6C79: CDA76C  	      call  bcd_to_dec              ; Convert from BCD to decimal
              	
6C7C: C607    	      add   A, 7                    ; Add an extra week to cater for
              	                                    ; low day numbers
              	
6C7E: 90      	      sub   A, B                    ; Subtract DOW from day
              	
6C7F: FE08    	      cp    A, 8                    ; Result is day 1-7?
6C81: 3806    	      jr    C, done                 ; Yes if C, done
              	
6C83:         	loop
6C83: D607    	      sub   A, 7                    ; Take a week off
6C85: FE08    	      cp    A, 8                    ; Result is day 1-7?
6C87: 30FA    	      jr    NC, loop                ; No if NC, go again
              	
6C89:         	done
6C89: C1      	      pop   BC
              	
6C8A: C9      	      ret
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     find_last_sunday                                               :
              	;                                                                    :
              	; Description                                                        :
              	;     Finds the day number of the last Sunday in a month.            :
              	;                                                                    :
              	;     This is done by calling find_first_sunday and then adding 7    :
              	;     as long as the day number does not exceed the number of days   :
              	;     in the current month (per clock_tz_days_in_mon).               :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  Day number of last Sunday in BCD                            :
              	;---------------------------------------------------------------------
6C8B:         	find_last_sunday
              	#local
6C8B: C5      	      push  BC
              	
6C8C: 3A7378  	      ld    A, (clock_tz_days_in_mon)
6C8F: 47      	      ld    B, A
              	
6C90: CD706C  	      call  find_first_sunday
              	
6C93:         	loop
6C93: C607    	      add   A, 7                    ; Add a week
6C95: 27      	      daa
              	
6C96: B8      	      cp    A, B                    ; Below number of days in month?
6C97: 38FA    	      jr    C, loop                 ; Yes if C, loop again
6C99: 2803    	      jr    Z, done                 ; Last day is Sunday if Z
              	
6C9B: D607    	      sub   A, 7                    ; Overshot in last loop iter, fix
6C9D: 27      	      daa
              	
6C9E:         	done
6C9E: C1      	      pop   BC
              	
6C9F: C9      	      ret
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     find_second_sunday                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Finds the day number of the second Sunday in a month.          :
              	;                                                                    :
              	;     This is done by calling find_first_sunday and then adding 7.   :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  Day number of second Sunday in BCD                          :
              	;---------------------------------------------------------------------
6CA0:         	find_second_sunday
6CA0: CD706C  	      call  find_first_sunday
6CA3: C607    	      add   A, 7
6CA5: 27      	      daa
              	
6CA6: C9      	      ret
              	
              	
              	;---------------------------------------------------------------------
              	;     bcd_to_dec                                                     :
              	;                                                                    :
              	; Description                                                        :
              	;     Convert the BCD value in A to a decimal number.                :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  Decimal converted number                                    :
              	;---------------------------------------------------------------------
6CA7:         	bcd_to_dec
6CA7: C5      	      push  BC                      ; Save BC, B is used as temp
6CA8: 4F      	      ld    C, A                    ; Store A for later
              	
6CA9: 1F      	      rra                           ; Tens to lower nibble
6CAA: 1F      	      rra
6CAB: 1F      	      rra
6CAC: 1F      	      rra
6CAD: E60F    	      and   A, 0xF                  ; Clear upper nibble
6CAF: 47      	      ld    B, A                    ; Save 1x lower nibble
6CB0: 87      	      add   A, A                    ; Lower nibble * 2
6CB1: 80      	      add   A, B                    ; Lower nibble * 3
6CB2: CB27    	      sla   A                       ; Lower nibble * 6
6CB4: 47      	      ld    B, A                    ; B = 6 * tens
6CB5: 79      	      ld    A, C                    ; Restore original BCD val
6CB6: 90      	      sub   A, B                    ; Subtract 6 * tens from BCD
              	
6CB7: C1      	      pop   BC
              	
6CB8: C9      	      ret
              	
              	; END clock_app.s
              	#include "configr_app.s"
              	;---------------------------------------------------------------------
              	;     Configuration Application                                      :
              	;                                                                    :
              	; Description                                                        :
              	;     This task is scheduled at boot and should not be descheduled.  :
              	;                                                                    :
              	;     This task runs as an application of sorts. It implements a     :
              	;     state machine which provides an interface that allows the user :
              	;     to configure the time and date of UTC (the base timezone)      :
              	;     which is then stored within the RTC peripheral.                :
              	;                                                                    :
              	;     The task self determines if it should run, signalled by the    :
              	;     foreground mutex either being null or owned.                   :
              	;---------------------------------------------------------------------
              	
              	; State machine states
0000:         	CONFIGR_APP_START       .equ  0
0001:         	CONFIGR_MAIN_MENU       .equ  0x01
0002:         	CONFIGR_ADJUST_TIME     .equ  0x02
0003:         	CONFIGR_HOURS_MSG       .equ  0x03
0004:         	CONFIGR_ADJUST_HOURS    .equ  0x04
0005:         	CONFIGR_MINUTES_MSG     .equ  0x05
0006:         	CONFIGR_ADJUST_MINS     .equ  0x06
0007:         	CONFIGR_APPLY_TIME      .equ  0x07
0008:         	CONFIGR_ADJUST_DATE     .equ  0x08
0009:         	CONFIGR_YEAR_MSG        .equ  0x09
000A:         	CONFIGR_ADJUST_YEAR     .equ  0x0A
000B:         	CONFIGR_MONTH_MSG       .equ  0x0B
000C:         	CONFIGR_ADJUST_MONTH    .equ  0x0C
000D:         	CONFIGR_DAY_MSG         .equ  0x0D
000E:         	CONFIGR_ADJUST_DAY      .equ  0x0E
000F:         	CONFIGR_DOW_MSG         .equ  0x0F
0010:         	CONFIGR_ADJUST_DOW      .equ  0x10
0011:         	CONFIGR_APPLY_DATE      .equ  0x11
0012:         	CONFIGR_EXIT            .equ  0x12
              	
              	#data RAM
7880: 00      	configr_state           .db 0       ; State machine value
7881: 00      	configr_menu_opt        .db 0       ; Current menu option
              	
7882: 00      	configr_rtc_min         .db 0       ; Copy of RTC registers for
7883: 00      	configr_rtc_hrs         .db 0       ; adjusting and setting time/date
7884: 00      	configr_rtc_day         .db 0
7885: 00      	configr_rtc_dow         .db 0
7886: 00      	configr_rtc_mon         .db 0
7887: 00      	configr_rtc_year        .db 0
              	
              	#data _INITIALIZED
              	#code _INITIALIZER
              	
              	#code ROM
6CB9: FFFFFFFF	      .align 0x100
6CBD: FF...   	
6D00:         	configr_app
              	      ; Try to lock the foreground mutex if it is available, or return
              	      mtx_trylock foreground_mtx, APP_CONFIGR
6D00: E5      	      push  HL
              	
6D01: ED57    	      ld    A, I                    ; IFF2 to P/V flag
6D03: F5      	      push  AF                      ; Save flags
6D04: F3      	      di                            ; Ensure interrupts disabled
              	
6D05: 210078  	      ld    HL, foreground_mtx
6D08: 7E      	      ld    A, (HL)                 ; Check current mutex owner
6D09: B7      	      or    A, A
6D0A: 2807    	      jr    Z, $+9                  ; If zero, acquire it
              	
6D0C: FE04    	      cp    A, APP_CONFIGR            ; If not zero, do we own it?
6D0E: 2806    	      jr    Z, $+8                  ; Yes if Z, return mutex value
              	
6D10: AF      	      xor   A, A                    ; No otherwise, return 0
6D11: 1803    	      jr    $+5                     ; Go to done
              	
6D13: 3E04    	      ld    A, APP_CONFIGR            ; Acquire by loading task_num into
6D15: 77      	      ld    (HL), A                 ; mutex
              	
6D16: E1      	      pop   HL                      ; F into L
6D17: CB55    	      bit   2, L                    ; Test IFF2 flag
6D19: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
6D1B: FB      	      ei                            ; Re-enable interrupts
              	
6D1C: E1      	      pop   HL                      ; Done
              	
6D1D: B7      	      or    A, A                    ; Set Z flag according to A
6D1E: C8      	      ret   Z
              	
              	      ; Check semaphore to determine if config app should run
              	      sem_trywait configr_app_sem
6D1F: E5      	      push  HL
              	
6D20: ED57    	      ld    A, I                    ; IFF2 to P/V flag
6D22: F5      	      push  AF                      ; Save flags
6D23: F3      	      di                            ; Ensure interrupts disabled
              	
6D24: 210278  	      ld    HL, configr_app_sem
6D27: 7E      	      ld    A, (HL)                 ; Load semaphore value for return
6D28: B7      	      or    A, A                    ; Semaphore value greater than 0?
6D29: 2801    	      jr    Z, $+3                  ; If Z, return 0, go to done
              	
6D2B: 35      	      dec   (HL)                    ; Decrement semaphore
              	
6D2C: E1      	      pop   HL                      ; F into L
6D2D: CB55    	      bit   2, L                    ; Test IFF2 flag
6D2F: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
6D31: FB      	      ei                            ; Re-enable interrupts
              	
6D32: E1      	      pop   HL                      ; Done
              	
6D33: B7      	      or    A, A                    ; Set Z flag according to A
6D34: C8      	      ret   Z
              	
              	      ; Get jump table entry and jump to state
6D35: 3A8078  	      ld    A, (configr_state)
              	      get_jp_table_entry configr_jp_tbl
6D38: D5      	      push DE
              	
6D39: 1600    	      ld    D, 0                    ; DE becomes offset by doubling A
6D3B: 5F      	      ld    E, A
6D3C: CB23    	      sla   E
6D3E: CB12    	      rl    D
              	
6D40: 219171  	      ld    HL, configr_jp_tbl              ; HL = pointer to jump table
6D43: 19      	      add   HL, DE                  ; Add offset to pointer
              	
6D44: 5E      	      ld    E, (HL)                 ; Load HL pair into DE
6D45: 23      	      inc   HL
6D46: 56      	      ld    D, (HL)
              	
6D47: EB      	      ex    DE, HL                  ; DE becomes HL for return
              	
6D48: D1      	      pop   DE
6D49: E9      	      jp    (HL)
              	
              	;---- State 00 -------------------------------------------------------
              	;     This is where the app starts from fresh.
6D4A:         	configr_app_start
6D4A: 010800  	      ld    BC, 8                   ; Display app title on row 1
6D4D: 114078  	      ld    DE, staging_row1
6D50: 21B771  	      ld    HL, configr_title
6D53: CD2075  	      call  strncpy
              	
6D56: 3E00    	      ld    A, 0                    ; Clear rows 2 and 3
6D58: 011300  	      ld    BC, 19
6D5B: 214878  	      ld    HL, staging_row2
6D5E: CD4075  	      call  memset
              	
6D61: AF      	      xor   A, A
6D62: 328178  	      ld    (configr_menu_opt), A   ; Reset selected menu option
6D65: 326378  	      ld    (display_effect), A     ; Disable display update effects
              	
              	      set_valid_btn_mask BTN_ALL
6D68: F5      	      push  AF
6D69: C5      	      push  BC
              	
6D6A: 3A5D78  	      ld    A, (btn_state)          ; Ack all un-ack'd buttons by
6D6D: 47      	      ld    B, A                    ; OR'ing them with all ack'd
6D6E: 3A5C78  	      ld    A, (btn_ack)            ; buttons.
6D71: B0      	      or    A, B
6D72: 325C78  	      ld    (btn_ack), A
              	
6D75: 3E0F    	      ld    A, BTN_ALL
6D77: 325B78  	      ld    (btn_valid), A          ; Load new mask
              	
6D7A: C1      	      pop   BC
6D7B: F1      	      pop   AF
              	      set_state configr_state, CONFIGR_MAIN_MENU
6D7C: F5      	      push  AF
              	
6D7D: 3E01    	      ld    A, CONFIGR_MAIN_MENU
6D7F: 328078  	      ld    (configr_state), A
              	
6D82: F1      	      pop   AF
              	
6D83: C9      	      ret
              	
              	;---- State 01 -------------------------------------------------------
              	;     Implements the main menu.
              	;
              	;     User can:
              	;     * Select between setting date and time using Up/Down buttons
              	;     * Proceed to perform that action by pressing the Enter button
              	;     * Exit configurator app using Escape button
6D84:         	configr_main_menu
              	#local
6D84: 010800  	      ld    BC, 8                   ; Prepare to set text on row 2,
6D87: 114878  	      ld    DE, staging_row2        ; default to "SET DATE"
6D8A: 21C871  	      ld    HL, configr_menu_set_date
              	
6D8D: 3A8178  	      ld    A, (configr_menu_opt)   ; If selected menu option is value
6D90: FE00    	      cp    A, 0                    ; 0 (zero), row 2 will display
6D92: 2003    	      jr    NZ, do_msg              ; "SET TIME" instead.
6D94: 21BF71  	      ld    HL, configr_menu_set_time
              	
6D97:         	do_msg
6D97: CD2075  	      call  strncpy
              	
              	      ; Handle button presses
6D9A: 3A5D78  	      ld    A, (btn_state)
              	
6D9D: CB5F    	      bit   BTN_ESC_BIT, A
6D9F: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape exits the config app
6DA1: E5      	      push  HL
              	
6DA2: 215C78  	      ld    HL, btn_ack             ; Ack the button
6DA5: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
6DA7: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_EXIT
6DA8: F5      	      push  AF
              	
6DA9: 3E12    	      ld    A, CONFIGR_EXIT
6DAB: 328078  	      ld    (configr_state), A
              	
6DAE: F1      	      pop   AF
              	
6DAF: C9      	      ret
              	
6DB0:         	test_enter_btn
6DB0: CB57    	      bit   BTN_ENT_BIT, A
6DB2: 281E    	      jr    Z, test_updn_btns
              	
              	      ack_btn BTN_ENT_BIT
6DB4: E5      	      push  HL
              	
6DB5: 215C78  	      ld    HL, btn_ack             ; Ack the button
6DB8: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
6DBA: E1      	      pop   HL
              	
6DBB: 3A8178  	      ld    A, (configr_menu_opt)
6DBE: FE00    	      cp    A, 0
6DC0: 2008    	      jr    NZ, enter_menu1
              	
              	      ; On Enter, if menu option was 0, proceed to set time
              	      set_state configr_state, CONFIGR_ADJUST_TIME
6DC2: F5      	      push  AF
              	
6DC3: 3E02    	      ld    A, CONFIGR_ADJUST_TIME
6DC5: 328078  	      ld    (configr_state), A
              	
6DC8: F1      	      pop   AF
              	
6DC9: C9      	      ret
              	
6DCA:         	enter_menu1
              	      ; Otherwise proceed to set date
              	      set_state configr_state, CONFIGR_ADJUST_DATE
6DCA: F5      	      push  AF
              	
6DCB: 3E08    	      ld    A, CONFIGR_ADJUST_DATE
6DCD: 328078  	      ld    (configr_state), A
              	
6DD0: F1      	      pop   AF
              	
6DD1: C9      	      ret
              	
6DD2:         	test_updn_btns
6DD2: 47      	      ld    B, A
6DD3: E603    	      and   A, 0x03
6DD5: C8      	      ret   Z
              	
              	      ; Up and Down buttons achieve essentially the same thing, so
              	      ; handle them as though they are the same - toggle the LSb to
              	      ; move between the two available options
6DD6: 218178  	      ld    HL, configr_menu_opt
6DD9: 7E      	      ld    A, (HL)
6DDA: EE01    	      xor   A, 0x01
6DDC: 77      	      ld    (HL), A
              	
              	      ack_btn BTN_UP_BIT
6DDD: E5      	      push  HL
              	
6DDE: 215C78  	      ld    HL, btn_ack             ; Ack the button
6DE1: CBC6    	      set   BTN_UP_BIT, (HL)
              	
6DE3: E1      	      pop   HL
              	      ack_btn BTN_DN_BIT
6DE4: E5      	      push  HL
              	
6DE5: 215C78  	      ld    HL, btn_ack             ; Ack the button
6DE8: CBCE    	      set   BTN_DN_BIT, (HL)
              	
6DEA: E1      	      pop   HL
              	
6DEB: C9      	      ret
              	#endlocal
              	
              	;---- State 02 -------------------------------------------------------
              	;     Adjust the time.
              	;
              	;     The hours and minutes registers of the RTC are copied to RAM so
              	;     they can be adjusted independently, and then applied at the end.
              	;
              	;     Falls through to next state.
6DEC:         	configr_adjust_time
              	      rtc_update_lock
6DEC: F5      	      push  AF
              	
6DED: 3E0E    	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
6DEF: D31E    	      out   (RTC_CTRL), A
              	
6DF1: F1      	      pop   AF
              	
6DF2: DB12    	      in    A, (RTC_MIN)
6DF4: 328278  	      ld    (configr_rtc_min), A
6DF7: DB14    	      in    A, (RTC_HRS)
6DF9: E67F    	      and   A, 0x7F                 ; Remove MSb (AM/PM indicator)
6DFB: 328378  	      ld    (configr_rtc_hrs), A
              	
              	      rtc_update_unlock
6DFE: F5      	      push  AF
              	
6DFF: 3E06    	      ld    A, RTC_CTRL_CFG
6E01: D31E    	      out   (RTC_CTRL), A
              	
6E03: F1      	      pop   AF
              	
6E04: 010800  	      ld    BC, 8                   ; Set title/row 1 to "TIME UTC"
6E07: 114078  	      ld    DE, staging_row1
6E0A: 21D171  	      ld    HL, configr_time_utc
6E0D: CD2075  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_HOURS_MSG
6E10: F5      	      push  AF
              	
6E11: 3E03    	      ld    A, CONFIGR_HOURS_MSG
6E13: 328078  	      ld    (configr_state), A
              	
6E16: F1      	      pop   AF
              	
              	;---- State 03 -------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
6E17:         	configr_hours_msg
6E17: 011000  	      ld    BC, 16                  ; Set row 2 to "HOURS" and clear
6E1A: 114878  	      ld    DE, staging_row2        ; row 3
6E1D: 21DA71  	      ld    HL, configr_set_hours
6E20: CD2075  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_HOURS
6E23: F5      	      push  AF
              	
6E24: 3E04    	      ld    A, CONFIGR_ADJUST_HOURS
6E26: 328078  	      ld    (configr_state), A
              	
6E29: F1      	      pop   AF
              	
              	;---- State 04 -------------------------------------------------------
              	;     Implements hours adjustment.
              	;
              	;     Hours value can be adjusted using the Up/Down buttons. Proceed
              	;     to Minutes adjustment using the Enter button, or exit back to
              	;     the main menu using the Escape button.
6E2A:         	configr_adjust_hours
              	#local
              	      ; Display tens digit in row 3 col 0
6E2A: 218378  	      ld    HL, configr_rtc_hrs
6E2D: 7E      	      ld    A, (HL)
6E2E: 0F      	      rrca
6E2F: 0F      	      rrca
6E30: 0F      	      rrca
6E31: 0F      	      rrca
6E32: E60F    	      and   A, 0x0F
6E34: C630    	      add   A, 0x30
6E36: 325078  	      ld    (staging_row3), A
              	
              	      ; Display units digit in row 3 col 1
6E39: 7E      	      ld    A, (HL)
6E3A: E60F    	      and   A, 0x0F
6E3C: C630    	      add   A, 0x30
6E3E: 325178  	      ld    (staging_row3+1), A
              	
              	      ; Handle button presses
6E41: 3A5D78  	      ld    A, (btn_state)
              	
6E44: CB5F    	      bit   BTN_ESC_BIT, A
6E46: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to main menu
6E48: E5      	      push  HL
              	
6E49: 215C78  	      ld    HL, btn_ack             ; Ack the button
6E4C: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
6E4E: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_APP_START
6E4F: F5      	      push  AF
              	
6E50: 3E00    	      ld    A, CONFIGR_APP_START
6E52: 328078  	      ld    (configr_state), A
              	
6E55: F1      	      pop   AF
              	
6E56: C9      	      ret
              	
6E57:         	test_enter_btn
6E57: CB57    	      bit   BTN_ENT_BIT, A
6E59: 280F    	      jr    Z, test_updn_btns
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to minutes adjust
6E5B: E5      	      push  HL
              	
6E5C: 215C78  	      ld    HL, btn_ack             ; Ack the button
6E5F: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
6E61: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_MINUTES_MSG
6E62: F5      	      push  AF
              	
6E63: 3E05    	      ld    A, CONFIGR_MINUTES_MSG
6E65: 328078  	      ld    (configr_state), A
              	
6E68: F1      	      pop   AF
              	
6E69: C9      	      ret
              	
6E6A:         	test_updn_btns
6E6A: 47      	      ld    B, A
6E6B: E603    	      and   A, 0x03                 ; Up or Down pressed?
6E6D: C8      	      ret   Z                       ; No if Z
              	
6E6E: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
6E6F: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
6E71: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
6E73: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
6E74: E5      	      push  HL
              	
6E75: 215C78  	      ld    HL, btn_ack             ; Ack the button
6E78: CBC6    	      set   BTN_UP_BIT, (HL)
              	
6E7A: E1      	      pop   HL
6E7B: 1808    	      jr    store
              	
6E7D:         	down_button
6E7D: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
6E7E: E5      	      push  HL
              	
6E7F: 215C78  	      ld    HL, btn_ack             ; Ack the button
6E82: CBCE    	      set   BTN_DN_BIT, (HL)
              	
6E84: E1      	      pop   HL
              	
6E85:         	store
6E85: 27      	      daa                           ; Format new value for BCD
6E86: 77      	      ld    (HL), A                 ; Store new value back
              	
6E87: FE24    	      cp    A, 0x24                 ; New value overflowed to 24?
6E89: 2003    	      jr    NZ, cp_99
6E8B: 3600    	      ld    (HL), 0                 ; Yes, reset to 0
              	
6E8D: C9      	      ret
              	
6E8E:         	cp_99
6E8E: FE99    	      cp    A, 0x99                 ; New value underflowed to 99?
6E90: C0      	      ret   NZ
6E91: 3623    	      ld    (HL), 0x23              ; Yes, reset to 23
              	
6E93: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 05 -------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
6E94:         	configr_minutes_msg
6E94: 011000  	      ld    BC, 16                  ; Set row 2 to "MINUTES" and clear
6E97: 114878  	      ld    DE, staging_row2        ; row 3
6E9A: 21E071  	      ld    HL, configr_set_minutes
6E9D: CD2075  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_MINS
6EA0: F5      	      push  AF
              	
6EA1: 3E06    	      ld    A, CONFIGR_ADJUST_MINS
6EA3: 328078  	      ld    (configr_state), A
              	
6EA6: F1      	      pop   AF
              	
              	;---- State 06 -------------------------------------------------------
              	;     Implements minutes adjustment.
              	;
              	;     Minutes value can be adjusted using the Up/Down buttons. Proceed
              	;     to apply new time using Enter button, or return to hours
              	;     adjustment using Escape button.
6EA7:         	configr_adjust_mins
              	#local
              	      ; Display tens digit in row 3 col 0
6EA7: 218278  	      ld    HL, configr_rtc_min
6EAA: 7E      	      ld    A, (HL)
6EAB: 0F      	      rrca
6EAC: 0F      	      rrca
6EAD: 0F      	      rrca
6EAE: 0F      	      rrca
6EAF: E60F    	      and   A, 0x0F
6EB1: C630    	      add   A, 0x30
6EB3: 325078  	      ld    (staging_row3), A
              	
              	      ; Display units digit in row 3 col 1
6EB6: 7E      	      ld    A, (HL)
6EB7: E60F    	      and   A, 0x0F
6EB9: C630    	      add   A, 0x30
6EBB: 325178  	      ld    (staging_row3+1), A
              	
              	      ; Handle button presses
6EBE: 3A5D78  	      ld    A, (btn_state)
              	
6EC1: CB5F    	      bit   BTN_ESC_BIT, A
6EC3: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to hours adjust
6EC5: E5      	      push  HL
              	
6EC6: 215C78  	      ld    HL, btn_ack             ; Ack the button
6EC9: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
6ECB: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_HOURS_MSG
6ECC: F5      	      push  AF
              	
6ECD: 3E03    	      ld    A, CONFIGR_HOURS_MSG
6ECF: 328078  	      ld    (configr_state), A
              	
6ED2: F1      	      pop   AF
              	
6ED3: C9      	      ret
              	
6ED4:         	test_enter_btn
6ED4: CB57    	      bit   BTN_ENT_BIT, A
6ED6: 280F    	      jr    Z, test_updn_btn
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to apply time
6ED8: E5      	      push  HL
              	
6ED9: 215C78  	      ld    HL, btn_ack             ; Ack the button
6EDC: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
6EDE: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_APPLY_TIME
6EDF: F5      	      push  AF
              	
6EE0: 3E07    	      ld    A, CONFIGR_APPLY_TIME
6EE2: 328078  	      ld    (configr_state), A
              	
6EE5: F1      	      pop   AF
              	
6EE6: C9      	      ret
              	
6EE7:         	test_updn_btn
6EE7: 47      	      ld    B, A
6EE8: E603    	      and   A, 0x03                 ; Up or Down pressed?
6EEA: C8      	      ret   Z                       ; No if Z
              	
6EEB: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
6EEC: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
6EEE: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
6EF0: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
6EF1: E5      	      push  HL
              	
6EF2: 215C78  	      ld    HL, btn_ack             ; Ack the button
6EF5: CBC6    	      set   BTN_UP_BIT, (HL)
              	
6EF7: E1      	      pop   HL
6EF8: 1808    	      jr    store
              	
6EFA:         	down_button
6EFA: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
6EFB: E5      	      push  HL
              	
6EFC: 215C78  	      ld    HL, btn_ack             ; Ack the button
6EFF: CBCE    	      set   BTN_DN_BIT, (HL)
              	
6F01: E1      	      pop   HL
              	
6F02:         	store
6F02: 27      	      daa                           ; Format new value for BCD
6F03: 77      	      ld    (HL), A                 ; Store new value back
              	
6F04: FE60    	      cp    A, 0x60                 ; New value overflowed to 60?
6F06: 2003    	      jr    NZ, cp_99
6F08: 3600    	      ld    (HL), 0                 ; Yes, reset to 0
              	
6F0A: C9      	      ret
              	
6F0B:         	cp_99
6F0B: FE99    	      cp    A, 0x99                 ; New value underflowed to 99?
6F0D: C0      	      ret   NZ
6F0E: 3659    	      ld    (HL), 0x59              ; Yes, reset to 59
              	
6F10: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 07 -------------------------------------------------------
              	;     The adjusted hours and minutes values are written to the RTC
              	;     registers to apply the new time.
6F11:         	configr_apply_time
              	      rtc_update_lock
6F11: F5      	      push  AF
              	
6F12: 3E0E    	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
6F14: D31E    	      out   (RTC_CTRL), A
              	
6F16: F1      	      pop   AF
              	
6F17: AF      	      xor   A, A                    ; Seconds are always reset to 0
6F18: D310    	      out   (RTC_SEC), A
              	
6F1A: 3A8278  	      ld    A, (configr_rtc_min)
6F1D: D312    	      out   (RTC_MIN), A
6F1F: 3A8378  	      ld    A, (configr_rtc_hrs)
6F22: D314    	      out   (RTC_HRS), A
              	
              	      rtc_update_unlock
6F24: F5      	      push  AF
              	
6F25: 3E06    	      ld    A, RTC_CTRL_CFG
6F27: D31E    	      out   (RTC_CTRL), A
              	
6F29: F1      	      pop   AF
              	
              	      ; Restart app after applying new time
              	      set_state configr_state, CONFIGR_APP_START
6F2A: F5      	      push  AF
              	
6F2B: 3E00    	      ld    A, CONFIGR_APP_START
6F2D: 328078  	      ld    (configr_state), A
              	
6F30: F1      	      pop   AF
              	
6F31: C9      	      ret
              	
              	;---- State 08 -------------------------------------------------------
              	;     Adjust the date.
              	;
              	;     The year, month, day and day of week registers of the RTC are
              	;     copied to RAM so they can be adjusted independently, and then
              	;     applied at the end.
              	;
              	;     Falls through to next state.
6F32:         	configr_adjust_date
              	      rtc_update_lock
6F32: F5      	      push  AF
              	
6F33: 3E0E    	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
6F35: D31E    	      out   (RTC_CTRL), A
              	
6F37: F1      	      pop   AF
              	
6F38: DB16    	      in    A, (RTC_DAY)
6F3A: 328478  	      ld    (configr_rtc_day), A
6F3D: DB18    	      in    A, (RTC_DOW)
6F3F: 328578  	      ld    (configr_rtc_dow), A
6F42: DB19    	      in    A, (RTC_MON)
6F44: 328678  	      ld    (configr_rtc_mon), A
6F47: DB1A    	      in    A, (RTC_YEAR)
6F49: 328778  	      ld    (configr_rtc_year), A
              	
              	      rtc_update_unlock
6F4C: F5      	      push  AF
              	
6F4D: 3E06    	      ld    A, RTC_CTRL_CFG
6F4F: D31E    	      out   (RTC_CTRL), A
              	
6F51: F1      	      pop   AF
              	
6F52: 010800  	      ld    BC, 8                   ; Set title/row 1 to "DATE UTC"
6F55: 114078  	      ld    DE, staging_row1
6F58: 21E871  	      ld    HL, configr_date_utc
6F5B: CD2075  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_YEAR_MSG
6F5E: F5      	      push  AF
              	
6F5F: 3E09    	      ld    A, CONFIGR_YEAR_MSG
6F61: 328078  	      ld    (configr_state), A
              	
6F64: F1      	      pop   AF
              	
              	;---- State 09 -------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
6F65:         	configr_year_msg
6F65: 011000  	      ld    BC, 16                  ; Set row 2 to "YEAR" and clear
6F68: 114878  	      ld    DE, staging_row2        ; row 3
6F6B: 21F171  	      ld    HL, configr_set_year
6F6E: CD2075  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_YEAR
6F71: F5      	      push  AF
              	
6F72: 3E0A    	      ld    A, CONFIGR_ADJUST_YEAR
6F74: 328078  	      ld    (configr_state), A
              	
6F77: F1      	      pop   AF
              	
              	;---- State 0A -------------------------------------------------------
6F78:         	configr_adjust_year
              	#local
              	      ; Display tens digit in row 3 col 0
6F78: 218778  	      ld    HL, configr_rtc_year
6F7B: 7E      	      ld    A, (HL)
6F7C: 0F      	      rrca
6F7D: 0F      	      rrca
6F7E: 0F      	      rrca
6F7F: 0F      	      rrca
6F80: E60F    	      and   A, 0x0F
6F82: C630    	      add   A, 0x30
6F84: 325078  	      ld    (staging_row3), A
              	
              	      ; Display units digit in row 3 col 1
6F87: 7E      	      ld    A, (HL)
6F88: E60F    	      and   A, 0x0F
6F8A: C630    	      add   A, 0x30
6F8C: 325178  	      ld    (staging_row3+1), A
              	
              	      ; Handle button presses
6F8F: 3A5D78  	      ld    A, (btn_state)
              	
6F92: CB5F    	      bit   BTN_ESC_BIT, A
6F94: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to main menu
6F96: E5      	      push  HL
              	
6F97: 215C78  	      ld    HL, btn_ack             ; Ack the button
6F9A: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
6F9C: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_APP_START
6F9D: F5      	      push  AF
              	
6F9E: 3E00    	      ld    A, CONFIGR_APP_START
6FA0: 328078  	      ld    (configr_state), A
              	
6FA3: F1      	      pop   AF
              	
6FA4: C9      	      ret
              	
6FA5:         	test_enter_btn
6FA5: CB57    	      bit   BTN_ENT_BIT, A
6FA7: 280F    	      jr    Z, test_updn_btn
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to month adjust
6FA9: E5      	      push  HL
              	
6FAA: 215C78  	      ld    HL, btn_ack             ; Ack the button
6FAD: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
6FAF: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_MONTH_MSG
6FB0: F5      	      push  AF
              	
6FB1: 3E0B    	      ld    A, CONFIGR_MONTH_MSG
6FB3: 328078  	      ld    (configr_state), A
              	
6FB6: F1      	      pop   AF
              	
6FB7: C9      	      ret
              	
6FB8:         	test_updn_btn
6FB8: 47      	      ld    B, A
6FB9: E603    	      and   A, 0x03                 ; Up or Down pressed?
6FBB: C8      	      ret   Z                       ; No if Z
              	
6FBC: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
6FBD: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
6FBF: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
6FC1: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
6FC2: E5      	      push  HL
              	
6FC3: 215C78  	      ld    HL, btn_ack             ; Ack the button
6FC6: CBC6    	      set   BTN_UP_BIT, (HL)
              	
6FC8: E1      	      pop   HL
6FC9: 1808    	      jr    store
              	
6FCB:         	down_button
6FCB: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
6FCC: E5      	      push  HL
              	
6FCD: 215C78  	      ld    HL, btn_ack             ; Ack the button
6FD0: CBCE    	      set   BTN_DN_BIT, (HL)
              	
6FD2: E1      	      pop   HL
              	
6FD3:         	store
6FD3: 27      	      daa                           ; Format new value for BCD
6FD4: 77      	      ld    (HL), A                 ; Store new value back
              	
6FD5: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 0B --------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
6FD6:         	configr_month_msg
6FD6: 011000  	      ld    BC, 16                  ; Set row 2 to "MONTH" and clear
6FD9: 114878  	      ld    DE, staging_row2        ; row 3
6FDC: 21F671  	      ld    HL, configr_set_month
6FDF: CD2075  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_MONTH
6FE2: F5      	      push  AF
              	
6FE3: 3E0C    	      ld    A, CONFIGR_ADJUST_MONTH
6FE5: 328078  	      ld    (configr_state), A
              	
6FE8: F1      	      pop   AF
              	
              	;---- State 0C --------------------------------------------------------
6FE9:         	configr_adjust_month
              	#local
              	      ; Display tens digit in row 3 col 0
6FE9: 218678  	      ld    HL, configr_rtc_mon
6FEC: 7E      	      ld    A, (HL)
6FED: 0F      	      rrca
6FEE: 0F      	      rrca
6FEF: 0F      	      rrca
6FF0: 0F      	      rrca
6FF1: E60F    	      and   A, 0x0F
6FF3: C630    	      add   A, 0x30
6FF5: 325078  	      ld    (staging_row3), A
              	
              	      ; Display units digit in row 3 col 1
6FF8: 7E      	      ld    A, (HL)
6FF9: E60F    	      and   A, 0x0F
6FFB: C630    	      add   A, 0x30
6FFD: 325178  	      ld    (staging_row3+1), A
              	
              	      ; Handle button presses
7000: 3A5D78  	      ld    A, (btn_state)
              	
7003: CB5F    	      bit   BTN_ESC_BIT, A
7005: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to year adjust
7007: E5      	      push  HL
              	
7008: 215C78  	      ld    HL, btn_ack             ; Ack the button
700B: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
700D: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_YEAR_MSG
700E: F5      	      push  AF
              	
700F: 3E09    	      ld    A, CONFIGR_YEAR_MSG
7011: 328078  	      ld    (configr_state), A
              	
7014: F1      	      pop   AF
              	
7015: C9      	      ret
              	
7016:         	test_enter_btn
7016: CB57    	      bit   BTN_ENT_BIT, A
7018: 280F    	      jr    Z, test_updn_btn
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to day adjust
701A: E5      	      push  HL
              	
701B: 215C78  	      ld    HL, btn_ack             ; Ack the button
701E: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
7020: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_DAY_MSG
7021: F5      	      push  AF
              	
7022: 3E0D    	      ld    A, CONFIGR_DAY_MSG
7024: 328078  	      ld    (configr_state), A
              	
7027: F1      	      pop   AF
              	
7028: C9      	      ret
              	
7029:         	test_updn_btn
7029: 47      	      ld    B, A
702A: E603    	      and   A, 0x03                 ; Up or Down pressed?
702C: C8      	      ret   Z                       ; No if Z
              	
702D: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
702E: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
7030: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
7032: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
7033: E5      	      push  HL
              	
7034: 215C78  	      ld    HL, btn_ack             ; Ack the button
7037: CBC6    	      set   BTN_UP_BIT, (HL)
              	
7039: E1      	      pop   HL
703A: 1808    	      jr    store
              	
703C:         	down_button
703C: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
703D: E5      	      push  HL
              	
703E: 215C78  	      ld    HL, btn_ack             ; Ack the button
7041: CBCE    	      set   BTN_DN_BIT, (HL)
              	
7043: E1      	      pop   HL
              	
7044:         	store
7044: 27      	      daa                           ; Format new value for BCD
7045: 77      	      ld    (HL), A                 ; Store new value back
              	
7046: FE13    	      cp    A, 0x13                 ; New value overflowed to 13?
7048: 2003    	      jr    NZ, cp_0
704A: 3601    	      ld    (HL), 0x01              ; Yes, reset to 1
              	
704C: C9      	      ret
              	
704D:         	cp_0
704D: FE00    	      cp    A, 0                    ; New value underflowed to 0?
704F: C0      	      ret   NZ
7050: 3612    	      ld    (HL), 0x12              ; Yes, reset to 12
              	
7052: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 0D --------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
7053:         	configr_day_msg
7053: 011000  	      ld    BC, 16                  ; Set row 2 to "DAY" and clear row
7056: 114878  	      ld    DE, staging_row2        ; 3
7059: 21FC71  	      ld    HL, configr_set_day
705C: CD2075  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_DAY
705F: F5      	      push  AF
              	
7060: 3E0E    	      ld    A, CONFIGR_ADJUST_DAY
7062: 328078  	      ld    (configr_state), A
              	
7065: F1      	      pop   AF
              	
              	;---- State 0E --------------------------------------------------------
7066:         	configr_adjust_day
              	#local
              	      ; Display tens digit in row 3 col 0
7066: 218478  	      ld    HL, configr_rtc_day
7069: 7E      	      ld    A, (HL)
706A: 0F      	      rrca
706B: 0F      	      rrca
706C: 0F      	      rrca
706D: 0F      	      rrca
706E: E60F    	      and   A, 0x0F
7070: C630    	      add   A, 0x30
7072: 325078  	      ld    (staging_row3), A
              	
              	      ; Display units digit in row 3 col 1
7075: 7E      	      ld    A, (HL)
7076: E60F    	      and   A, 0x0F
7078: C630    	      add   A, 0x30
707A: 325178  	      ld    (staging_row3+1), A
              	
              	      ; Handle button presses
707D: 3A5D78  	      ld    A, (btn_state)
              	
7080: CB5F    	      bit   BTN_ESC_BIT, A
7082: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to month adjust
7084: E5      	      push  HL
              	
7085: 215C78  	      ld    HL, btn_ack             ; Ack the button
7088: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
708A: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_MONTH_MSG
708B: F5      	      push  AF
              	
708C: 3E0B    	      ld    A, CONFIGR_MONTH_MSG
708E: 328078  	      ld    (configr_state), A
              	
7091: F1      	      pop   AF
              	
7092: C9      	      ret
              	
7093:         	test_enter_btn
7093: CB57    	      bit   BTN_ENT_BIT, A
7095: 280F    	      jr    Z, test_updn_btn
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to DOW adjust
7097: E5      	      push  HL
              	
7098: 215C78  	      ld    HL, btn_ack             ; Ack the button
709B: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
709D: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_DOW_MSG
709E: F5      	      push  AF
              	
709F: 3E0F    	      ld    A, CONFIGR_DOW_MSG
70A1: 328078  	      ld    (configr_state), A
              	
70A4: F1      	      pop   AF
              	
70A5: C9      	      ret
              	
70A6:         	test_updn_btn
70A6: 47      	      ld    B, A
70A7: E603    	      and   A, 0x03                 ; Up or Down pressed?
70A9: C8      	      ret   Z                       ; No if Z
              	
70AA: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
70AB: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
70AD: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
70AF: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
70B0: E5      	      push  HL
              	
70B1: 215C78  	      ld    HL, btn_ack             ; Ack the button
70B4: CBC6    	      set   BTN_UP_BIT, (HL)
              	
70B6: E1      	      pop   HL
70B7: 1808    	      jr    store
              	
70B9:         	down_button
70B9: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
70BA: E5      	      push  HL
              	
70BB: 215C78  	      ld    HL, btn_ack             ; Ack the button
70BE: CBCE    	      set   BTN_DN_BIT, (HL)
              	
70C0: E1      	      pop   HL
              	
70C1:         	store
70C1: 27      	      daa                           ; Format new value for BCD
70C2: 77      	      ld    (HL), A                 ; Store new value back
              	
70C3: FE32    	      cp    A, 0x32                 ; New value overflowed to 32?
70C5: 2003    	      jr    NZ, cp_0
70C7: 3601    	      ld    (HL), 0x01              ; Yes, reset to 1
              	
70C9: C9      	      ret
              	
70CA:         	cp_0
70CA: FE00    	      cp    A, 0                    ; New value underflowed to 0?
70CC: C0      	      ret   NZ
70CD: 3631    	      ld    (HL), 0x31              ; Yes, reset to 31
              	
70CF: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 0F --------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
70D0:         	configr_dow_msg
70D0: 011000  	      ld    BC, 16                  ; Set row 2 to "WEEKDAY" and
70D3: 114878  	      ld    DE, staging_row2        ; clear row 3
70D6: 210072  	      ld    HL, configr_set_weekday
70D9: CD2075  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_DOW
70DC: F5      	      push  AF
              	
70DD: 3E10    	      ld    A, CONFIGR_ADJUST_DOW
70DF: 328078  	      ld    (configr_state), A
              	
70E2: F1      	      pop   AF
              	
              	;---- State 10 --------------------------------------------------------
70E3:         	configr_adjust_dow
              	#local
70E3: 3A8578  	      ld    A, (configr_rtc_dow)    ; DOW value into A
70E6: 3D      	      dec   A                       ; Decrement by 1 and mult by 4 to
70E7: 87      	      add   A, A                    ; make offset (Sun = index 0)
70E8: 87      	      add   A, A
70E9: 1600    	      ld    D, 0                    ; A into DE
70EB: 5F      	      ld    E, A
70EC: 210872  	      ld    HL, configr_day_names   ; HL = pointer to first tbl entry
70EF: 19      	      add   HL, DE                  ; Add offset to pointer
              	
70F0: 010800  	      ld    BC, 8                   ; Write day name to row 3
70F3: 115078  	      ld    DE, staging_row3
70F6: CD2075  	      call  strncpy
              	
              	      ; Handle button presses
70F9: 3A5D78  	      ld    A, (btn_state)
              	
70FC: CB5F    	      bit   BTN_ESC_BIT, A
70FE: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to day adjust
7100: E5      	      push  HL
              	
7101: 215C78  	      ld    HL, btn_ack             ; Ack the button
7104: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
7106: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_DAY_MSG
7107: F5      	      push  AF
              	
7108: 3E0D    	      ld    A, CONFIGR_DAY_MSG
710A: 328078  	      ld    (configr_state), A
              	
710D: F1      	      pop   AF
              	
710E: C9      	      ret
              	
710F:         	test_enter_btn
710F: CB57    	      bit   BTN_ENT_BIT, A
7111: 280F    	      jr    Z, test_updn_btn
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to apply date
7113: E5      	      push  HL
              	
7114: 215C78  	      ld    HL, btn_ack             ; Ack the button
7117: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
7119: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_APPLY_DATE
711A: F5      	      push  AF
              	
711B: 3E11    	      ld    A, CONFIGR_APPLY_DATE
711D: 328078  	      ld    (configr_state), A
              	
7120: F1      	      pop   AF
              	
7121: C9      	      ret
              	
7122:         	test_updn_btn
7122: 47      	      ld    B, A
7123: E603    	      and   A, 0x03                 ; Up or Down pressed?
7125: C8      	      ret   Z                       ; No if Z
              	
7126: 218578  	      ld    HL, configr_rtc_dow
7129: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
712A: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
712C: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
712E: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
712F: E5      	      push  HL
              	
7130: 215C78  	      ld    HL, btn_ack             ; Ack the button
7133: CBC6    	      set   BTN_UP_BIT, (HL)
              	
7135: E1      	      pop   HL
7136: 1808    	      jr    store
              	
7138:         	down_button
7138: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
7139: E5      	      push  HL
              	
713A: 215C78  	      ld    HL, btn_ack             ; Ack the button
713D: CBCE    	      set   BTN_DN_BIT, (HL)
              	
713F: E1      	      pop   HL
              	
7140:         	store
7140: 27      	      daa                           ; Format new value for BCD
7141: 77      	      ld    (HL), A                 ; Store new value back
              	
7142: FE08    	      cp    A, 0x08                 ; New value overflowed to 8?
7144: 2003    	      jr    NZ, cp_0
7146: 3601    	      ld    (HL), 0x01              ; Yes, reset to 1
              	
7148: C9      	      ret
              	
7149:         	cp_0
7149: FE00    	      cp    A, 0                    ; New value underflowed to 0?
714B: C0      	      ret   NZ
714C: 3607    	      ld    (HL), 0x07              ; Yes, reset to 7
              	
714E: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 11 --------------------------------------------------------
              	;     The adjusted year, month, day and day of week values are written
              	;     to the RTC registers to apply the new date.
714F:         	configr_apply_date
              	      rtc_update_lock
714F: F5      	      push  AF
              	
7150: 3E0E    	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
7152: D31E    	      out   (RTC_CTRL), A
              	
7154: F1      	      pop   AF
              	
7155: 3A8478  	      ld    A, (configr_rtc_day)
7158: D316    	      out   (RTC_DAY), A
715A: 3A8578  	      ld    A, (configr_rtc_dow)
715D: D318    	      out   (RTC_DOW), A
715F: 3A8678  	      ld    A, (configr_rtc_mon)
7162: D319    	      out   (RTC_MON), A
7164: 3A8778  	      ld    A, (configr_rtc_year)
7167: D31A    	      out   (RTC_YEAR), A
              	
              	      rtc_update_unlock
7169: F5      	      push  AF
              	
716A: 3E06    	      ld    A, RTC_CTRL_CFG
716C: D31E    	      out   (RTC_CTRL), A
              	
716E: F1      	      pop   AF
              	
              	      ; Restart app after applying new date
              	      set_state configr_state, CONFIGR_APP_START
716F: F5      	      push  AF
              	
7170: 3E00    	      ld    A, CONFIGR_APP_START
7172: 328078  	      ld    (configr_state), A
              	
7175: F1      	      pop   AF
              	
7176: C9      	      ret
              	
              	;---- State 12 -------------------------------------------------------
              	;     Exit the config app by releasing the foreground mutex.
7177:         	configr_exit_app
              	      set_state configr_state, CONFIGR_APP_START
7177: F5      	      push  AF
              	
7178: 3E00    	      ld    A, CONFIGR_APP_START
717A: 328078  	      ld    (configr_state), A
              	
717D: F1      	      pop   AF
              	      mtx_unlock foreground_mtx
717E: F5      	      push  AF
717F: E5      	      push  HL
              	
7180: ED57    	      ld    A, I                    ; IFF2 to P/V flag
7182: F5      	      push  AF                      ; Save flags
7183: F3      	      di                            ; Ensure interrupts disabled
              	
7184: AF      	      xor   A, A                    ; Load zero to unlock the mutex
7185: 320078  	      ld    (foreground_mtx), A
              	
7188: E1      	      pop   HL                      ; F into L
7189: CB55    	      bit   2, L                    ; Test IFF2 flag
718B: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
718D: FB      	      ei                            ; Re-enable interrupts
              	
718E: E1      	      pop   HL                      ; Done
718F: F1      	      pop   AF
              	
7190: C9      	      ret
              	
              	; State machine jump table
7191: 4A6D    	configr_jp_tbl          .dw   configr_app_start
7193: 846D    	                        .dw   configr_main_menu
7195: EC6D    	                        .dw   configr_adjust_time
7197: 176E    	                        .dw   configr_hours_msg
7199: 2A6E    	                        .dw   configr_adjust_hours
719B: 946E    	                        .dw   configr_minutes_msg
719D: A76E    	                        .dw   configr_adjust_mins
719F: 116F    	                        .dw   configr_apply_time
71A1: 326F    	                        .dw   configr_adjust_date
71A3: 656F    	                        .dw   configr_year_msg
71A5: 786F    	                        .dw   configr_adjust_year
71A7: D66F    	                        .dw   configr_month_msg
71A9: E96F    	                        .dw   configr_adjust_month
71AB: 5370    	                        .dw   configr_day_msg
71AD: 6670    	                        .dw   configr_adjust_day
71AF: D070    	                        .dw   configr_dow_msg
71B1: E370    	                        .dw   configr_adjust_dow
71B3: 4F71    	                        .dw   configr_apply_date
71B5: 7771    	                        .dw   configr_exit_app
              	
71B7: 434F4E46	configr_title           .text "CONFIGR", 0
71BB: 49475200	
71BF: 53455420	configr_menu_set_time   .text "SET TIME", 0
71C3: 54494D45	
71C7: 00      	
71C8: 53455420	configr_menu_set_date   .text "SET DATE", 0
71CC: 44415445	
71D0: 00      	
71D1: 54494D45	configr_time_utc        .text "TIME UTC", 0
71D5: 20555443	
71D9: 00      	
71DA: 484F5552	configr_set_hours       .text "HOURS", 0
71DE: 5300    	
71E0: 4D494E55	configr_set_minutes     .text "MINUTES", 0
71E4: 54455300	
71E8: 44415445	configr_date_utc        .text "DATE UTC", 0
71EC: 20555443	
71F0: 00      	
71F1: 59454152	configr_set_year        .text "YEAR", 0
71F5: 00      	
71F6: 4D4F4E54	configr_set_month       .text "MONTH", 0
71FA: 4800    	
71FC: 44415900	configr_set_day         .text "DAY", 0
7200: 5745454B	configr_set_weekday     .text "WEEKDAY", 0
7204: 44415900	
              	
7208: 53554E00	configr_day_names       .text "SUN", 0    ; Keep day names contiguous
720C: 4D4F4E00	                        .text "MON", 0
7210: 54554500	                        .text "TUE", 0
7214: 57454400	                        .text "WED", 0
7218: 54485500	                        .text "THU", 0
721C: 46524900	                        .text "FRI", 0
7220: 53415400	                        .text "SAT", 0
              	
              	; END configr_app.s
              	#include "ctc_isr.s"
              	#data RAM
              	#code ROM
7224: FFFFFFFF	      .align 0x100
7228: FF...   	
7300:         	ctc_ch0_isr
7300: FB      	      ei
7301: ED4D    	      reti
              	
              	
              	;---------------------------------------------------------------------
              	;     CTC Channel 1 ISR - Display refresh                            :
              	;                                                                    :
              	; Description                                                        :
              	;     Runs in real time as opposed to being shceduled as a task      :
              	;     to ensure the least amount of jitter for display refreshing.   :
              	;                                                                    :
              	;     On each iteration of this ISR the working row is incremented,  :
              	;     and the character data is loaded from the character ROM and    :
              	;     shifted into the display driver shift registers.               :
              	;                                                                    :
              	;     External tasks are responsible for loading the display row     :
              	;     buffers with the data that is to be displayed.                 :
              	;---------------------------------------------------------------------
              	#data RAM
7888: 00      	disp_cur_row            .db 0       ; Current row being displayed
7889: 00      	disp_dim_ctr            .db 0       ; Display dimming counter
788A: 00      	disp_dim                .db 0       ; 0 = bright, 1 = dim
              	
              	#code ROM
7303: FFFFFFFF	      .align 0x80
7307: FF...   	
7380:         	ctc_ch1_isr
              	#local
7380: 08      	      ex    AF, AF'
7381: D9      	      exx
              	
              	;---- First thing to do is to determine the current row being worked
              	;     on. At boot, memory is zeroised, so incrementing early means
              	;     row 1 is the starting row. Each iteration the counter is inc'd
              	;     and once it reaches 4 it is reset back to 1 directly.
              	;
              	;     Also increment the display dimming row counter. The LSb of this
              	;     is used to determine if the current working row should be on or
              	;     off while dimming is active.
              	
7382: 218878  	      ld    HL, disp_cur_row        ; Increment row counter
7385: 34      	      inc   (HL)
7386: 7E      	      ld    A, (HL)
7387: FE04    	      cp    A, 4                    ; If at row 4, go back to 1
7389: 2007    	      jr    NZ, row_offset
              	
738B: 3E01    	      ld    A, 1                    ; Reset row counter to 1
738D: 77      	      ld    (HL), A
              	
738E: 218978  	      ld    HL, disp_dim_ctr        ; Increment dimming counter each
7391: 34      	      inc   (HL)                    ; time 3 rows have been displayed.
              	                                    ; This will result in a 50% duty
              	                                    ; cycle.
              	
              	;---- Once the working row is determined, the next step is to compute
              	;     an offset for the address where that rows buffer is located in
              	;     RAM. Start by loading the address of row 1's buffer, and then
              	;     subtract 1 from the current row counter. Each row is then some
              	;     multiple of 8 from that address.
              	;
              	;     Due to the layout of the display driver shift registers, the row
              	;     is iterated in reverse, from last character to first.
              	;
              	;     At the same time, compute a pointer to the dot point buffer for
              	;     the working row.
              	;
              	;     And finally, the buffer offset is added to a pointer for the row
              	;     data buffer.
              	
7392:         	row_offset
7392: 213878  	      ld    HL, display_dp1         ; Ptr to DP buffer for this row
              	
7395: 3D      	      dec   A                       ; Decrement row counter by 1
7396: 2807    	      jr    Z, row_offset_add       ; If row ctr == 0, skip offset adj
              	
7398: 47      	      ld    B, A                    ; Row counter becomes loop counter
7399: 3E04    	      ld    A, 4                    ; Offset start value
              	
739B:         	shift_offset
739B: 87      	      add   A, A                    ; Double for each row to offset
739C: 23      	      inc   HL                      ; Inc DP ptr for each row
739D: 10FC    	      djnz  shift_offset
              	
739F:         	row_offset_add
739F: E5      	      push  HL                      ; Save DP ptr for later
              	
73A0: 212778  	      ld    HL, display_row1+7      ; HL = pointer to row buffer.
              	                                    ; +7 to load data backwards.
73A3: 1600    	      ld    D, 0                    ; DE = row multiple offset
73A5: 5F      	      ld    E, A
73A6: 19      	      add   HL, DE                  ; Add row offset to pointer
              	
              	;---- The outer loop iterates over each of the 8 columns on the row.
              	;     The row buffer pointer points to the character to be displayed,
              	;     and is decremented each iteration to work backwards to the first
              	;     character of the row.
              	;
              	;     A pointer to the character ROM is computed and used by the
              	;     inner loop. Since each character on the display uses 2 bytes of
              	;     data to control 16 segments, the character value is doubled and
              	;     then added as an offset to the base addr of the character ROM.
              	
73A7: 0E20    	      ld    C, DISP_DATA            ; Display data shift register addr
73A9: 0608    	      ld    B, 8                    ; Outer loop - chars per row
              	
73AB:         	next_row_char
73AB: 1600    	      ld    D, 0                    ; DE = char value to display
73AD: 5E      	      ld    E, (HL)
73AE: EB      	      ex    DE, HL                  ; Each char ROM entry is 2 bytes
73AF: 29      	      add   HL, HL                  ; (16 segments), so double DE to
73B0: EB      	      ex    DE, HL                  ; make offset.
              	
73B1: E5      	      push  HL                      ; HL = ptr to row buf pos
              	
73B2: 2100E0  	      ld    HL, CHAR_ROM_BASE       ; HL = char ROM base addr
73B5: 19      	      add   HL, DE                  ; Add DE for char offset in ROM
              	
73B6: C5      	      push  BC                      ; BC contains outer loop counter
              	
73B7: 0602    	      ld    B, 2                    ; Inner loop - 2 chars from ROM
              	
73B9: EDB3    	      otir                          ; xfer char data
              	                                    ; 18 clocks between bytes
              	
73BB: C1      	      pop   BC                      ; Restore outer loop counter
73BC: E1      	      pop   HL                      ; Restore pointer to row buf
73BD: 2B      	      dec   HL                      ; Move to "next" row buffer pos
              	
73BE: 10EB    	      djnz  next_row_char
              	
              	;---- Finally, the dot points are loaded and shifted, and then the row
              	;     counter is written to an output register of the display driver
              	;     board, which also serves to latch in the data to drive that row.
              	
73C0: E1      	      pop   HL                      ; Restore DP ptr
73C1: 7E      	      ld    A, (HL)                 ; Load DP byte from buffer
73C2: 2F      	      cpl                           ; Invert for drivers that sink
73C3: ED79    	      out   (C), A
              	
              	;---- If the row is to be turned off while dimming is enabled, write
              	;     row 0 instead of the working row number to the display control
              	;     register.
              	;
              	;     Dimming is enabled by storing a value of 1 in the disp_dim
              	;     variable. When this value is ANDed with disp_dim_ctr, and when
              	;     both LSb's are set, the row will be enabled.
              	
73C5: 218978  	      ld    HL, disp_dim_ctr        ; Is the display being dimmed?
73C8: 3A8A78  	      ld    A, (disp_dim)
73CB: A6      	      and   A, (HL)
73CC: 3A8878  	      ld    A, (disp_cur_row)       ; Default write row counter
73CF: 2801    	      jr    Z, out_disp_ctrl
              	
73D1: AF      	      xor   A, A                    ; If dimming, this row will be off
              	
73D2:         	out_disp_ctrl
73D2: D321    	      out   (DISP_CTRL), A
              	
73D4: 08      	      ex    AF, AF'
73D5: D9      	      exx
              	
73D6: FB      	      ei
73D7: ED4D    	      reti
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     CTC Channel 2 ISR - Task scheduler                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Tasks that are to be run periodically (every ~10ms) will be    :
              	;     scheduled through this ISR.                                    :
              	;                                                                    :
              	;     Additionally, semaphores that permit applications to run will  :
              	;     be incremented here.                                           :
              	;                                                                    :
              	;     The processor is halted once all scheduled tasks have          :
              	;     completed, so tasks can only start at the next interrupt, and  :
              	;     only if they are scheduled here.                               :
              	;---------------------------------------------------------------------
              	#data RAM
              	#code ROM
73D9: FFFFFFFF	      .align 0x80
73DD: FF...   	
7400:         	ctc_ch2_isr
              	#local
7400: 08      	      ex    AF, AF'
7401: D9      	      exx
              	
              	      ; Schedule periodic tasks
              	      schedule_task TASK_BUTTON_RD
7402: E5      	      push  HL
              	
7403: 211178  	      ld    HL, task_sched+TASK_BUTTON_RD
7406: 3601    	      ld    (HL), TASK_BUTTON_RD
              	
7408: E1      	      pop   HL
              	      schedule_task TASK_WD_POKE
7409: E5      	      push  HL
              	
740A: 211278  	      ld    HL, task_sched+TASK_WD_POKE
740D: 3602    	      ld    (HL), TASK_WD_POKE
              	
740F: E1      	      pop   HL
              	      schedule_task TASK_DISPLAY
7410: E5      	      push  HL
              	
7411: 211578  	      ld    HL, task_sched+TASK_DISPLAY
7414: 3605    	      ld    (HL), TASK_DISPLAY
              	
7416: E1      	      pop   HL
              	
              	      ; Increment semaphores to allow apps to run, but only where an
              	      ; app owns the foreground mutex. It is important that apps only
              	      ; run once per ~10ms to allow button acknowledges to be applied
              	      ; and reduce erratic behaviour.
7417:         	clock_sem
              	      mtx_owned foreground_mtx, APP_CLOCK
7417: E5      	      push  HL
              	
7418: ED57    	      ld    A, I                    ; IFF2 to P/V flag
741A: F5      	      push  AF                      ; Save flags
741B: F3      	      di                            ; Ensure interrupts disabled
              	
741C: 3A0078  	      ld    A, (foreground_mtx)             ; Compare the value stored in
741F: FE03    	      cp    A, APP_CLOCK            ; (mutex) with task_num.
7421: 2801    	      jr    Z, $+3
              	
7423: AF      	      xor   A, A                    ; Not equal, return 0
              	
7424: E1      	      pop   HL                      ; F into L
7425: CB55    	      bit   2, L                    ; Test IFF2 flag
7427: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
7429: FB      	      ei                            ; Re-enable interrupts
              	
742A: E1      	      pop   HL                      ; Done
              	
742B: B7      	      or    A, A
742C: 2812    	      jr    Z, configr_sem
              	      sem_post clock_app_sem
742E: F5      	      push  AF
742F: E5      	      push  HL
              	
7430: ED57    	      ld    A, I                    ; IFF2 to P/V flag
7432: F5      	      push  AF                      ; Save flags
7433: F3      	      di                            ; Ensure interrupts disabled
              	
7434: 210178  	      ld    HL, clock_app_sem
7437: 34      	      inc   (HL)
              	
7438: E1      	      pop   HL                      ; F into L
7439: CB55    	      bit   2, L                    ; Test IFF2 flag
743B: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
743D: FB      	      ei                            ; Re-enable interrupts
              	
743E: E1      	      pop   HL
743F: F1      	      pop   AF
              	
7440:         	configr_sem
              	      mtx_owned foreground_mtx, APP_CONFIGR
7440: E5      	      push  HL
              	
7441: ED57    	      ld    A, I                    ; IFF2 to P/V flag
7443: F5      	      push  AF                      ; Save flags
7444: F3      	      di                            ; Ensure interrupts disabled
              	
7445: 3A0078  	      ld    A, (foreground_mtx)             ; Compare the value stored in
7448: FE04    	      cp    A, APP_CONFIGR            ; (mutex) with task_num.
744A: 2801    	      jr    Z, $+3
              	
744C: AF      	      xor   A, A                    ; Not equal, return 0
              	
744D: E1      	      pop   HL                      ; F into L
744E: CB55    	      bit   2, L                    ; Test IFF2 flag
7450: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
7452: FB      	      ei                            ; Re-enable interrupts
              	
7453: E1      	      pop   HL                      ; Done
              	
7454: B7      	      or    A, A
7455: 2812    	      jr    Z, done
              	      sem_post configr_app_sem
7457: F5      	      push  AF
7458: E5      	      push  HL
              	
7459: ED57    	      ld    A, I                    ; IFF2 to P/V flag
745B: F5      	      push  AF                      ; Save flags
745C: F3      	      di                            ; Ensure interrupts disabled
              	
745D: 210278  	      ld    HL, configr_app_sem
7460: 34      	      inc   (HL)
              	
7461: E1      	      pop   HL                      ; F into L
7462: CB55    	      bit   2, L                    ; Test IFF2 flag
7464: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
7466: FB      	      ei                            ; Re-enable interrupts
              	
7467: E1      	      pop   HL
7468: F1      	      pop   AF
              	
7469:         	done
7469: 08      	      ex    AF, AF'
746A: D9      	      exx
              	
746B: FB      	      ei
746C: ED4D    	      reti
              	#endlocal
              	
              	;---------------------------------------------------------------------
              	;     CTC Channel 3 ISR - Clock display refresh scheduler            :
              	;                                                                    :
              	; Description                                                        :
              	;     The RTC is configured to generate an alarm once per minute     :
              	;     by asserting its INT/ output. This output is connected to      :
              	;     channel 3 of the CTC to provide a vectored interrupt for the   :
              	;     RTC alarm.                                                     :
              	;                                                                    :
              	;                                                                    :
              	;---------------------------------------------------------------------
              	#data RAM
              	#code ROM
746E: FFFFFFFF	      .align 0x80
7472: FF...   	
7480:         	ctc_ch3_isr
              	#local
7480: 08      	      ex    AF, AF'
7481: D9      	      exx
              	
              	;---- Before the clock_upd_sem can be incremented, such an update must
              	;     have been requested by the clock app. This prevents the
              	;     semaphore being incremented while not in the clock app.
              	;
              	;     Initially when the clock app starts it will read the time from
              	;     the RTC and use that to configure the display immediately. It
              	;     will then increment the clock_upd_req_sem semaphore, and wait
              	;     for the clock_upd_sem semaphore to be updated in turn.
              	      sem_trywait clock_upd_req_sem
7482: E5      	      push  HL
              	
7483: ED57    	      ld    A, I                    ; IFF2 to P/V flag
7485: F5      	      push  AF                      ; Save flags
7486: F3      	      di                            ; Ensure interrupts disabled
              	
7487: 210378  	      ld    HL, clock_upd_req_sem
748A: 7E      	      ld    A, (HL)                 ; Load semaphore value for return
748B: B7      	      or    A, A                    ; Semaphore value greater than 0?
748C: 2801    	      jr    Z, $+3                  ; If Z, return 0, go to done
              	
748E: 35      	      dec   (HL)                    ; Decrement semaphore
              	
748F: E1      	      pop   HL                      ; F into L
7490: CB55    	      bit   2, L                    ; Test IFF2 flag
7492: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
7494: FB      	      ei                            ; Re-enable interrupts
              	
7495: E1      	      pop   HL                      ; Done
              	
7496: B7      	      or    A, A                    ; Set Z flag according to A
7497: 2812    	      jr    Z, done
              	
              	      sem_post clock_upd_sem        ; Increment display update sem
7499: F5      	      push  AF
749A: E5      	      push  HL
              	
749B: ED57    	      ld    A, I                    ; IFF2 to P/V flag
749D: F5      	      push  AF                      ; Save flags
749E: F3      	      di                            ; Ensure interrupts disabled
              	
749F: 210478  	      ld    HL, clock_upd_sem
74A2: 34      	      inc   (HL)
              	
74A3: E1      	      pop   HL                      ; F into L
74A4: CB55    	      bit   2, L                    ; Test IFF2 flag
74A6: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
74A8: FB      	      ei                            ; Re-enable interrupts
              	
74A9: E1      	      pop   HL
74AA: F1      	      pop   AF
              	
74AB:         	done
              	      ; Reconfigure things so they can happen again
74AB: DB1D    	      in    A, (RTC_FLAGS)          ; Read RTC flags to clear alarm
              	
74AD: 3EC5    	      ld    A, CTC_CH3_CFG          ; Reconfigure CTC channel to load
74AF: D303    	      out   (CTC_CH3), A            ; new time constant.
74B1: 3E01    	      ld    A, CTC_CH3_TCONST
74B3: D303    	      out   (CTC_CH3), A
              	
74B5: 08      	      ex    AF, AF'
74B6: D9      	      exx
              	
74B7: FB      	      ei
74B8: ED4D    	      reti
              	#endlocal
              	
              	; END ctc_isr.s
              	#include "c_lib.s"
              	#data RAM
              	#code ROM
              	;---------------------------------------------------------------------
              	;     memcpy                                                         :
              	;                                                                    :
              	; Description                                                        :
              	;     Copy block of memory.                                          :
              	;                                                                    :
              	;     Copies the values of BC bytes from the location pointed to by  :
              	;     HL directly to the memory block pointed to by DE.              :
              	;                                                                    :
              	; Parameters                                                         :
              	;     BC  Number of bytes to copy                                    :
              	;     DE  Pointer to the destination                                 :
              	;     HL  Pointer to the source of data to be copied                 :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;---------------------------------------------------------------------
74BA: FFFFFFFF	      .align 0x100
74BE: FF...   	
7500:         	memcpy:
7500: 78      	      ld    A, B                    ; BC == 0?
7501: B1      	      or    A, C
7502: C8      	      ret   Z                       ; Yes if Z, return
              	
7503: EDB0    	      ldir                          ; while (BC != 0) {
              	                                    ;   (DE) <- (HL);
              	                                    ;   DE++; HL++; BC--;
              	                                    ; }
7505: C9      	      ret
              	
              	
              	;---------------------------------------------------------------------
              	;     strncpy                                                        :
              	;                                                                    :
              	; Description                                                        :
              	;     Copy characters from string.                                   :
              	;                                                                    :
              	;     Copies the first BC characters from HL to DE. If the end of    :
              	;     the source string (which is signaled by a null-character) is   :
              	;     found before BC characters have been copied, DE is padded with :
              	;     zeros until a total of BC characters have been written to it.  :
              	;
              	;     No null-character is implicitly appended at the end of DE if   ;
              	;     HL is longer than BC. Thus, in this case, DE shall not be      ;
              	;     considered a null terminated string.                           ;
              	;                                                                    :
              	; Parameters                                                         :
              	;     BC  Maximum number of characters to be copied                  :
              	;     DE  Pointer to the destination                                 :
              	;     HL  String to be copied                                        :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;---------------------------------------------------------------------
7506: FFFFFFFF	      .align 0x20
750A: FF...   	
7520:         	strncpy:
              	#local
7520: 78      	      ld    A, B                    ; BC == 0?
7521: B1      	      or    A, C
7522: C8      	      ret   Z                       ; Yes if Z, return
              	
7523: 7E      	      ld    A, (HL)                 ; Load char from source
7524: B7      	      or    A, A                    ; Is it a zero?
7525: 2806    	      jr    Z, zero_fill            ; Yes if Z, zero fill from here
              	
7527: 12      	      ld    (DE), A                 ; No, store char to dest
              	
7528: 0B      	      dec   BC                      ; Dec byte count
7529: 13      	      inc   DE                      ; Inc dest pointer
752A: 23      	      inc   HL                      ; Inc source pointer
              	
752B: 18F3    	      jr    strncpy                 ; Next char
              	
752D:         	zero_fill:
752D: AF      	      xor   A, A                    ; Store 0 into DE
752E: 12      	      ld    (DE), A
              	
752F: 0B      	      dec   BC                      ; Dec byte count
7530: 13      	      inc   DE                      ; Inc dest pointer
              	
7531: 78      	      ld    A, B                    ; BC == 0?
7532: B1      	      or    A, C
7533: 20F8    	      jr    NZ, zero_fill           ; No if NZ, fill next char
              	
7535: C9      	      ret
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     memset                                                         :
              	;                                                                    :
              	; Description                                                        :
              	;     Fill block of memory.                                          :
              	;                                                                    :
              	;     Sets the first BC bytes of the block of memory pointed by HL   :
              	;     to the specified value in A.                                   :
              	;                                                                    :
              	; Parameters                                                         :
              	;     A   Value to be set                                            :
              	;     BC  Number of bytes to be set to the value of A                :
              	;     HL  Pointer to the block of memory to fill                     :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;                                                                    :
              	; Destroys                                                           :
              	;     D                                                              :
              	;---------------------------------------------------------------------
7536: FFFFFFFF	      .align 0x20
753A: FF...   	
7540:         	memset:
              	#local
7540: 57      	      ld    D, A
              	
7541:         	next:
7541: 78      	      ld    A, B                    ; BC == 0?
7542: B1      	      or    A, C
7543: C8      	      ret   Z                       ; Yes if Z, return
              	
7544: 72      	      ld    (HL), D                 ; Set
              	
7545: 0B      	      dec   BC                      ; Dec byte count
7546: 23      	      inc   HL                      ; Inc dest pointer
              	
7547: 18F8    	      jr    next
              	#endlocal
              	
              	; END c_lib.s
              	
              	
              	      .end


; +++ segments +++

#CODE ROM           = $6000 = 24576,  size = $1700 =  5888
#CODE _INITIALIZER  = $7700 = 30464,  size = $0100 =   256
#DATA RAM           = $7800 = 30720,  size = $0600 =  1536
#DATA _INITIALIZED  = $7E00 = 32256,  size = $0100 =   256

; +++ global symbols +++

APP_CLOCK           = $0003 =     3               clock.inc:76
APP_CONFIGR         = $0004 =     4               clock.inc:77
BTN_ALL             = $000F =    15               clock.inc:30
BTN_DN              = $0002 =     2               clock.inc:27 (unused)
BTN_DN_BIT          = $0001 =     1               clock.inc:32
BTN_ENT             = $0004 =     4               clock.inc:28 (unused)
BTN_ENT_BIT         = $0002 =     2               clock.inc:33
BTN_ESC             = $0008 =     8               clock.inc:29
BTN_ESC_BIT         = $0003 =     3               clock.inc:34
BTN_REG             = $0008 =     8               clock.inc:25
BTN_UP              = $0001 =     1               clock.inc:26 (unused)
BTN_UP_BIT          = $0000 =     0               clock.inc:31
CHAR_ROM_BASE       = $E000 = 57344               platform.inc:30
CHAR_ROM_SZ         = $2000 =  8192               platform.inc:31 (unused)
CLOCK_APP_START     = $0000 =     0  ROM          clock_app.s:18
CLOCK_EXIT          = $0003 =     3  ROM          clock_app.s:21
CLOCK_IDLE          = $0002 =     2  ROM          clock_app.s:20
CLOCK_UPDATE        = $0001 =     1  ROM          clock_app.s:19
CONFIGR_ADJUST_DATE = $0008 =     8  ROM          configr_app.s:25
CONFIGR_ADJUST_DAY  = $000E =    14  ROM          configr_app.s:31
CONFIGR_ADJUST_DOW  = $0010 =    16  ROM          configr_app.s:33
CONFIGR_ADJUST_HOURS = $0004 =     4  ROM          configr_app.s:21
CONFIGR_ADJUST_MINS = $0006 =     6  ROM          configr_app.s:23
CONFIGR_ADJUST_MONTH = $000C =    12  ROM          configr_app.s:29
CONFIGR_ADJUST_TIME = $0002 =     2  ROM          configr_app.s:19
CONFIGR_ADJUST_YEAR = $000A =    10  ROM          configr_app.s:27
CONFIGR_APPLY_DATE  = $0011 =    17  ROM          configr_app.s:34
CONFIGR_APPLY_TIME  = $0007 =     7  ROM          configr_app.s:24
CONFIGR_APP_START   = $0000 =     0  ROM          configr_app.s:17
CONFIGR_DAY_MSG     = $000D =    13  ROM          configr_app.s:30
CONFIGR_DOW_MSG     = $000F =    15  ROM          configr_app.s:32
CONFIGR_EXIT        = $0012 =    18  ROM          configr_app.s:35
CONFIGR_HOURS_MSG   = $0003 =     3  ROM          configr_app.s:20
CONFIGR_MAIN_MENU   = $0001 =     1  ROM          configr_app.s:18
CONFIGR_MINUTES_MSG = $0005 =     5  ROM          configr_app.s:22
CONFIGR_MONTH_MSG   = $000B =    11  ROM          configr_app.s:28
CONFIGR_YEAR_MSG    = $0009 =     9  ROM          configr_app.s:26
CTC_CH0             = $0000 =     0               clock.inc:6
CTC_CH0_CFG         = $0001 =     1               clock.inc:12 (unused)
CTC_CH1             = $0001 =     1               clock.inc:7
CTC_CH1_CFG         = $00A5 =   165               clock.inc:13
CTC_CH1_TCONST      = $0017 =    23               clock.inc:17
CTC_CH2             = $0002 =     2               clock.inc:8
CTC_CH2_CFG         = $00A5 =   165               clock.inc:14
CTC_CH2_TCONST      = $00EA =   234               clock.inc:18
CTC_CH3             = $0003 =     3               clock.inc:9
CTC_CH3_CFG         = $00C5 =   197               clock.inc:15
CTC_CH3_TCONST      = $0001 =     1               clock.inc:19
CTC_CTL_CLKTRG_ST   = $0008 =     8               ctc.inc:4 (unused)
CTC_CTL_CTR_MODE    = $0040 =    64               ctc.inc:7
CTC_CTL_INT_EN      = $0080 =   128               ctc.inc:8
CTC_CTL_PS_256      = $0020 =    32               ctc.inc:6
CTC_CTL_RISE        = $0010 =    16               ctc.inc:5 (unused)
CTC_CTL_SW_RESET    = $0002 =     2               ctc.inc:2 (unused)
CTC_CTL_TCONST      = $0004 =     4               ctc.inc:3
CTC_CTL_WORD        = $0001 =     1               ctc.inc:1
DEBUG_PORT          = $00DE =   222               clock.inc:83
DISP_CTRL           = $0021 =    33               clock.inc:64
DISP_DATA           = $0020 =    32               clock.inc:63
FCTC                = $8000 =4096000               platform.inc:8 (unused)
FSYS                = $8D80 =6000000               platform.inc:7
FUART               = $8000 =7372800               platform.inc:9 (unused)
OUTPUT_REG          = $000C =    12               clock.inc:38 (unused)
RAM                 = $7800 = 30720  RAM          platform.inc:4 (unused)
RAM_BASE            = $7800 = 30720               platform.inc:17
RAM_SZ              = $0700 =  1792               platform.inc:18
RAM_end             = $7E00 = 32256  RAM          platform.inc:4
RAM_size            = $0600 =  1536  RAM          platform.inc:4
ROM                 = $6000 = 24576  ROM          platform.inc:6 (unused)
ROM_BASE            = $6000 = 24576               platform.inc:14
ROM_SZ              = $1800 =  6144               platform.inc:15
ROM_end             = $7700 = 30464  ROM          platform.inc:6 (unused)
ROM_size            = $1700 =  5888  ROM          platform.inc:6 (unused)
RTC_ALM_ALM0        = $0040 =    64               rtc.inc:1
RTC_ALM_ALM1        = $0080 =   128               rtc.inc:2
RTC_ALM_CFG         = $00C0 =   192               clock.inc:57
RTC_CTRL            = $001E =    30               clock.inc:55
RTC_CTRL_24HR       = $0002 =     2               rtc.inc:41
RTC_CTRL_CFG        = $0006 =     6               clock.inc:60
RTC_CTRL_DSE        = $0001 =     1               rtc.inc:40 (unused)
RTC_CTRL_RUN_BAT    = $0004 =     4               rtc.inc:42
RTC_CTRL_UTI        = $0008 =     8               rtc.inc:43
RTC_DAY             = $0016 =    22               clock.inc:47
RTC_DAY_ALM         = $0017 =    23               clock.inc:48
RTC_DOW             = $0018 =    24               clock.inc:49
RTC_FLAGS           = $001D =    29               clock.inc:54
RTC_FLAG_AF         = $0008 =     8               rtc.inc:38 (unused)
RTC_FLAG_BVF        = $0001 =     1               rtc.inc:35 (unused)
RTC_FLAG_PF         = $0004 =     4               rtc.inc:37 (unused)
RTC_FLAG_PWRF       = $0002 =     2               rtc.inc:36 (unused)
RTC_HRS             = $0014 =    20               clock.inc:45
RTC_HRS_ALM         = $0015 =    21               clock.inc:46
RTC_INTS            = $001C =    28               clock.inc:53
RTC_INTS_CFG        = $0008 =     8               clock.inc:59
RTC_INT_ABE         = $0001 =     1               rtc.inc:30 (unused)
RTC_INT_AIE         = $0008 =     8               rtc.inc:33
RTC_INT_PIE         = $0004 =     4               rtc.inc:32 (unused)
RTC_INT_PWRIE       = $0002 =     2               rtc.inc:31 (unused)
RTC_MIN             = $0012 =    18               clock.inc:43
RTC_MIN_ALM         = $0013 =    19               clock.inc:44
RTC_MON             = $0019 =    25               clock.inc:50
RTC_RATES           = $001B =    27               clock.inc:52
RTC_RATES_CFG       = $0000 =     0               clock.inc:58
RTC_RS_122_070US    = $0030 =    48               rtc.inc:7 (unused)
RTC_RS_125MS        = $00D0 =   208               rtc.inc:17 (unused)
RTC_RS_15_625MS     = $00A0 =   160               rtc.inc:14 (unused)
RTC_RS_1_95315MS    = $0070 =   112               rtc.inc:11 (unused)
RTC_RS_244_141US    = $0040 =    64               rtc.inc:8 (unused)
RTC_RS_250MS        = $00E0 =   224               rtc.inc:18 (unused)
RTC_RS_30_5175US    = $0010 =    16               rtc.inc:5 (unused)
RTC_RS_31_25MS      = $00B0 =   176               rtc.inc:15 (unused)
RTC_RS_3_90625MS    = $0080 =   128               rtc.inc:12 (unused)
RTC_RS_488_281US    = $0050 =    80               rtc.inc:9 (unused)
RTC_RS_500MS        = $00F0 =   240               rtc.inc:19 (unused)
RTC_RS_61_035US     = $0020 =    32               rtc.inc:6 (unused)
RTC_RS_62_5MS       = $00C0 =   192               rtc.inc:16 (unused)
RTC_RS_7_8125MS     = $0090 =   144               rtc.inc:13 (unused)
RTC_RS_976_5625US   = $0060 =    96               rtc.inc:10 (unused)
RTC_RS_NONE         = $0000 =     0               rtc.inc:4
RTC_SEC             = $0010 =    16               clock.inc:41
RTC_SEC_ALM         = $0011 =    17               clock.inc:42
RTC_WD_187_5MS      = $0040 =    64               rtc.inc:25 (unused)
RTC_WD_1_5SEC       = $0000 =     0               rtc.inc:21
RTC_WD_23_4375MS    = $0010 =    16               rtc.inc:22 (unused)
RTC_WD_375MS        = $0050 =    80               rtc.inc:26 (unused)
RTC_WD_3S           = $0070 =   112               rtc.inc:28 (unused)
RTC_WD_46_875MS     = $0020 =    32               rtc.inc:23 (unused)
RTC_WD_750MS        = $0060 =    96               rtc.inc:27 (unused)
RTC_WD_93_75MS      = $0030 =    48               rtc.inc:24 (unused)
RTC_YEAR            = $001A =    26               clock.inc:51
TASK_BUTTON_RD      = $0001 =     1               clock.inc:74
TASK_DISPLAY        = $0005 =     5               clock.inc:78
TASK_WD_POKE        = $0002 =     2               clock.inc:75
TZ_ROM_BASE         = $C000 = 49152               platform.inc:27
TZ_ROM_SZ           = $2000 =  8192               platform.inc:28 (unused)
TZ_SW1_REG          = $0009 =     9               clock.inc:35
TZ_SW2_REG          = $000A =    10               clock.inc:36 (unused)
TZ_SW3_REG          = $000B =    11               clock.inc:37 (unused)
VECTOR_INT_PG       = $0061 =    97               platform.inc:36
WDT_POKE            = $0004 =     4               clock.inc:22
_INITIALIZED        = $7E00 = 32256  _INITIALIZED platform.inc:5
_INITIALIZED_end    = $7F00 = 32512  _INITIALIZED platform.inc:5 (unused)
_INITIALIZED_size   = $0100 =   256  _INITIALIZED platform.inc:5 (unused)
_INITIALIZER        = $7700 = 30464  _INITIALIZER platform.inc:7
_INITIALIZER_end    = $7800 = 30720  _INITIALIZER platform.inc:7 (unused)
_INITIALIZER_size   = $0100 =   256  _INITIALIZER platform.inc:7
bcd_to_dec          = $6CA7 = 27815  ROM          clock_app.s:1075
btn_ack             = $785C = 30812  RAM          clock.s:369
btn_debounce        = $785E = 30814  RAM          clock.s:371
btn_flags           = $785F = 30815  RAM          clock.s:372
btn_state           = $785D = 30813  RAM          clock.s:370
btn_valid           = $785B = 30811  RAM          clock.s:368
button_rd_task      = $6500 = 25856  ROM          clock.s:376
clock_app           = $6800 = 26624  ROM          clock_app.s:78
clock_app_sem       = $7801 = 30721  RAM          clock.s:233
clock_app_start     = $684D = 26701  ROM          clock_app.s:97
clock_exit_app      = $6C04 = 27652  ROM          clock_app.s:930
clock_idle          = $6BD0 = 27600  ROM          clock_app.s:908
clock_jp_tbl        = $6C1E = 27678  ROM          clock_app.s:937
clock_row           = $7874 = 30836  RAM          clock_app.s:44
clock_rtc_day       = $786A = 30826  RAM          clock_app.s:32 (unused)
clock_rtc_dow       = $786B = 30827  RAM          clock_app.s:33 (unused)
clock_rtc_hrs       = $7869 = 30825  RAM          clock_app.s:31 (unused)
clock_rtc_min       = $7868 = 30824  RAM          clock_app.s:30
clock_rtc_mon       = $786C = 30828  RAM          clock_app.s:34 (unused)
clock_rtc_year      = $786D = 30829  RAM          clock_app.s:35
clock_state         = $7864 = 30820  RAM          clock_app.s:24
clock_tz1_sw        = $7865 = 30821  RAM          clock_app.s:26
clock_tz2_sw        = $7866 = 30822  RAM          clock_app.s:27 (unused)
clock_tz3_sw        = $7867 = 30823  RAM          clock_app.s:28 (unused)
clock_tz_day        = $7870 = 30832  RAM          clock_app.s:39
clock_tz_days_in_mon = $7873 = 30835  RAM          clock_app.s:42
clock_tz_dow        = $7871 = 30833  RAM          clock_app.s:40
clock_tz_hrs        = $786F = 30831  RAM          clock_app.s:38
clock_tz_min        = $786E = 30830  RAM          clock_app.s:37
clock_tz_mon        = $7872 = 30834  RAM          clock_app.s:41
clock_upd_req_sem   = $7803 = 30723  RAM          clock.s:235
clock_upd_sem       = $7804 = 30724  RAM          clock.s:236
clock_update        = $6880 = 26752  ROM          clock_app.s:127
configr_adjust_date = $6F32 = 28466  ROM          configr_app.s:403
configr_adjust_day  = $7066 = 28774  ROM          configr_app.s:604
configr_adjust_dow  = $70E3 = 28899  ROM          configr_app.s:693
configr_adjust_hours = $6E2A = 28202  ROM          configr_app.s:204
configr_adjust_mins = $6EA7 = 28327  ROM          configr_app.s:298
configr_adjust_month = $6FE9 = 28649  ROM          configr_app.s:515
configr_adjust_time = $6DEC = 28140  ROM          configr_app.s:168
configr_adjust_year = $6F78 = 28536  ROM          configr_app.s:437
configr_app         = $6D00 = 27904  ROM          configr_app.s:53
configr_app_sem     = $7802 = 30722  RAM          clock.s:234
configr_app_start   = $6D4A = 27978  ROM          configr_app.s:69
configr_apply_date  = $714F = 29007  ROM          configr_app.s:769
configr_apply_time  = $6F11 = 28433  ROM          configr_app.s:377
configr_date_utc    = $71E8 = 29160  ROM          configr_app.s:823
configr_day_msg     = $7053 = 28755  ROM          configr_app.s:595
configr_day_names   = $7208 = 29192  ROM          configr_app.s:829
configr_dow_msg     = $70D0 = 28880  ROM          configr_app.s:684
configr_exit_app    = $7177 = 29047  ROM          configr_app.s:790
configr_hours_msg   = $6E17 = 28183  ROM          configr_app.s:190
configr_jp_tbl      = $7191 = 29073  ROM          configr_app.s:797
configr_main_menu   = $6D84 = 28036  ROM          configr_app.s:96
configr_menu_opt    = $7881 = 30849  RAM          configr_app.s:39
configr_menu_set_date = $71C8 = 29128  ROM          configr_app.s:819
configr_menu_set_time = $71BF = 29119  ROM          configr_app.s:818
configr_minutes_msg = $6E94 = 28308  ROM          configr_app.s:284
configr_month_msg   = $6FD6 = 28630  ROM          configr_app.s:506
configr_rtc_day     = $7884 = 30852  RAM          configr_app.s:43
configr_rtc_dow     = $7885 = 30853  RAM          configr_app.s:44
configr_rtc_hrs     = $7883 = 30851  RAM          configr_app.s:42
configr_rtc_min     = $7882 = 30850  RAM          configr_app.s:41
configr_rtc_mon     = $7886 = 30854  RAM          configr_app.s:45
configr_rtc_year    = $7887 = 30855  RAM          configr_app.s:46
configr_set_day     = $71FC = 29180  ROM          configr_app.s:826
configr_set_hours   = $71DA = 29146  ROM          configr_app.s:821
configr_set_minutes = $71E0 = 29152  ROM          configr_app.s:822
configr_set_month   = $71F6 = 29174  ROM          configr_app.s:825
configr_set_weekday = $7200 = 29184  ROM          configr_app.s:827
configr_set_year    = $71F1 = 29169  ROM          configr_app.s:824
configr_state       = $7880 = 30848  RAM          configr_app.s:38
configr_time_utc    = $71D1 = 29137  ROM          configr_app.s:820
configr_title       = $71B7 = 29111  ROM          configr_app.s:817
configr_year_msg    = $6F65 = 28517  ROM          configr_app.s:428
ctc_ch0_isr         = $7300 = 29440  ROM          ctc_isr.s:4
ctc_ch1_isr         = $7380 = 29568  ROM          ctc_isr.s:30
ctc_ch2_isr         = $7400 = 29696  ROM          ctc_isr.s:187
ctc_ch3_isr         = $7480 = 29824  ROM          ctc_isr.s:233
day_array_ptr       = $787B = 30843  RAM          clock_app.s:49
days_common_year    = $6C30 = 27696  ROM          clock_app.s:944
days_leap_year      = $6C40 = 27712  ROM          clock_app.s:949
disp_cur_row        = $7888 = 30856  RAM          ctc_isr.s:24
disp_dim            = $788A = 30858  RAM          ctc_isr.s:26
disp_dim_ctr        = $7889 = 30857  RAM          ctc_isr.s:25
display_ctr         = $7860 = 30816  RAM          clock.s:429
display_dp1         = $7838 = 30776  RAM          clock.s:249
display_dp2         = $7839 = 30777  RAM          clock.s:250 (unused)
display_dp3         = $783A = 30778  RAM          clock.s:251 (unused)
display_effect      = $7863 = 30819  RAM          clock.s:432
display_row1        = $7820 = 30752  RAM          clock.s:246
display_row2        = $7828 = 30760  RAM          clock.s:247 (unused)
display_row3        = $7830 = 30768  RAM          clock.s:248 (unused)
display_status      = $7861 = 30817  RAM          clock.s:430
display_syncd       = $7862 = 30818  RAM          clock.s:431 (unused)
display_task        = $6600 = 26112  ROM          clock.s:438
find_first_sunday   = $6C70 = 27760  ROM          clock_app.s:976
find_last_sunday    = $6C8B = 27787  ROM          clock_app.s:1020
find_second_sunday  = $6CA0 = 27808  ROM          clock_app.s:1058
foreground_mtx      = $7800 = 30720  RAM          clock.s:227
init                = $6300 = 25344  ROM          clock.s:263
int_vector_table    = $6100 = 24832  ROM          clock.s:51 (unused)
main_loop           = $6400 = 25600  ROM          clock.s:336
mem_test            = $6283 = 25219  ROM          clock.s:182
memcpy              = $7500 = 29952  ROM          c_lib.s:21
memset              = $7540 = 30016  ROM          c_lib.s:111
nmi_vector          = $6066 = 24678  ROM          clock.s:47 (unused)
proc_test           = $6200 = 25088  ROM          clock.s:68
row_borrows         = $787E = 30846  RAM          clock_app.s:57
row_buf_ptr         = $7879 = 30841  RAM          clock_app.s:48
row_carrys          = $787D = 30845  RAM          clock_app.s:51
row_flags           = $787F = 30847  RAM          clock_app.s:63
serial_loading      = $0001 =     1               clock.s:1 (unused)
short_day_names     = $6C50 = 27728  ROM          clock_app.s:954
staging_dp1         = $7858 = 30808  RAM          clock.s:257 (unused)
staging_dp2         = $7859 = 30809  RAM          clock.s:258 (unused)
staging_dp3         = $785A = 30810  RAM          clock.s:259 (unused)
staging_row1        = $7840 = 30784  RAM          clock.s:254
staging_row2        = $7848 = 30792  RAM          clock.s:255
staging_row3        = $7850 = 30800  RAM          clock.s:256
strncpy             = $7520 = 29984  ROM          c_lib.s:57
task_sched          = $7810 = 30736  RAM          clock.s:239
tz_rom_ptr          = $7877 = 30839  RAM          clock_app.s:47
tz_sw_ptr           = $7875 = 30837  RAM          clock_app.s:46
wd_poke_task        = $6700 = 26368  ROM          clock.s:508

; +++ local symbols +++

next_regs      = $6201 = 25089  ROM          clock.s:73 (unused)
proc_test_done = $626B = 25195  ROM          clock.s:147
proc_test_err  = $6282 = 25218  ROM          clock.s:165
write_pattern  = $6253 = 25171  ROM          clock.s:125

; +++ local symbols +++

mem_test_err      = $62A3 = 25251  ROM          clock.s:215
mem_test_loop     = $6294 = 25236  ROM          clock.s:199
mem_test_next     = $628A = 25226  ROM          clock.s:190
mem_test_patterns = $62A4 = 25252  ROM          clock.s:218

; +++ local symbols +++

done    = $6525 = 25893  ROM          clock.s:408

; +++ local symbols +++

done        = $663E = 26174  ROM          clock.s:487
dsky_effect = $6615 = 26133  ROM          clock.s:452

; +++ local symbols +++


; +++ local symbols +++

apply_dimming      = $6B1D = 27421  ROM          clock_app.s:752
begin_computation  = $68FE = 26878  ROM          clock_app.s:229
check1             = $6A1A = 27162  ROM          clock_app.s:489
check1_done        = $6A2E = 27182  ROM          clock_app.s:505
check2             = $6A46 = 27206  ROM          clock_app.s:542
check3_day_equal   = $6A94 = 27284  ROM          clock_app.s:615
check3_last_sun    = $6A79 = 27257  ROM          clock_app.s:584
check3_match_day   = $6A89 = 27273  ROM          clock_app.s:597
check3_second_sun  = $6A82 = 27266  ROM          clock_app.s:590
check4_day_equal   = $6AD4 = 27348  ROM          clock_app.s:679
check4_last_sun    = $6AC2 = 27330  ROM          clock_app.s:654
check4_match_day   = $6AC9 = 27337  ROM          clock_app.s:661
check_end_cond     = $6AA3 = 27299  ROM          clock_app.s:632
check_for_dst      = $6AEA = 27370  ROM          clock_app.s:702
check_start_cond   = $6A58 = 27224  ROM          clock_app.s:560
day_continue       = $699B = 27035  ROM          clock_app.s:364
dimming_off        = $6B1C = 27420  ROM          clock_app.s:749
dimming_on         = $6B18 = 27416  ROM          clock_app.s:745
display_date       = $6B68 = 27496  ROM          clock_app.s:823
display_row        = $6AF9 = 27385  ROM          clock_app.s:713
display_time       = $6B29 = 27433  ROM          clock_app.s:767 (unused)
dst_end_mon_higher = $6A17 = 27159  ROM          clock_app.s:486
hrs_min_to_buf     = $6B4C = 27468  ROM          clock_app.s:795
mon_borrow_fix_day = $69AE = 27054  ROM          clock_app.s:387
mon_day_dec        = $6BA3 = 27555  ROM          clock_app.s:874
mon_day_to_buf     = $6B86 = 27526  ROM          clock_app.s:846
no_day_borrow      = $6978 = 27000  ROM          clock_app.s:335
no_dimming         = $6B20 = 27424  ROM          clock_app.s:755
no_hrs_borrow      = $692E = 26926  ROM          clock_app.s:272
no_hrs_carry       = $6938 = 26936  ROM          clock_app.s:281
no_mon_borrow      = $69C9 = 27081  ROM          clock_app.s:409
no_mon_carry       = $69ED = 27117  ROM          clock_app.s:435
nodst_start_mon_higher = $6A43 = 27203  ROM          clock_app.s:539
not_leap_year      = $6948 = 26952  ROM          clock_app.s:295
row_loop           = $68BE = 26814  ROM          clock_app.s:176
row_loop_done      = $6BA8 = 27560  ROM          clock_app.s:882

; +++ local symbols +++

check_semaphore = $6BE6 = 27622  ROM          clock_app.s:919

; +++ local symbols +++

done    = $6C89 = 27785  ROM          clock_app.s:1000
loop    = $6C83 = 27779  ROM          clock_app.s:995

; +++ local symbols +++

done    = $6C9E = 27806  ROM          clock_app.s:1040
loop    = $6C93 = 27795  ROM          clock_app.s:1029

; +++ local symbols +++

do_msg         = $6D97 = 28055  ROM          configr_app.s:107
enter_menu1    = $6DCA = 28106  ROM          configr_app.s:136
test_enter_btn = $6DB0 = 28080  ROM          configr_app.s:121
test_updn_btns = $6DD2 = 28114  ROM          configr_app.s:142

; +++ local symbols +++

cp_99          = $6E8E = 28302  ROM          configr_app.s:271
down_button    = $6E7D = 28285  ROM          configr_app.s:257
store          = $6E85 = 28293  ROM          configr_app.s:261
test_enter_btn = $6E57 = 28247  ROM          configr_app.s:234
test_updn_btns = $6E6A = 28266  ROM          configr_app.s:243

; +++ local symbols +++

cp_99          = $6F0B = 28427  ROM          configr_app.s:365
down_button    = $6EFA = 28410  ROM          configr_app.s:351
store          = $6F02 = 28418  ROM          configr_app.s:355
test_enter_btn = $6ED4 = 28372  ROM          configr_app.s:328
test_updn_btn  = $6EE7 = 28391  ROM          configr_app.s:337

; +++ local symbols +++

down_button    = $6FCB = 28619  ROM          configr_app.s:490
store          = $6FD3 = 28627  ROM          configr_app.s:494
test_enter_btn = $6FA5 = 28581  ROM          configr_app.s:467
test_updn_btn  = $6FB8 = 28600  ROM          configr_app.s:476

; +++ local symbols +++

cp_0           = $704D = 28749  ROM          configr_app.s:582
down_button    = $703C = 28732  ROM          configr_app.s:568
store          = $7044 = 28740  ROM          configr_app.s:572
test_enter_btn = $7016 = 28694  ROM          configr_app.s:545
test_updn_btn  = $7029 = 28713  ROM          configr_app.s:554

; +++ local symbols +++

cp_0           = $70CA = 28874  ROM          configr_app.s:671
down_button    = $70B9 = 28857  ROM          configr_app.s:657
store          = $70C1 = 28865  ROM          configr_app.s:661
test_enter_btn = $7093 = 28819  ROM          configr_app.s:634
test_updn_btn  = $70A6 = 28838  ROM          configr_app.s:643

; +++ local symbols +++

cp_0           = $7149 = 29001  ROM          configr_app.s:757
down_button    = $7138 = 28984  ROM          configr_app.s:743
store          = $7140 = 28992  ROM          configr_app.s:747
test_enter_btn = $710F = 28943  ROM          configr_app.s:719
test_updn_btn  = $7122 = 28962  ROM          configr_app.s:728

; +++ local symbols +++

next_row_char  = $73AB = 29611  ROM          ctc_isr.s:109
out_disp_ctrl  = $73D2 = 29650  ROM          ctc_isr.s:159
row_offset     = $7392 = 29586  ROM          ctc_isr.s:73
row_offset_add = $739F = 29599  ROM          ctc_isr.s:87
shift_offset   = $739B = 29595  ROM          ctc_isr.s:82

; +++ local symbols +++

clock_sem   = $7417 = 29719  ROM          ctc_isr.s:201 (unused)
configr_sem = $7440 = 29760  ROM          ctc_isr.s:206
done        = $7469 = 29801  ROM          ctc_isr.s:211

; +++ local symbols +++

done    = $74AB = 29867  ROM          ctc_isr.s:251

; +++ local symbols +++

zero_fill = $752D = 29997  ROM          c_lib.s:75

; +++ local symbols +++

next    = $7541 = 30017  ROM          c_lib.s:115


total time: 0.0398 sec.
no errors
