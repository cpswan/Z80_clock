              	; --------------------------------------
              	; zasm: assemble "clock.s"
              	; date: 2020-04-03 10:39:56
              	; --------------------------------------


              	; #define serial_loading 1
              	
              	#target ROM
              	#include "platform.inc"
              	;---- Oscillator frequencies (in Hz)
              	;     * FSYS is the primary system oscillator which drives the CPU.
              	;     * FCTC is a secondary oscillator external to the CTC which can
              	;       be prescaled and is fed in to the TRG1 input.
              	;     * FUART is the frequency fed into the SIO clock inputs for baud
              	;       rate generation.
8D80:         	FSYS                    .equ  6000000
8000:         	FCTC                    .equ  4096000
8000:         	FUART                   .equ  7372800
              	
              	;---- Memory sizes (in bytes)
              	;     Define the start (base) and size of ROMs and RAM.
              	#if defined(serial_loading)
              	ROM_BASE                .equ  0x6000
              	ROM_SZ                  .equ  6144
              	
              	RAM_BASE                .equ  0x7800
              	RAM_SZ                  .equ  1792
              	#else
0000:         	ROM_BASE                .equ  0
6000:         	ROM_SZ                  .equ  24576
              	
6000:         	RAM_BASE                .equ  0x6000
2000:         	RAM_SZ                  .equ  8192
              	#endif
              	
C000:         	TZ_ROM_BASE             .equ  0xC000
2000:         	TZ_ROM_SZ               .equ  8192
              	
E000:         	CHAR_ROM_BASE           .equ  0xE000
2000:         	CHAR_ROM_SZ             .equ  8192
              	
              	;---- Vector interrupt page number
              	;     Forms the most significant byte of the interrupt vector address
              	;     for Mode 2 interrupts.
0001:         	VECTOR_INT_PG           .equ  (ROM_BASE+0x100)>>8
              	
              	; END platform.inc
              	#include "ctc.inc"
0001:         	CTC_CTL_WORD            .equ  0x1   ; This is a control word
0002:         	CTC_CTL_SW_RESET        .equ  0x2   ; Perform SW reset on channel
0004:         	CTC_CTL_TCONST          .equ  0x4   ; Time constant follows
0008:         	CTC_CTL_CLKTRG_ST       .equ  0x8   ; CLK/TRG pulse starts timer
0010:         	CTC_CTL_RISE            .equ  0x10  ; CLK/TRG rising edge
0020:         	CTC_CTL_PS_256          .equ  0x20  ; Prescaler of 256
0040:         	CTC_CTL_CTR_MODE        .equ  0x40  ; Channel in counter mode
0080:         	CTC_CTL_INT_EN          .equ  0x80  ; Enable interrupt on this channel
              	
              	; END ctc.inc
              	#include "rtc.inc"
0040:         	RTC_ALM_ALM0            .equ  0x40
0080:         	RTC_ALM_ALM1            .equ  0x80
              	
0000:         	RTC_RS_NONE             .equ  0
0010:         	RTC_RS_30_5175US        .equ  0x01 << 4
0020:         	RTC_RS_61_035US         .equ  0x02 << 4
0030:         	RTC_RS_122_070US        .equ  0x03 << 4
0040:         	RTC_RS_244_141US        .equ  0x04 << 4
0050:         	RTC_RS_488_281US        .equ  0x05 << 4
0060:         	RTC_RS_976_5625US       .equ  0x06 << 4
0070:         	RTC_RS_1_95315MS        .equ  0x07 << 4
0080:         	RTC_RS_3_90625MS        .equ  0x08 << 4
0090:         	RTC_RS_7_8125MS         .equ  0x09 << 4
00A0:         	RTC_RS_15_625MS         .equ  0x0A << 4
00B0:         	RTC_RS_31_25MS          .equ  0x0B << 4
00C0:         	RTC_RS_62_5MS           .equ  0x0C << 4
00D0:         	RTC_RS_125MS            .equ  0x0D << 4
00E0:         	RTC_RS_250MS            .equ  0x0E << 4
00F0:         	RTC_RS_500MS            .equ  0x0F << 4
              	
0000:         	RTC_WD_1_5SEC           .equ  0
0010:         	RTC_WD_23_4375MS        .equ  0x01 << 4
0020:         	RTC_WD_46_875MS         .equ  0x02 << 4
0030:         	RTC_WD_93_75MS          .equ  0x03 << 4
0040:         	RTC_WD_187_5MS          .equ  0x04 << 4
0050:         	RTC_WD_375MS            .equ  0x05 << 4
0060:         	RTC_WD_750MS            .equ  0x06 << 4
0070:         	RTC_WD_3S               .equ  0x07 << 4
              	
0001:         	RTC_INT_ABE             .equ  0x01
0002:         	RTC_INT_PWRIE           .equ  0x02
0004:         	RTC_INT_PIE             .equ  0x04
0008:         	RTC_INT_AIE             .equ  0x08
              	
0001:         	RTC_FLAG_BVF            .equ  0x01
0002:         	RTC_FLAG_PWRF           .equ  0x02
0004:         	RTC_FLAG_PF             .equ  0x04
0008:         	RTC_FLAG_AF             .equ  0x08
              	
0001:         	RTC_CTRL_DSE            .equ  0x01
0002:         	RTC_CTRL_24HR           .equ  0x02
0004:         	RTC_CTRL_RUN_BAT        .equ  0x04
0008:         	RTC_CTRL_UTI            .equ  0x08
              	
              	; END rtc.inc
              	#include "clock.inc"
              	;---------------------------------------------------------------------
              	;                 PERIPHERAL CONFIGURATION & IO PORTS                :
              	;---------------------------------------------------------------------
              	
              	; CTC channel addresses
0000:         	CTC_CH0           .equ  0
0001:         	CTC_CH1           .equ  0x01
0002:         	CTC_CH2           .equ  0x02
0003:         	CTC_CH3           .equ  0x03
              	
              	; CTC channel configuration
0001:         	CTC_CH0_CFG       .equ  CTC_CTL_WORD
00A5:         	CTC_CH1_CFG       .equ  CTC_CTL_INT_EN | CTC_CTL_PS_256 | CTC_CTL_TCONST | CTC_CTL_WORD
00A5:         	CTC_CH2_CFG       .equ  CTC_CTL_INT_EN | CTC_CTL_PS_256 | CTC_CTL_TCONST | CTC_CTL_WORD
00C5:         	CTC_CH3_CFG       .equ  CTC_CTL_INT_EN | CTC_CTL_CTR_MODE | CTC_CTL_TCONST | CTC_CTL_WORD
              	
0017:         	CTC_CH1_TCONST    .equ  FSYS / 256 / 1000
00EA:         	CTC_CH2_TCONST    .equ  FSYS / 256 / 100
0001:         	CTC_CH3_TCONST    .equ  0x01
              	
              	; Watchdog poke register
0004:         	WDT_POKE          .equ  0x04
              	
              	; Buttons and switches
0008:         	BTN_REG           .equ  0x08        ; Buttons/switches
              	                                    ;   Masks
0001:         	BTN_UP            .equ  0x01        ;     Up button
0002:         	BTN_DN            .equ  0x02        ;     Down button
0004:         	BTN_ENT           .equ  0x04        ;     Enter button
0008:         	BTN_ESC           .equ  0x08        ;     Escape button
000F:         	BTN_ALL           .equ  0x0F        ;     All buttons
0030:         	DIMM_ROW          .equ  0x30        ;     Dimming row bits
0040:         	DUTY_CYCLE        .equ  0x40        ;     Dimming duty cycle
              	                                    ;   Bits
0000:         	BTN_UP_BIT        .equ  0           ;     Up button
0001:         	BTN_DN_BIT        .equ  1           ;     Down button
0002:         	BTN_ENT_BIT       .equ  2           ;     Enter button
0003:         	BTN_ESC_BIT       .equ  3           ;     Escape button
0004:         	DIMM_ROW_SW0      .equ  4           ;     Dimming row select bit 0
0004:         	DIMM_ROW_SW1      .equ  4           ;     Dimming row select bit 1
0006:         	DUTY_CYCLE_BIT    .equ  6           ;     Dimming duty cycle
0009:         	TZ_SW1_REG        .equ  0x09        ; Switches 1 (timezone 1)
000A:         	TZ_SW2_REG        .equ  0x0A        ; Switches 2 (timezone 2)
000B:         	TZ_SW3_REG        .equ  0x0B        ; Switches 3 (timezone 3)
000C:         	OUTPUT_REG        .equ  0x0C        ; Outputs, e.g. beeper
              	
              	; RTC register addresses
0010:         	RTC_SEC           .equ  0x10
0011:         	RTC_SEC_ALM       .equ  0x11
0012:         	RTC_MIN           .equ  0x12
0013:         	RTC_MIN_ALM       .equ  0x13
0014:         	RTC_HRS           .equ  0x14
0015:         	RTC_HRS_ALM       .equ  0x15
0016:         	RTC_DAY           .equ  0x16
0017:         	RTC_DAY_ALM       .equ  0x17
0018:         	RTC_DOW           .equ  0x18
0019:         	RTC_MON           .equ  0x19
001A:         	RTC_YEAR          .equ  0x1A
001B:         	RTC_RATES         .equ  0x1B
001C:         	RTC_INTS          .equ  0x1C
001D:         	RTC_FLAGS         .equ  0x1D
001E:         	RTC_CTRL          .equ  0x1E
              	
00C0:         	RTC_ALM_CFG       .equ  RTC_ALM_ALM1 | RTC_ALM_ALM0
0000:         	RTC_RATES_CFG     .equ  RTC_WD_1_5SEC | RTC_RS_NONE
0008:         	RTC_INTS_CFG      .equ  RTC_INT_AIE
0006:         	RTC_CTRL_CFG      .equ  RTC_CTRL_RUN_BAT | RTC_CTRL_24HR
              	
              	; Display registers
0020:         	DISP_DATA         .equ  0x20        ; Display data register
0021:         	DISP_CTRL         .equ  0x21        ; Display control register
              	
              	;---------------------------------------------------------------------
              	;                         TASK/APP CONSTANTS                         :
              	;---------------------------------------------------------------------
              	
              	; Apps differ from tasks in that tasks can be (de)scheduled, while
              	; apps are scheduled at boot and dont become descheduled. They share
              	; common infrastructure, however.
              	
0001:         	TASK_BUTTON_RD          .equ  1     ; Button reader
0002:         	TASK_WD_POKE            .equ  2     ; Poke the watchdog
0003:         	APP_CLOCK               .equ  3     ; Clock application
0004:         	APP_CONFIGR             .equ  4     ; Configuration application
0005:         	TASK_DISPLAY            .equ  5     ; Display updater
              	
              	;---------------------------------------------------------------------
              	;                           MISCELLANEOUS                            :
              	;---------------------------------------------------------------------
00DE:         	DEBUG_PORT              .equ  0xDE
              	
              	;---------------------------------------------------------------------
              	;                              MACROS                                :
              	;---------------------------------------------------------------------
              	
              	;---------------------------------------------------------------------
              	;     schedule_task                                                  :
              	;                                                                    :
              	; Description                                                        :
              	;     Schedule a task to be run at the next iteration of the main    :
              	;     loop.                                                          :
              	;                                                                    :
              	;     This is achieved by loading a positive value (the task number  :
              	;     itself, which is used as an offset) into the task's scheduling :
              	;     byte.                                                          :
              	;                                                                    :
              	; Parameters                                                         :
              	;     task_num  Task number to schedule                              :
              	;                                                                    :
              	;---------------------------------------------------------------------
              	schedule_task .macro task_num
              	      push  HL
              	
              	      ld    HL, task_sched+&task_num
              	      ld    (HL), &task_num
              	
              	      pop   HL
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     deschedule_task                                                :
              	;                                                                    :
              	; Description                                                        :
              	;     De-schedule a task to prevent it from running during future    :
              	;     iterations of the main loop.                                   :
              	;                                                                    :
              	;     This is achieved by loading a value of zero into the task's    :
              	;     scheduling byte.                                               :
              	;                                                                    :
              	; Parameters                                                         :
              	;     task_num  Task number to deschedule                            :
              	;---------------------------------------------------------------------
              	deschedule_task .macro task_num
              	      push  HL
              	
              	      ld    HL, task_sched+&task_num
              	      ld    (HL), 0
              	
              	      pop   HL
              	      .endm
              	
              	
              	
              	;---------------------------------------------------------------------
              	;     run_task                                                       :
              	;                                                                    :
              	; Description                                                        :
              	;     Runs a task if it has been scheduled.                          :
              	;                                                                    :
              	;     A task is scheduled if its task scheduling byte contains any   :
              	;     non-zero value.                                                :
              	;                                                                    :
              	; Parameters                                                         :
              	;     task_num    Task number to run                                 :
              	;     call_label  If scheduled, the label to CALL                    :
              	;---------------------------------------------------------------------
              	run_task .macro task_num, call_label
              	      ld    HL, task_sched+&task_num
              	      ld    A, (HL)
              	      or    A, A
              	
              	      call  NZ, &call_label
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     set_state                                                      :
              	;                                                                    :
              	; Description                                                        :
              	;     Update the value of a state machine variable.                  :
              	;                                                                    :
              	; Parameters                                                         :
              	;     sm     Destination state machine variable                      :
              	;     state  State to be loaded                                      :
              	;---------------------------------------------------------------------
              	set_state .macro sm, state
              	      push  AF
              	
              	      ld    A, &state
              	      ld    (&sm), A
              	
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     mtx_trylock                                                    :
              	;                                                                    :
              	; Description                                                        :
              	;     Attempts to acquire the mutex pointed to by the mutex          :
              	;     parameter. If the mutex cannot be immediately acquired         :
              	;     mtx_trylock will return 0, otherwise the mutex will be         :
              	;     acquired and a non-zero value will be returned.                :
              	;                                                                    :
              	;     Interrupt safe: interrupts are disabled throughout the         :
              	;                     critical code path, and restored to original   :
              	;                     state upon completion.                         :
              	;                                                                    :
              	; Parameters                                                         :
              	;     mutex     Address of mutex to acquire                          :
              	;     task_num  The task number that wants to acquire the mutex      :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  0 if lock not acquired, or task_num if acquired             :
              	;     F  Z flag is set or cleared based on value of A                :
              	;---------------------------------------------------------------------
              	mtx_trylock .macro mutex, task_num
              	      push  HL
              	
              	      ld    A, I                    ; IFF2 to P/V flag
              	      push  AF                      ; Save flags
              	      di                            ; Ensure interrupts disabled
              	
              	      ld    HL, &mutex
              	      ld    A, (HL)                 ; Check current mutex owner
              	      or    A, A
              	      jr    Z, $+9                  ; If zero, acquire it
              	
              	      cp    A, &task_num            ; If not zero, do we own it?
              	      jr    Z, $+8                  ; Yes if Z, return mutex value
              	
              	      xor   A, A                    ; No otherwise, return 0
              	      jr    $+5                     ; Go to done
              	
              	      ld    A, &task_num            ; Acquire by loading task_num into
              	      ld    (HL), A                 ; mutex
              	
              	      pop   HL                      ; F into L
              	      bit   2, L                    ; Test IFF2 flag
              	      jr    Z, $+3                  ; If IFF2 was not set, go to done
              	      ei                            ; Re-enable interrupts
              	
              	      pop   HL                      ; Done
              	
              	      or    A, A                    ; Set Z flag according to A
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     mtx_unlock                                                     :
              	;                                                                    :
              	; Description                                                        :
              	;     Releases a mutual exclusion lock.                              :
              	;                                                                    :
              	;     Interrupt safe: interrupts are disabled throughout the         :
              	;                     critical code path, and restored to original   :
              	;                     state upon completion.                         :
              	;                                                                    :
              	; Parameters                                                         :
              	;     mutex     Address of mutex to unlock                           :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;---------------------------------------------------------------------
              	mtx_unlock .macro mutex
              	      push  AF
              	      push  HL
              	
              	      ld    A, I                    ; IFF2 to P/V flag
              	      push  AF                      ; Save flags
              	      di                            ; Ensure interrupts disabled
              	
              	      xor   A, A                    ; Load zero to unlock the mutex
              	      ld    (&mutex), A
              	
              	      pop   HL                      ; F into L
              	      bit   2, L                    ; Test IFF2 flag
              	      jr    Z, $+3                  ; If IFF2 was not set, go to done
              	      ei                            ; Re-enable interrupts
              	
              	      pop   HL                      ; Done
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     mtx_owned                                                      :
              	;                                                                    :
              	; Description                                                        :
              	;     Returns non-zero if the task indicated by the task_num param   :
              	;     owns the mutex. If that task does not hold the mutex, zero is  :
              	;     returned.                                                      :
              	;                                                                    :
              	;     Interrupt safe: interrupts are disabled throughout the         :
              	;                     critical code path, and restored to original   :
              	;                     state upon completion.                         :
              	;                                                                    :
              	; Parameters                                                         :
              	;     mutex     Address of mutex to check ownership of               :
              	;     task_num  The task number to compare                           :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  0 if lock not owned, or task_num if owned                   :
              	;     F  Z flag is set or cleared based on value of A                :
              	;---------------------------------------------------------------------
              	mtx_owned .macro mutex, task_num
              	      push  HL
              	
              	      ld    A, I                    ; IFF2 to P/V flag
              	      push  AF                      ; Save flags
              	      di                            ; Ensure interrupts disabled
              	
              	      ld    A, (&mutex)             ; Compare the value stored in
              	      cp    A, &task_num            ; (mutex) with task_num.
              	      jr    Z, $+3
              	
              	      xor   A, A                    ; Not equal, return 0
              	
              	      pop   HL                      ; F into L
              	      bit   2, L                    ; Test IFF2 flag
              	      jr    Z, $+3                  ; If IFF2 was not set, go to done
              	      ei                            ; Re-enable interrupts
              	
              	      pop   HL                      ; Done
              	
              	      or    A, A
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     sem_post                                                       :
              	;                                                                    :
              	; Description                                                        :
              	;     Increment (unlock) a semaphore.                                :
              	;                                                                    :
              	;     Interrupt safe: interrupts are disabled throughout the         :
              	;                     critical code path, and restored to original   :
              	;                     state upon completion.                         :
              	;                                                                    :
              	; Parameters                                                         :
              	;     sem       Address of semaphore to increment (unlock)           :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;---------------------------------------------------------------------
              	sem_post .macro sem
              	      push  AF
              	      push  HL
              	
              	      ld    A, I                    ; IFF2 to P/V flag
              	      push  AF                      ; Save flags
              	      di                            ; Ensure interrupts disabled
              	
              	      ld    HL, &sem
              	      inc   (HL)
              	
              	      pop   HL                      ; F into L
              	      bit   2, L                    ; Test IFF2 flag
              	      jr    Z, $+3                  ; If IFF2 was not set, go to done
              	      ei                            ; Re-enable interrupts
              	
              	      pop   HL
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     sem_trywait                                                    :
              	;                                                                    :
              	; Description                                                        :
              	;     sem_trywait decrements (locks) the semaphore only if the value :
              	;     is non-zero. Otherwise, the semaphore is not decremented and   :
              	;     an error (0) is returned.                                      :
              	;                                                                    :
              	;     Interrupt safe: interrupts are disabled throughout the         :
              	;                     critical code path, and restored to original   :
              	;                     state upon completion.                         :
              	;                                                                    :
              	; Parameters                                                         :
              	;     sem       Address of semaphore to increment (unlock)           :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  0 if semaphore locked, or semaphore value pre-decrement     :
              	;     F  Z flag is set or cleared based on value of A                :
              	;---------------------------------------------------------------------
              	sem_trywait .macro sem
              	      push  HL
              	
              	      ld    A, I                    ; IFF2 to P/V flag
              	      push  AF                      ; Save flags
              	      di                            ; Ensure interrupts disabled
              	
              	      ld    HL, &sem
              	      ld    A, (HL)                 ; Load semaphore value for return
              	      or    A, A                    ; Semaphore value greater than 0?
              	      jr    Z, $+3                  ; If Z, return 0, go to done
              	
              	      dec   (HL)                    ; Decrement semaphore
              	
              	      pop   HL                      ; F into L
              	      bit   2, L                    ; Test IFF2 flag
              	      jr    Z, $+3                  ; If IFF2 was not set, go to done
              	      ei                            ; Re-enable interrupts
              	
              	      pop   HL                      ; Done
              	
              	      or    A, A                    ; Set Z flag according to A
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     set_valid_btn_mask                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Update the valid button mask to a new value.                   :
              	;                                                                    :
              	;     Presumably this is done while switching between states in an   :
              	;     app or task, so to prevent any unacknowledged or very recent   :
              	;     button presses being immediately acted upon within the new     :
              	;     state, those button presses are nulled out and made            :
              	;     acknowledged. Therefore the user will need to release those    :
              	;     button(s) before they can be re-recognised as new presses.     :
              	;                                                                    :
              	; Parameters                                                         :
              	;     mask  New button mask to apply                                 :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;---------------------------------------------------------------------
              	set_valid_btn_mask .macro mask
              	      push  AF
              	      push  BC
              	
              	      ld    A, (btn_state)          ; Ack all un-ack'd buttons by
              	      ld    B, A                    ; OR'ing them with all ack'd
              	      ld    A, (btn_ack)            ; buttons.
              	      or    A, B
              	      ld    (btn_ack), A
              	
              	      ld    A, &mask
              	      ld    (btn_valid), A          ; Load new mask
              	
              	      pop   BC
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     ack_btn                                                        :
              	;                                                                    :
              	; Description                                                        :
              	;     Acknowledge a button press by setting its appropriate bit in   :
              	;     the btn_ack variable.                                          :
              	;---------------------------------------------------------------------
              	ack_btn .macro button
              	      push  HL
              	
              	      ld    HL, btn_ack             ; Ack the button
              	      set   &button, (HL)
              	
              	      pop   HL
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     rtc_update_lock                                                :
              	;                                                                    :
              	; Description                                                        :
              	;     Set the Update Transfer Inhibit bit of the RTC control         :
              	;     register.                                                      :
              	;                                                                    :
              	;     Prevents the RTC from updating public registers while they are :
              	;     being read by an application.                                  :
              	;---------------------------------------------------------------------
              	rtc_update_lock .macro
              	      push  AF
              	
              	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
              	      out   (RTC_CTRL), A
              	
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     rtc_update_unlock                                              :
              	;                                                                    :
              	; Description                                                        :
              	;     Clear the Update Transfer Inhibit bit of the RTC control       :
              	;     register.                                                      :
              	;                                                                    :
              	;     Allows the RTC to update public registers so that their new    :
              	;     values may be read by an application.                          :
              	;---------------------------------------------------------------------
              	rtc_update_unlock .macro
              	      push  AF
              	
              	      ld    A, RTC_CTRL_CFG
              	      out   (RTC_CTRL), A
              	
              	      pop   AF
              	      .endm
              	
              	
              	;---------------------------------------------------------------------
              	;     get_jp_table_entry                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Using A as an index, return the value of a double word from    :
              	;     the supplied table to be used as an address to perform a jump. :
              	;                                                                    :
              	;     The value of A is doubled and added to the supplied table      :
              	;     address.                                                       :
              	;                                                                    :
              	; Parameters                                                         :
              	;     table  Address of the table to return entry from               :
              	;                                                                    :
              	; Returns                                                            :
              	;     HL  Address at index in jump table                             :
              	;---------------------------------------------------------------------
              	get_jp_table_entry .macro table
              	      push DE
              	
              	      ld    D, 0                    ; DE becomes offset by doubling A
              	      ld    E, A
              	      sla   E
              	      rl    D
              	
              	      ld    HL, &table              ; HL = pointer to jump table
              	      add   HL, DE                  ; Add offset to pointer
              	
              	      ld    E, (HL)                 ; Load HL pair into DE
              	      inc   HL
              	      ld    D, (HL)
              	
              	      ex    DE, HL                  ; DE becomes HL for return
              	
              	      pop   DE
              	      .endm
              	
              	; END clock.inc
              	
6000:         	#data RAM, RAM_BASE, RAM_SZ-256
7F00:         	#data _INITIALIZED, *, 256
0000:         	#code ROM, ROM_BASE, ROM_SZ-256
5F00:         	#code _INITIALIZER, *, 256
              	
              	#code ROM
              	;---------------------------------------------------------------------
              	;                           RESTART VECTORS                          :
              	;---------------------------------------------------------------------
              	      .org ROM_BASE
0000: C30002  	      jp    proc_test
              	
0003: FFFFFFFF	      .org ROM_BASE+0x8             ; RST1
0007: FF      	
0008: 76      	      halt
              	
0009: FFFFFFFF	      .org ROM_BASE+0x10            ; RST2
000D: FFFFFF  	
0010: 76      	      halt
              	
0011: FFFFFFFF	      .org ROM_BASE+0x18            ; RST3
0015: FFFFFF  	
0018: 76      	      halt
              	
0019: FFFFFFFF	      .org ROM_BASE+0x20            ; RST4
001D: FFFFFF  	
0020: 76      	      halt
              	
0021: FFFFFFFF	      .org ROM_BASE+0x28            ; RST5
0025: FFFFFF  	
0028: 76      	      halt
              	
0029: FFFFFFFF	      .org ROM_BASE+0x30            ; RST6
002D: FFFFFF  	
0030: 76      	      halt
              	
0031: FFFFFFFF	      .org ROM_BASE+0x38            ; RST7
0035: FFFFFF  	
0038: 76      	      halt
              	
              	
              	;---------------------------------------------------------------------
              	;                          INTERRUPT VECTORS                         :
              	;---------------------------------------------------------------------
0039: FFFFFFFF	      .org ROM_BASE+0x66
003D: FF...   	
0066:         	nmi_vector
0066: 76      	      halt
              	
0067: FFFFFFFF	      .org VECTOR_INT_PG<<8
006B: FF...   	
0100:         	int_vector_table
0100: 0013    	      .dw   ctc_ch0_isr
0102: 8013    	      .dw   ctc_ch1_isr
0104: 0014    	      .dw   ctc_ch2_isr
0106: 8014    	      .dw   ctc_ch3_isr
              	
              	
              	;---------------------------------------------------------------------
              	;     Z80 Processor Test                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Verify Z80 flags, registers (except IX/IY) and conditional     :
              	;     jumps, including all shadow register pairs.                    :
              	;                                                                    :
              	;     Adapted from IBM 5150 BIOS.                                    :
              	;---------------------------------------------------------------------
0108: FFFFFFFF	      .align 0x100
010C: FF...   	
0200:         	proc_test
              	#local
0200: F3      	      di                            ; Ensure interrupts disabled
              	
              	;---- First tests for normal flags register
0201:         	next_regs
0201: AF      	      xor   A, A
0202: 387E    	      jr    C, proc_test_err        ; Carry should be clear
0204: E28202  	      jp    PO, proc_test_err       ; Parity should be even
0207: 2079    	      jr    NZ, proc_test_err       ; Result should be zero
0209: FA8202  	      jp    M, proc_test_err        ; Result should be positive
              	
020C: D601    	      sub   A, 1
020E: 3072    	      jr    NC, proc_test_err       ; Carry should be set
0210: EA8202  	      jp    PE, proc_test_err       ; Parity should be odd
0213: 286D    	      jr    Z, proc_test_err        ; Result should be non-zero
0215: F28202  	      jp    P, proc_test_err        ; Result should be negative
              	
0218: 3E01    	      ld    A, 0x01
021A: CB3F    	      srl   A
021C: 3064    	      jr    NC, proc_test_err       ; Carry should be set
021E: 2062    	      jr    NZ, proc_test_err       ; Result should be zero
              	
0220: CB17    	      rl    A
0222: 385E    	      jr    C, proc_test_err        ; Carry should be clear
0224: 285C    	      jr    Z, proc_test_err        ; Result should be non-zero
              	
              	;---- Repeat tests for shadow flags register
0226: 08      	      ex    AF, AF'
0227: AF      	      xor   A, A
0228: 3858    	      jr    C, proc_test_err        ; Carry should be clear
022A: E28202  	      jp    PO, proc_test_err       ; Parity should be even
022D: 2053    	      jr    NZ, proc_test_err       ; Result should be zero
022F: FA8202  	      jp    M, proc_test_err        ; Result should be positive
              	
0232: D601    	      sub   A, 1
0234: 304C    	      jr    NC, proc_test_err       ; Carry should be set
0236: EA8202  	      jp    PE, proc_test_err       ; Parity should be odd
0239: 2847    	      jr    Z, proc_test_err        ; Result should be non-zero
023B: F28202  	      jp    P, proc_test_err        ; Result should be negative
              	
023E: 3E01    	      ld    A, 0x01
0240: CB3F    	      srl   A
0242: 303E    	      jr    NC, proc_test_err       ; Carry should be set
0244: 203C    	      jr    NZ, proc_test_err       ; Result should be zero
              	
0246: CB17    	      rl    A
0248: 3838    	      jr    C, proc_test_err        ; Carry should be clear
024A: 2836    	      jr    Z, proc_test_err        ; Result should be non-zero
              	
              	;---- Load a test pattern through all registers
024C: 3EFF    	      ld    A, 0xFF                 ; Setup one's pattern in A
024E: 37      	      scf
              	
024F: ED47    	      ld    I, A                    ; Write pattern through all regs
0251: ED57    	      ld    A, I
              	
0253:         	write_pattern
0253: 6F      	      ld    L, A
0254: 65      	      ld    H, L
0255: 5C      	      ld    E, H
0256: 53      	      ld    D, E
0257: 4A      	      ld    C, D
0258: 41      	      ld    B, C
0259: 78      	      ld    A, B
025A: D9      	      exx
025B: 6F      	      ld    L, A
025C: 65      	      ld    H, L
025D: 5C      	      ld    E, H
025E: 53      	      ld    D, E
025F: 4A      	      ld    C, D
0260: 41      	      ld    B, C
0261: 3008    	      jr    NC, proc_test_done
0263: 08      	      ex    AF, AF'
0264: 78      	      ld    A, B
0265: EEFF    	      xor   A, 0xFF                 ; Pattern make it through all regs
0267: 2019    	      jr    NZ, proc_test_err       ; If no, go to error
0269: 18E8    	      jr    write_pattern
              	
026B:         	proc_test_done
026B: B7      	      or    A, A                    ; Resulting pattern is zero?
026C: C28202  	      jp    NZ, proc_test_err       ; If no, go to error
              	
026F: 310000  	      ld    SP, 0                   ; Test all zeroes in SP
0272: 39      	      add   HL, SP
0273: 7C      	      ld    A, H
0274: B5      	      or    A, L
0275: 200B    	      jr    NZ, proc_test_err
              	
0277: 31FFFF  	      ld    SP, 0xFFFF              ; Test all ones in SP
027A: 39      	      add   HL, SP
027B: 7C      	      ld    A, H
027C: AD      	      xor   A, L
027D: 2003    	      jr    NZ, proc_test_err
              	
027F: C38302  	      jp    mem_test
              	
0282:         	proc_test_err
0282: 76      	      halt                          ; Halt on error
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     RAM Test                                                       :
              	;                                                                    :
              	; Description                                                        :
              	;     Performs a read/write storage test on RAM address space as     :
              	;     defined by RAM_BASE and RAM_SZ variables.                      :
              	;                                                                    :
              	;     Writes a series of patterns (0xAA, 0x55, 0xFF, 0x01 and 0x00)  :
              	;     and reads them back to check for errors.                       :
              	;                                                                    :
              	;     !!! DESTROYS CONTENTS OF ENTIRE MEMORY BLOCK !!!               :
              	;---------------------------------------------------------------------
0283:         	mem_test
              	#local
0283: D9      	      exx
0284: 21A402  	      ld    HL, mem_test_patterns   ; Shadow HL holds ptr to patterns
0287: D9      	      exx
              	
0288: 0605    	      ld    B, 5                    ; B holds outer loop (pattern) ctr
              	
028A:         	mem_test_next
028A: 210060  	      ld    HL, RAM_BASE            ; Pointer to start of RAM
028D: 110020  	      ld    DE, RAM_SZ              ; Inner loop counter (size of RAM)
              	
0290: D9      	      exx
0291: 7E      	      ld    A, (HL)                 ; Get test pattern for this round
0292: 23      	      inc   HL                      ; Inc pointer to next test pattern
0293: D9      	      exx
              	
0294:         	mem_test_loop
0294: 77      	      ld    (HL), A                 ; Store pattern in memory
0295: AE      	      xor   A, (HL)                 ; XOR pattern out of memory
0296: 200B    	      jr    NZ, mem_test_err        ; If not zero, error
              	
0298: 23      	      inc   HL                      ; Inc pointer to next memory loc
0299: 1B      	      dec   DE                      ; Dec inner loop
              	
029A: 7A      	      ld    A, D                    ; Inner loop counter at zero?
029B: B3      	      or    A, E
029C: 20F6    	      jr    NZ, mem_test_loop       ; No if NZ, next memory loc
              	
029E: 10EA    	      djnz  mem_test_next           ; Loop for next pattern
              	
02A0: C30003  	      jp    init                    ; All tests complete, init
              	
02A3:         	mem_test_err
02A3: 76      	      halt                          ; Halt on error
              	
02A4: AA55FF01	mem_test_patterns       .dm   0xAA, 0x55, 0xFF, 0x01, 0
02A8: 00      	
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;                          APPLICATION CODE                          :
              	;---------------------------------------------------------------------
              	#data RAM
              	; Mutexes
6000: 00      	foreground_mtx          .db 0       ; Which task owns the foreground.
              	                                    ; The foreground task can read
              	                                    ; buttons and update display row
              	                                    ; data.
              	
              	; Semaphores
6001: 00      	clock_app_sem           .db 0
6002: 00      	configr_app_sem         .db 0
6003: 00      	clock_upd_req_sem       .db 0
6004: 00      	clock_upd_sem           .db 0
              	
6005: 00000000	      .align 0x10
6009: 00...   	
6010: 00000000	task_sched              .ds 16      ; Each byte corresponds to one app
6014: 00...   	
              	                                    ; or task. A non-zero value
              	                                    ; indicates the app/task is
              	                                    ; scheduled to run.
              	
              	; Display row/dot point buffers - keep each block contiguous!
              	      .align 0x8
6020: 00000000	display_row1            .ds 8       ; Working buffers.
6024: 00000000	
6028: 00000000	display_row2            .ds 8       ; Display rows will be refreshed
602C: 00000000	
6030: 00000000	display_row3            .ds 8       ; using the data held in these
6034: 00000000	
6038: 00      	display_dp1             .db 0       ; buffers.
6039: 00      	display_dp2             .db 0
603A: 00      	display_dp3             .db 0
              	
603B: 00000000	      .align 0x8
603F: 00      	
6040: 00000000	staging_row1            .ds 8       ; Staging buffers.
6044: 00000000	
6048: 00000000	staging_row2            .ds 8       ; New data to be displayed can be
604C: 00000000	
6050: 00000000	staging_row3            .ds 8       ; staged in these buffers, then
6054: 00000000	
6058: 00      	staging_dp1             .db 0       ; copied to the working buffers
6059: 00      	staging_dp2             .db 0       ; when ready for display.
605A: 00      	staging_dp3             .db 0
              	
              	#code ROM
02A9: FFFFFFFF	      .align 0x100
02AD: FF...   	
0300:         	init
              	
0300: 31007F  	      ld    SP, RAM_end             ; SP to top of RAM, below init'd
              	
0303: 010001  	      ld    BC, _INITIALIZER_size   ; Copy initialised RAM from ROM
0306: 11007F  	      ld    DE, _INITIALIZED
0309: 21005F  	      ld    HL, _INITIALIZER
030C: CD0015  	      call  memcpy
              	
030F: AF      	      xor   A, A
0310: D3DE    	      out   (DEBUG_PORT), A         ; Clear debug port display
              	
              	      ; Zeroise RAM, -2 to save return addr on stack
0312: 01FE1E  	      ld    BC, RAM_size-2
0315: 210060  	      ld    HL, RAM_BASE
0318: CD4015  	      call  memset
              	
              	;---- Configure CTC channels
              	
              	      ; Configures CTC interrupt vector
031B: AF      	      xor   A, A
031C: D300    	      out   (CTC_CH0), A
              	
              	      ; Configures CTC Ch 1 - ~1ms delay for display refresh
031E: 3EA5    	      ld    A, CTC_CH1_CFG
0320: D301    	      out   (CTC_CH1), A
0322: 3E17    	      ld    A, CTC_CH1_TCONST
0324: D301    	      out   (CTC_CH1), A
              	
              	      ; Configures CTC Ch 2 - ~10ms delay for scheduling various tasks
0326: 3EA5    	      ld    A, CTC_CH2_CFG
0328: D302    	      out   (CTC_CH2), A
032A: 3EEA    	      ld    A, CTC_CH2_TCONST
032C: D302    	      out   (CTC_CH2), A
              	
              	      ; Configures CTC Ch 3 as downcounter for RTC interrupt
032E: 3EC5    	      ld    A, CTC_CH3_CFG
0330: D303    	      out   (CTC_CH3), A
0332: 3E01    	      ld    A, CTC_CH3_TCONST
0334: D303    	      out   (CTC_CH3), A
              	
              	;---- Configure the RTC
0336: 3E00    	      ld    A, RTC_RATES_CFG        ; WD and periodic int rates
0338: D31B    	      out   (RTC_RATES), A
033A: 3E08    	      ld    A, RTC_INTS_CFG         ; Interrupt enables
033C: D31C    	      out   (RTC_INTS), A
033E: 3E06    	      ld    A, RTC_CTRL_CFG         ; Control flags
0340: D31E    	      out   (RTC_CTRL), A
              	
0342: AF      	      xor   A, A                    ; Configure alarm to occur each
0343: D311    	      out    (RTC_SEC_ALM), A       ; minute at 0 seconds.
0345: 3EC0    	      ld    A, RTC_ALM_CFG
0347: D313    	      out    (RTC_MIN_ALM), A
0349: D315    	      out    (RTC_HRS_ALM), A
034B: D317    	      out    (RTC_DAY_ALM), A
              	
034D: DB1D    	      in    A, (RTC_FLAGS)          ; Read RTC flags to clear them
              	
              	      ; Configure and enable Z80 vectored interrupts
034F: ED5E    	      im    2
0351: 3E01    	      ld    A, VECTOR_INT_PG
0353: ED47    	      ld    I, A
0355: FB      	      ei
              	
              	;---- Schedule applications to run
              	      schedule_task APP_CLOCK
0356: E5      	      push  HL
              	
0357: 211360  	      ld    HL, task_sched+APP_CLOCK
035A: 3603    	      ld    (HL), APP_CLOCK
              	
035C: E1      	      pop   HL
              	      schedule_task APP_CONFIGR
035D: E5      	      push  HL
              	
035E: 211460  	      ld    HL, task_sched+APP_CONFIGR
0361: 3604    	      ld    (HL), APP_CONFIGR
              	
0363: E1      	      pop   HL
              	
0364: C30004  	      jp    main_loop
              	
              	;---- Main application loop
              	;     Runs all scheduled tasks and applications.
0367: FFFFFFFF	      .align 0x100
036B: FF...   	
0400:         	main_loop
              	      ; Inputs
              	      run_task TASK_BUTTON_RD, button_rd_task
0400: 211160  	      ld    HL, task_sched+TASK_BUTTON_RD
0403: 7E      	      ld    A, (HL)
0404: B7      	      or    A, A
              	
0405: C40005  	      call  NZ, button_rd_task
              	
              	      ; Applications
              	      run_task APP_CLOCK, clock_app
0408: 211360  	      ld    HL, task_sched+APP_CLOCK
040B: 7E      	      ld    A, (HL)
040C: B7      	      or    A, A
              	
040D: C40008  	      call  NZ, clock_app
              	      run_task APP_CONFIGR, configr_app
0410: 211460  	      ld    HL, task_sched+APP_CONFIGR
0413: 7E      	      ld    A, (HL)
0414: B7      	      or    A, A
              	
0415: C4000D  	      call  NZ, configr_app
              	
              	      ; Outputs
              	      run_task TASK_DISPLAY, display_task
0418: 211560  	      ld    HL, task_sched+TASK_DISPLAY
041B: 7E      	      ld    A, (HL)
041C: B7      	      or    A, A
              	
041D: C40006  	      call  NZ, display_task
              	
              	      ; Other
              	      run_task TASK_WD_POKE, wd_poke_task
0420: 211260  	      ld    HL, task_sched+TASK_WD_POKE
0423: 7E      	      ld    A, (HL)
0424: B7      	      or    A, A
              	
0425: C40007  	      call  NZ, wd_poke_task
              	
0428: 76      	      halt
              	
0429: 18D5    	      jr    main_loop
              	
              	
              	;---------------------------------------------------------------------
              	;     Button Reader Task                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Read in the state of any pressed buttons to provide input to   :
              	;     any task that is interested.                                   :
              	;                                                                    :
              	;     Reads the button input register, masks out invalid buttons,    :
              	;     masks out button presses that have already been acknowledged,  :
              	;     debounces new button presses, and sets flags for newly         :
              	;     registered button presses.                                     :
              	;---------------------------------------------------------------------
              	#data RAM
605B: 00      	btn_valid               .db 0       ; Valid button mask
605C: 00      	btn_ack                 .db 0       ; Acknowledged button presses
605D: 00      	btn_state               .db 0       ; Serviceable buttons!
605E: 00      	btn_debounce            .db 0       ; Buttons presses being debounced
605F: 00      	btn_flags               .db 0       ; Button reader task flags
              	
              	#code ROM
042B: FFFFFFFF	      .align 0x100
042F: FF...   	
0500:         	button_rd_task
              	#local
0500: 3E01    	      ld    A, 0x01                 ; For extra button debouncing,
0502: 215F60  	      ld    HL, btn_flags           ; only run task every other time.
0505: AE      	      xor   A, (HL)                 ; Invert bit 0 of flags and test
0506: CB46    	      bit   0, (HL)
0508: 201B    	      jr    NZ, done                ; If bit is 0, run task
              	
050A: DB08    	      in    A, (BTN_REG)            ; Read in button state
050C: 2F      	      cpl                           ; Buttons pull down, make positive
              	
050D: 215B60  	      ld    HL, btn_valid           ; Mask out invalid buttons
0510: A6      	      and   A, (HL)
0511: 47      	      ld    B, A                    ; B is valid buttons only
              	
0512: 215C60  	      ld    HL, btn_ack             ; Make mask to hide serviced btns
0515: A6      	      and   A, (HL)
0516: 4F      	      ld    C, A                    ; C is mask
              	
0517: A8      	      xor   A, B                    ; Remove svcd btns, leave unsvcd
0518: 47      	      ld    B, A                    ; B is now unserviced buttons only
0519: B1      	      or    A, C                    ; Make mask to clear old ACKs
              	
051A: A6      	      and   A, (HL)                 ; Clear ACKs from released btns
051B: 77      	      ld    (HL), A
              	
051C: 215E60  	      ld    HL, btn_debounce        ; De-bounce button presses
051F: 7E      	      ld    A, (HL)
0520: A0      	      and   A, B
0521: 325D60  	      ld    (btn_state), A
0524: 70      	      ld    (HL), B
              	
0525:         	done
              	      deschedule_task TASK_BUTTON_RD
0525: E5      	      push  HL
              	
0526: 211160  	      ld    HL, task_sched+TASK_BUTTON_RD
0529: 3600    	      ld    (HL), 0
              	
052B: E1      	      pop   HL
              	
052C: C9      	      ret
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     Display update task                                            :
              	;                                                                    :
              	; Description                                                        :
              	;     Applications write only to the staging display buffers, but    :
              	;     the ISR that updates the physical displays takes its input     :
              	;     from the working display buffers.                              :
              	;                                                                    :
              	;     This task implements a display update effect which mimicks the :
              	;     displays of the DSKY, part of the Apollo Guidance Computer,    :
              	;     whereby the contents of the displays appear to transition      :
              	;     slowly.                                                        :
              	;---------------------------------------------------------------------
              	#data RAM
6060: 00      	display_ctr             .db 0       ; Counter for current character
6061: 00      	display_status          .db 0       ; Display updater status register
6062: 00      	display_syncd           .db 0       ; If zero, working == staging
6063: 00      	display_effect          .db 0       ; Display update effect:
              	                                    ; LSb 0: DSKY effect
              	                                    ; Anything else, no effect
              	
              	#code ROM
052D: FFFFFFFF	      .align 0x100
0531: FF...   	
0600:         	display_task
              	#local
0600: 3A6360  	      ld    A, (display_effect)
0603: CB47    	      bit   0, A
0605: 200E    	      jr    NZ, dsky_effect
              	
              	      ; No effect - copy the staging buffers to working buffers
0607: 011B00  	      ld    BC, 27
060A: 112060  	      ld    DE, display_row1
060D: 214060  	      ld    HL, staging_row1
0610: CD0015  	      call  memcpy
              	
0613: 1829    	      jr    done
              	
0615:         	dsky_effect
0615: 216160  	      ld    HL, display_status      ; Skip every other iteration
0618: 7E      	      ld    A, (HL)
0619: EE01    	      xor   A, 0x01
061B: 77      	      ld    (HL), A
061C: CB47    	      bit   0, A
061E: 201E    	      jr    NZ, done
              	
0620: AF      	      xor   A, A
0621: 57      	      ld    D, A
              	
0622: 3A6060  	      ld    A, (display_ctr)        ; Load display position counter
0625: 5F      	      ld    E, A                    ; DE is offset
              	
0626: 214060  	      ld    HL, staging_row1        ; Source pointer
0629: 19      	      add   HL, DE
062A: E5      	      push  HL                      ; Save for later
              	
062B: 212060  	      ld    HL, display_row1        ; Destination pointer
062E: 19      	      add   HL, DE
062F: EB      	      ex    DE, HL                  ; Restore source pointer
0630: E1      	      pop   HL
              	
0631: 7E      	      ld    A, (HL)
0632: 12      	      ld    (DE), A
              	
0633: 216060  	      ld    HL, display_ctr         ; Increment display position ctr
0636: 34      	      inc   (HL)
0637: 7E      	      ld    A, (HL)
0638: FE1B    	      cp    A, 27                   ; Overflowed to 27?
063A: 2002    	      jr    NZ, done
              	
063C: AF      	      xor   A, A                    ; Yes, reset back to zero
063D: 77      	      ld    (HL), A
              	
063E:         	done
              	      deschedule_task TASK_DISPLAY
063E: E5      	      push  HL
              	
063F: 211560  	      ld    HL, task_sched+TASK_DISPLAY
0642: 3600    	      ld    (HL), 0
              	
0644: E1      	      pop   HL
              	
0645: C9      	      ret
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     Watchdog Poke Task                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     The watchdog, contained in the RTC, should be poked every so   :
              	;     often to prevent it from asserting the RST/ signal and causing :
              	;     a processor reset.                                             :
              	;                                                                    :
              	;     This is achieved very simply by issuing an IO read or write to :
              	;     the watchdog peripheral address.                               :
              	;---------------------------------------------------------------------
              	#data RAM
              	#code ROM
0646: FFFFFFFF	      .align 0x100
064A: FF...   	
0700:         	wd_poke_task
              	#local
0700: D304    	      out   (WDT_POKE), A
              	
              	      deschedule_task TASK_WD_POKE
0702: E5      	      push  HL
              	
0703: 211260  	      ld    HL, task_sched+TASK_WD_POKE
0706: 3600    	      ld    (HL), 0
              	
0708: E1      	      pop   HL
              	
0709: C9      	      ret
              	#endlocal
              	
              	
              	#include "clock_app.s"
              	;---------------------------------------------------------------------
              	;     Clock Application                                              :
              	;                                                                    :
              	; Description                                                        :
              	;     This task is scheduled at boot and should not be descheduled.  :
              	;                                                                    :
              	;     This task runs as an application of sorts. It reads the        :
              	;     registers of the RTC to get UTC time, and then for each of the :
              	;     configured timezones (according to DIP switch settings),       :
              	;     calculates the appropriate offsets from UTC to show those      :
              	;     timezones on each row of the display.                          :
              	;                                                                    :
              	;     The task self determines if it should run, signalled by the    :
              	;     foreground mutex either being null or owned.                   :
              	;---------------------------------------------------------------------
              	
              	; State machine states
0000:         	CLOCK_APP_START         .equ  0
0001:         	CLOCK_UPDATE            .equ  0x01
0002:         	CLOCK_IDLE              .equ  0x02
0003:         	CLOCK_EXIT              .equ  0x03
              	
              	#data RAM
6064: 00      	clock_state             .db 0       ; State machine value
              	
6065: 00      	clock_tz1_sw            .db 0       ; Timezone switch settings
6066: 00      	clock_tz2_sw            .db 0
6067: 00      	clock_tz3_sw            .db 0
              	
6068: 00      	clock_rtc_min           .db 0       ; Copy of RTC registers
6069: 00      	clock_rtc_hrs           .db 0
606A: 00      	clock_rtc_day           .db 0
606B: 00      	clock_rtc_dow           .db 0
606C: 00      	clock_rtc_mon           .db 0
606D: 00      	clock_rtc_year          .db 0
              	
606E: 00      	clock_tz_min            .db 0       ; These variables hold the values
606F: 00      	clock_tz_hrs            .db 0       ; being computed for the current
6070: 00      	clock_tz_day            .db 0       ; row of the display.
6071: 00      	clock_tz_dow            .db 0
6072: 00      	clock_tz_mon            .db 0
6073: 00      	clock_tz_days_in_mon    .db 0       ; Days in month for this row
              	
6074: 00      	clock_row               .db 0       ; Display row being computed
              	
6075: 0000    	tz_sw_ptr               .dw 0
6077: 0000    	tz_rom_ptr              .dw 0       ; Pointer to TZ ROM entry
6079: 0000    	row_buf_ptr             .dw 0       ; Pointer to display row buffer
607B: 0000    	day_array_ptr           .dw 0       ; Pointer to array of days in mon
              	
607D: 00      	row_carrys              .db 0       ; Keep track of carrys:
              	                                    ; 0: Minutes
              	                                    ; 1: Hours (affects day)
              	                                    ; 2: Days (affects month)
              	                                    ; 3: Month (affects year)
              	
607E: 00      	row_borrows             .db 0       ; Keep track of borrows:
              	                                    ; 0: Minutes
              	                                    ; 1: Hours (affects day)
              	                                    ; 2: Days (affects month)
              	                                    ; 3: Month (affects year)
              	
607F: 00      	row_flags               .db 0       ; Flags used during row work:
              	                                    ; 0: DST hour match
              	                                    ; 1: DST day match
              	                                    ; 2: DST month match
              	                                    ; 3:
              	                                    ; 4:
              	                                    ; 5:
              	                                    ; 6:
              	                                    ; 7: Apply DST
              	
              	#data _INITIALIZED
              	#code _INITIALIZER
              	
              	#code ROM
070A: FFFFFFFF	      .align 0x100
070E: FF...   	
0800:         	clock_app
              	      ; Try to lock the foreground mutex if it is available, or return
              	      mtx_trylock foreground_mtx, APP_CLOCK
0800: E5      	      push  HL
              	
0801: ED57    	      ld    A, I                    ; IFF2 to P/V flag
0803: F5      	      push  AF                      ; Save flags
0804: F3      	      di                            ; Ensure interrupts disabled
              	
0805: 210060  	      ld    HL, foreground_mtx
0808: 7E      	      ld    A, (HL)                 ; Check current mutex owner
0809: B7      	      or    A, A
080A: 2807    	      jr    Z, $+9                  ; If zero, acquire it
              	
080C: FE03    	      cp    A, APP_CLOCK            ; If not zero, do we own it?
080E: 2806    	      jr    Z, $+8                  ; Yes if Z, return mutex value
              	
0810: AF      	      xor   A, A                    ; No otherwise, return 0
0811: 1803    	      jr    $+5                     ; Go to done
              	
0813: 3E03    	      ld    A, APP_CLOCK            ; Acquire by loading task_num into
0815: 77      	      ld    (HL), A                 ; mutex
              	
0816: E1      	      pop   HL                      ; F into L
0817: CB55    	      bit   2, L                    ; Test IFF2 flag
0819: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
081B: FB      	      ei                            ; Re-enable interrupts
              	
081C: E1      	      pop   HL                      ; Done
              	
081D: B7      	      or    A, A                    ; Set Z flag according to A
081E: C8      	      ret   Z
              	
              	      ; Check semaphore to determine if clock app should run
              	      sem_trywait clock_app_sem
081F: E5      	      push  HL
              	
0820: ED57    	      ld    A, I                    ; IFF2 to P/V flag
0822: F5      	      push  AF                      ; Save flags
0823: F3      	      di                            ; Ensure interrupts disabled
              	
0824: 210160  	      ld    HL, clock_app_sem
0827: 7E      	      ld    A, (HL)                 ; Load semaphore value for return
0828: B7      	      or    A, A                    ; Semaphore value greater than 0?
0829: 2801    	      jr    Z, $+3                  ; If Z, return 0, go to done
              	
082B: 35      	      dec   (HL)                    ; Decrement semaphore
              	
082C: E1      	      pop   HL                      ; F into L
082D: CB55    	      bit   2, L                    ; Test IFF2 flag
082F: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
0831: FB      	      ei                            ; Re-enable interrupts
              	
0832: E1      	      pop   HL                      ; Done
              	
0833: B7      	      or    A, A                    ; Set Z flag according to A
0834: C8      	      ret   Z
              	
              	      ; Get jump table entry and jump to state
0835: 3A6460  	      ld    A, (clock_state)
0838: B7      	      or    A, A
0839: 2812    	      jr    Z, clock_app_start
              	
              	      get_jp_table_entry clock_jp_tbl
083B: D5      	      push DE
              	
083C: 1600    	      ld    D, 0                    ; DE becomes offset by doubling A
083E: 5F      	      ld    E, A
083F: CB23    	      sla   E
0841: CB12    	      rl    D
              	
0843: 21240C  	      ld    HL, clock_jp_tbl              ; HL = pointer to jump table
0846: 19      	      add   HL, DE                  ; Add offset to pointer
              	
0847: 5E      	      ld    E, (HL)                 ; Load HL pair into DE
0848: 23      	      inc   HL
0849: 56      	      ld    D, (HL)
              	
084A: EB      	      ex    DE, HL                  ; DE becomes HL for return
              	
084B: D1      	      pop   DE
084C: E9      	      jp    (HL)
              	
              	;---- State 00 -------------------------------------------------------
              	;     This is where the app starts from fresh.
084D:         	clock_app_start
084D: 3E00    	      ld    A, 0                    ; Blank display buffers
084F: 011B00  	      ld    BC, 27
0852: 214060  	      ld    HL, staging_row1
0855: CD4015  	      call  memset
              	
0858: AF      	      xor   A, A                    ; Reset clock semaphores
0859: 3A0360  	      ld    A, (clock_upd_req_sem)
085C: 3A0460  	      ld    A, (clock_upd_sem)
              	
085F: 3E01    	      ld    A, 0x01                 ; Use DSKY display update effect
0861: 326360  	      ld    (display_effect), A
              	
              	      set_valid_btn_mask BTN_ESC
0864: F5      	      push  AF
0865: C5      	      push  BC
              	
0866: 3A5D60  	      ld    A, (btn_state)          ; Ack all un-ack'd buttons by
0869: 47      	      ld    B, A                    ; OR'ing them with all ack'd
086A: 3A5C60  	      ld    A, (btn_ack)            ; buttons.
086D: B0      	      or    A, B
086E: 325C60  	      ld    (btn_ack), A
              	
0871: 3E08    	      ld    A, BTN_ESC
0873: 325B60  	      ld    (btn_valid), A          ; Load new mask
              	
0876: C1      	      pop   BC
0877: F1      	      pop   AF
              	      set_state clock_state, CLOCK_UPDATE
0878: F5      	      push  AF
              	
0879: 3E01    	      ld    A, CLOCK_UPDATE
087B: 326460  	      ld    (clock_state), A
              	
087E: F1      	      pop   AF
              	
087F: C9      	      ret
              	
              	;---- State 01 -------------------------------------------------------
              	;     This is the state in which the clock display is updated with the
              	;     current time.
              	;
              	;     This state is always executed when the clock app starts, to fill
              	;     the display with the configured times, and then once per minute
              	;     as signalled by the clock_upd_sem semaphore containing a
              	;     non-zero value.
              	;
              	;     The clock_upd_req_sem semaphore is set at the end of this state
              	;     to request that the clock_upd_sem semaphore be incremented by
              	;     the RTC per-minute ISR.
0880:         	clock_update
              	#local
              	;---- Reset counters, pointers etc as required for a fresh run
0880: AF      	      xor   A, A
0881: 327460  	      ld    (clock_row), A          ; Display row starts at 0
              	
0884: 216560  	      ld    HL, clock_tz1_sw        ; Timezone switch pointer
0887: 227560  	      ld    (tz_sw_ptr), HL
              	
088A: 214060  	      ld    HL, staging_row1        ; Display row buffer pointer
088D: 227960  	      ld    (row_buf_ptr), HL
              	
              	;---- Read in timezone switch settings
0890: 0E09    	      ld    C, TZ_SW1_REG
0892: 216560  	      ld    HL, clock_tz1_sw
              	
0895: EDA2    	      ini                           ; Timezone 1 switch
0897: 0C      	      inc   C
0898: EDA2    	      ini                           ; Timezone 2 switch
089A: 0C      	      inc   C
089B: EDA2    	      ini                           ; Timezone 3 switch
              	
              	;---- Read in time from RTC
089D: 3E0E    	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
089F: D31E    	      out   (RTC_CTRL), A
              	
08A1: 0E12    	      ld    C, RTC_MIN
08A3: 216860  	      ld    HL, clock_rtc_min
              	
08A6: EDA2    	      ini                           ; Minutes register
08A8: 0C      	      inc   C                       ; Inc twice to skip alarm reg
08A9: 0C      	      inc   C
08AA: EDA2    	      ini                           ; Hours register
08AC: 0C      	      inc   C                       ; Inc twice to skip alarm reg
08AD: 0C      	      inc   C
08AE: EDA2    	      ini                           ; Day register
08B0: 0C      	      inc   C                       ; Inc twice to skip alarm reg
08B1: 0C      	      inc   C
08B2: EDA2    	      ini                           ; Day of week register
08B4: 0C      	      inc   C
08B5: EDA2    	      ini                           ; Month register
08B7: 0C      	      inc   C
08B8: EDA2    	      ini                           ; Year register
              	
08BA: 3E06    	      ld    A, RTC_CTRL_CFG
08BC: D31E    	      out   (RTC_CTRL), A
              	
              	
              	;---- Main loop for computing display rows
08BE:         	row_loop
08BE: AF      	      xor   A, A                    ; Reset row borrows/carrys/flags
08BF: 327F60  	      ld    (row_flags), A
              	
              	      ; Calculate pointer to TZ ROM entry for current row
08C2: 2A7560  	      ld    HL, (tz_sw_ptr)         ; Get value of timezone switches
08C5: 7E      	      ld    A, (HL)                 ; for this row
08C6: 2F      	      cpl                           ; Switches pull down, so invert
08C7: E67F    	      and   A, 0x7F                 ; MSb is reserved
              	
08C9: 2100C0  	      ld    HL, TZ_ROM_BASE         ; Compute pointer to TZ ROM entry.
08CC: 5F      	      ld    E, A                    ; HL is base of TZ ROM, DE will be
08CD: AF      	      xor   A, A                    ; offset.
              	
08CE: CB23    	      sla   E                       ; Each entry is 32 bytes, so shift
08D0: 17      	      rla                           ; left 5 bits
08D1: CB23    	      sla   E
08D3: 17      	      rla
08D4: CB23    	      sla   E
08D6: 17      	      rla
08D7: CB23    	      sla   E
08D9: 17      	      rla
08DA: CB23    	      sla   E
08DC: 17      	      rla
              	
08DD: 57      	      ld    D, A
08DE: 19      	      add   HL, DE
              	
08DF: 227760  	      ld    (tz_rom_ptr), HL        ; Save pointer, and xfer to IX
08E2: E5      	      push  HL
08E3: DDE1    	      pop   IX
              	
              	      ; Process this timezone setting?
08E5: DD7E00  	      ld    A, (IX+0)               ; Entry contains data?
08E8: FEFF    	      cp    A, 0xFF
08EA: CAAE0B  	      jp    Z, row_loop_done        ; No if 0xFF, skip row
              	
08ED: CB47    	      bit   0, A                    ; If bit 0 is set, this is a TZ
08EF: CAAE0B  	      jp    Z, row_loop_done        ; Skip if not a TZ
              	
              	      ; Take a copy of all of the RTC time registers
08F2: 216860  	      ld    HL, clock_rtc_min
08F5: 116E60  	      ld    DE, clock_tz_min
08F8: 010500  	      ld    BC, 5
08FB: CD0015  	      call  memcpy
              	
              	
              	      ; Execution can be diverted to this point from later in the
              	      ; program, if all of the DST match flags have been set. This
              	      ; causes an additional hour to be added onto the time that was
              	      ; computed during the first pass, which then also compensates
              	      ; for any additional hour/day/month carrys that may occurr as a
              	      ; result.
08FE:         	begin_computation
08FE: AF      	      xor   A, A                    ; Reset row borrows/carrys/flags.
08FF: 327D60  	      ld    (row_carrys), A         ; Do that here so that bor/car
0902: 327E60  	      ld    (row_borrows), A        ; from pre-DST computation do not
              	                                    ; apply twice.
              	
              	
              	;---- Compute minutes for current timezone ---------------------------
              	      ; Functionality not implemented at this time.
0905: 00      	      nop
              	
              	
              	;---- Compute hours for current timezone -----------------------------
0906: 3A6F60  	      ld    A, (clock_tz_hrs)       ; Load hours BCD into A
0909: E67F    	      and   A, 0x7F                 ; Remove AM/PM bit (working in
              	                                    ; 24hr time)
              	
090B: 0E24    	      ld    C, 0x24
              	
090D: DD4606  	      ld    B, (IX+6)               ; Load hrs offset from TZ ROM
              	
0910: 217F60  	      ld    HL, row_flags           ; If the "Apply DST" flag is set,
0913: CB7E    	      bit   7, (HL)                 ; replace offset with 1 to move
0915: 2802    	      jr    Z, $+4                  ; clock forward.
0917: 0601    	      ld    B, 0x01
              	
0919: 80      	      add   A, B                    ; Add offset to hours
091A: 27      	      daa
              	
091B: F22E09  	      jp    P, no_hrs_borrow        ; If positive, check for overflow
              	
091E: 81      	      add   A, C                    ; Result was negative, so add 24
091F: 27      	      daa
0920: 217E60  	      ld    HL, row_borrows         ; Record a borrow (-1 day)
0923: CBCE    	      set   1, (HL)
              	
0925: F5      	      push  AF
0926: 215060  	      ld    HL, staging_row3
0929: 3642    	      ld    (HL), 'B'
092B: F1      	      pop   AF
              	
092C: 180A    	      jr    no_hrs_carry
              	
092E:         	no_hrs_borrow
092E: B9      	      cp    A, C                    ; Has result overflowed hour 24?
092F: 3807    	      jr    C, no_hrs_carry         ; If C, result < 24
              	
0931: 91      	      sub   A, C                    ; Result overflowed, sub 24
0932: 27      	      daa
0933: 217D60  	      ld    HL, row_carrys          ; Record a carry (+1 day)
0936: CBCE    	      set   1, (HL)
              	
0938:         	no_hrs_carry
0938: 326F60  	      ld    (clock_tz_hrs), A       ; Store hours back
              	
              	
              	;---- Compute day of month -------------------------------------------
              	      ; First check for leap year
093B: 21300C  	      ld    HL, days_common_year    ; Default to common year array
              	
093E: 3A6D60  	      ld    A, (clock_rtc_year)     ; Load year BCD into A
0941: E603    	      and   0x03
0943: 2003    	      jr    NZ, not_leap_year       ; If zero, in a leap year
              	
0945: 21400C  	      ld    HL, days_leap_year      ; Override to leap year array
              	
0948:         	not_leap_year
              	      ; Load number of days in month from array
0948: 3A7260  	      ld    A, (clock_tz_mon)       ; Load month BCD into A
094B: CDA70C  	      call  bcd_to_dec
094E: 3D      	      dec   A                       ; Sub 1 for offset into array
094F: 1600    	      ld    D, 0                    ; DE becomes array offset
0951: 5F      	      ld    E, A
0952: 19      	      add   HL, DE                  ; Add offset to pointer
0953: 46      	      ld    B, (HL)                 ; B is number of days in month
0954: 227B60  	      ld    (day_array_ptr), HL     ; Save pointer
              	
              	      ; Store the number of days in the month for use later on
0957: 217360  	      ld    HL, clock_tz_days_in_mon
095A: 70      	      ld    (HL), B
              	
              	      ; Apply borrow/carry to day of month
095B: 3A7060  	      ld    A, (clock_tz_day)       ; Load day BCD into A
              	
095E: 217E60  	      ld    HL, row_borrows         ; Test hrs borrow bit
0961: CB4E    	      bit   1, (HL)
              	
0963: 2813    	      jr    Z, no_day_borrow        ; If Z, no borrow
              	
0965: 217160  	      ld    HL, clock_tz_dow        ; Decrement the day-of-week
0968: 35      	      dec   (HL)
0969: 2002    	      jr    NZ, $+4
096B: 3607    	      ld    (HL), 0x07
              	
096D: 3D      	      dec   A                       ; Hrs borrow, dec to prev day
096E: 27      	      daa
              	
096F: 202A    	      jr    NZ, day_continue        ; If day is 0, record borrow
              	
              	      ; Day is left at zero and will be corrected when calculating new
              	      ; month from borrow.
0971: 217E60  	      ld    HL, row_borrows         ; Record a borrow (-1 month)
0974: CBD6    	      set   2, (HL)
              	
0976: 1823    	      jr    day_continue
              	
0978:         	no_day_borrow
0978: 217D60  	      ld    HL, row_carrys          ; Test hrs carry bit
097B: CB4E    	      bit   1, (HL)
              	
097D: 281C    	      jr    Z, day_continue         ; If Z, no carry
              	
097F: 4F      	      ld    C, A                    ; Save A while incrementing DOW
              	
0980: 217160  	      ld    HL, clock_tz_dow        ; Increment the day-of-week
0983: 7E      	      ld    A, (HL)
0984: 3C      	      inc   A
0985: E607    	      and   0x07
0987: 2002    	      jr    NZ, $+4                 ; If NZ, still in valid range 1..7
0989: 3E01    	      ld    A, 0x01                 ; Inc reached zero, reset to 1
098B: 77      	      ld    (HL), A
              	
098C: 79      	      ld    A, C                    ; Restore A
098D: 3C      	      inc   A                       ; Hrs carry, inc to next day
098E: 27      	      daa
              	
098F: B8      	      cp    A, B                    ; Overflowed num of days in month?
0990: 3809    	      jr    C, day_continue         ; C if A < B
0992: 2807    	      jr    Z, day_continue         ; Z if A == B
              	
0994: 3E01    	      ld    A, 0x01                 ; On carry, day can be set to 1
              	
0996: 217D60  	      ld    HL, row_carrys          ; Record a carry (+1 month)
0999: CBD6    	      set   2, (HL)
              	
099B:         	day_continue
099B: 327060  	      ld    (clock_tz_day), A       ; Store day back
              	
              	
              	;---- Compute month --------------------------------------------------
099E: 3A7260  	      ld    A, (clock_tz_mon)       ; Load month BCD into A
              	
09A1: 217E60  	      ld    HL, row_borrows         ; Test day borrow bit
09A4: CB56    	      bit   2, (HL)
              	
09A6: 2821    	      jr    Z, no_mon_borrow        ; If Z, no borrow
              	
              	      ; If a day borrow occurred, the month number needs to be
              	      ; decremented, and the day reset to the last day of the new
              	      ; month. So, fix month number first...
              	
09A8: 3D      	      dec   A                       ; Decrement month number
09A9: 27      	      daa
              	
09AA: 2002    	      jr    NZ, mon_borrow_fix_day  ; Did it hit zero?
              	
09AC: 3E12    	      ld    A, 0x12                 ; Reset back to month 12
              	
09AE:         	mon_borrow_fix_day
09AE: 327260  	      ld    (clock_tz_mon), A       ; Store month back now
              	
              	      ; Now use the new month number to apply the correct day number
              	
09B1: CDA70C  	      call  bcd_to_dec
09B4: 3D      	      dec   A                       ; Sub 1 for offset into array
09B5: 1600    	      ld    D, 0                    ; DE becomes array offset
09B7: 5F      	      ld    E, A
              	
09B8: 2A7B60  	      ld    HL, (day_array_ptr)
09BB: 7D      	      ld    A, L
09BC: E6F0    	      and   A, 0xF0
09BE: 6F      	      ld    L, A
              	
09BF: 19      	      add   HL, DE                  ; Add offset to pointer
09C0: 7E      	      ld    A, (HL)
09C1: 327060  	      ld    (clock_tz_day), A       ; Save corrected day number
09C4: 327360  	      ld    (clock_tz_days_in_mon), A
              	
09C7: 1824    	      jr    no_mon_carry
              	
09C9:         	no_mon_borrow
09C9: 217D60  	      ld    HL, row_carrys          ; Test day carry bit
09CC: CB56    	      bit   2, (HL)
              	
09CE: 281D    	      jr    Z, no_mon_carry         ; If Z, no carry
              	
09D0: 3C      	      inc   A                       ; Day carry, inc to next month
09D1: 27      	      daa
09D2: 327260  	      ld    (clock_tz_mon), A       ; Store month back now
              	
09D5: FE13    	      cp    A, 0x13                 ; Overflowed to 13?
09D7: 2014    	      jr    NZ, no_mon_carry        ; No if NZ, all done
              	
09D9: 3E01    	      ld    A, 0x01                 ; On overflow, reset to month 1
09DB: 327260  	      ld    (clock_tz_mon), A       ; Store month back now
              	
              	      ; Now need to load and store the number of days in this month
09DE: 2A7B60  	      ld    HL, (day_array_ptr)
09E1: CDA70C  	      call  bcd_to_dec
09E4: 3D      	      dec   A
09E5: 1600    	      ld    D, 0
09E7: 5F      	      ld    E, A
09E8: 19      	      add   HL, DE
09E9: 7E      	      ld    A, (HL)
09EA: 327360  	      ld    (clock_tz_days_in_mon), A
              	
09ED:         	no_mon_carry
              	
09ED: 3A7F60  	      ld    A, (row_flags)          ; If the "Apply DST" flag is set,
09F0: CB7F    	      bit   7, A                    ; skip to display_row because it
09F2: C2F90A  	      jp    NZ, display_row         ; is not neccessary to recompute
              	                                    ; whether DST is in effect.
              	
              	      ; At this stage the correct time and date for the timezone has
              	      ; been computed, and now can determine if DST is in effect for
              	      ; this timezone.
              	
              	      ; First, does DST even apply in this timezone?
09F5: DD7E0A  	      ld    A, (IX+10)              ; Load DST start options
09F8: B7      	      or    A, A
09F9: CAF90A  	      jp    Z, display_row          ; DST does not apply if it doesnt
              	                                    ; start, show info on display row
              	
              	
              	;---- DST check #1: within the months that DST applies? --------------
              	      ;
              	      ; This is a definitive test to determine if DST SHOULD be in
              	      ; effect.
              	      ;
              	      ; To achieve this, first work out the order of the start and end
              	      ; months, e.g. if the end month is lower than the start month
              	      ; then they should be reversed, and then check if the current
              	      ; month falls within that range.
09FC: DD4607  	      ld    B, (IX+7)               ; Load start month from TZ ROM
09FF: DD4E0B  	      ld    C, (IX+11)              ; Load end month from TZ ROM
0A02: C5      	      push  BC                      ; Save these for later
              	
0A03: 78      	      ld    A, B
0A04: B9      	      cp    A, C
0A05: 3810    	      jr    C, dst_end_mon_higher
              	
              	      ; End month is lower than start month, add 12 to reverse order
0A07: 79      	      ld    A, C
0A08: 1612    	      ld    D, 0x12
0A0A: 82      	      add   A, D
0A0B: 27      	      daa
0A0C: 4F      	      ld    C, A
              	
0A0D: 3A7260  	      ld    A, (clock_tz_mon)       ; Must also offset current month,
0A10: B8      	      cp    A, B                    ; but only if less than the start
0A11: 3007    	      jr    NC, check1              ; month.
              	
0A13: 82      	      add   A, D
0A14: 27      	      daa
              	
0A15: 1803    	      jr    check1
              	
0A17:         	dst_end_mon_higher
0A17: 3A7260  	      ld    A, (clock_tz_mon)       ; Load current month unaffected
              	
0A1A:         	check1
0A1A: B8      	      cp    A, B
0A1B: 283B    	      jr    Z, check_start_cond     ; cur_mon == start_mon
0A1D: 380F    	      jr    C, check1_done          ; cur_mon < start_mon
              	
0A1F: B9      	      cp    A, C
0A20: CAA30A  	      jp    Z, check_end_cond       ; cur_mon == end_mon
0A23: 3009    	      jr    NC, check1_done         ; cur_mon > end_mon
              	
              	      ; At this point DST is definitively IN EFFECT
0A25: 3E07    	      ld    A, 0x07                 ; Set all match flags
0A27: 327F60  	      ld    (row_flags), A
0A2A: C1      	      pop   BC                      ; No longer needed
              	
0A2B: C3EA0A  	      jp    check_for_dst
              	
0A2E:         	check1_done
              	
              	
              	;---- DST check #2: outside the months that DST applies? -------------
              	      ;
              	      ; This is a definitive test to determine if DST SHOULD NOT be in
              	      ; effect.
              	      ;
              	      ; This is achieved in a similar way to the first check, except
              	      ; this time we reverse the order of start/end months if the
              	      ; start month is lower than the end month.
              	
0A2E: C1      	      pop   BC                      ; Restore original star/end months
0A2F: C5      	      push  BC                      ; Save them again
              	
0A30: 78      	      ld    A, B
0A31: B9      	      cp    A, C
0A32: 300F    	      jr    NC, nodst_start_mon_higher
              	
              	      ; Start month is lower than end month, add 12 to reverse order
0A34: 1612    	      ld    D, 0x12
0A36: 82      	      add   A, D
0A37: 27      	      daa
0A38: 47      	      ld    B, A
              	
0A39: 3A7260  	      ld    A, (clock_tz_mon)       ; Must also offset current month,
0A3C: B9      	      cp    A, C                    ; but only if less than the end
0A3D: 3007    	      jr    NC, check2              ; month.
              	
0A3F: 82      	      add   A, D
0A40: 27      	      daa
              	
0A41: 1803    	      jr    check2
              	
0A43:         	nodst_start_mon_higher
0A43: 3A7260  	      ld    A, (clock_tz_mon)       ; Load current month unaffected
              	
0A46:         	check2
0A46: B9      	      cp    A, C
0A47: 285A    	      jr    Z, check_end_cond       ; cur_mon == end_mon
0A49: 380D    	      jr    C, check_start_cond     ; cur_mon < end_mon
              	
0A4B: B8      	      cp    A, B
0A4C: 280A    	      jr    Z, check_start_cond     ; cur_mon == start_mon
0A4E: 3008    	      jr    NC, check_start_cond    ; cur_mon > start_mon
              	
              	      ; At this point DST is definitively NOT IN EFFECT
0A50: AF      	      xor   A, A                    ; Clear all match flags
0A51: 327F60  	      ld    (row_flags), A
0A54: C1      	      pop   BC                      ; No longer needed
              	
0A55: C3F90A  	      jp    display_row
              	
              	
              	;---- DST check #3: Progressively check start conditions -------------
0A58:         	check_start_cond
0A58: C1      	      pop   BC
0A59: C5      	      push  BC
0A5A: 3A7260  	      ld    A, (clock_tz_mon)
              	
0A5D: B8      	      cp    A, B                    ; In start month?
0A5E: 2043    	      jr    NZ, check_end_cond      ; No if NZ (should be end month)
              	
              	      ; Yes - In start month
0A60: 3A7260  	      ld    A, (clock_tz_mon)
0A63: 217F60  	      ld    HL, row_flags
0A66: CBD6    	      set   2, (HL)                 ; Set month match flag
0A68: C1      	      pop   BC                      ; No longer need this on stack
              	
0A69: 3A7060  	      ld    A, (clock_tz_day)       ; Load current day into B
0A6C: 47      	      ld    B, A
              	
0A6D: DD4E0A  	      ld    C, (IX+10)              ; Load start options from TZ ROM
              	
0A70: CB41    	      bit   0, C                    ; If bit 0 of start options was
0A72: 2805    	      jr    Z, check3_last_sun      ; set, find the day number of the
0A74: CD700C  	      call  find_first_sunday       ; first Sunday of the month
0A77: 1810    	      jr    check3_match_day
              	
0A79:         	check3_last_sun
0A79: CB49    	      bit   1, C                    ; If bit 1 of the start options
0A7B: 2805    	      jr    Z, check3_second_sun    ; was set, find the day number of
0A7D: CD8B0C  	      call  find_last_sunday        ; the last Sunday of the month
0A80: 1807    	      jr    check3_match_day
              	
0A82:         	check3_second_sun
0A82: CB51    	      bit   2, C                    ; If bit 2 of start options was
0A84: 281D    	      jr    Z, check_end_cond       ; set, find the day number of the
0A86: CDA00C  	      call  find_second_sunday      ; second Sunday of the month. If
              	                                    ; bit 2 not set, some other bit is
              	                                    ; and that is unhandled (no DST).
              	
0A89:         	check3_match_day
              	      ; There are 3 tests for matching the day:
              	      ;
              	      ; 1. Day of month is less than start day, no DST
              	      ; 2. Day of month is same as start day, maybe no DST just yet
              	      ;    (depends on final check of hours)
              	      ; 3. Day of month is greater than start day, DST in effect
0A89: B8      	      cp    A, B
0A8A: 2808    	      jr    Z, check3_day_equal     ; Maybe in effect
0A8C: 306B    	      jr    NC, display_row         ; Less than, not in effect
              	
              	      ; Day is greater than start day, DST is IN EFFECT. Set remaining
              	      ; match flags
0A8E: CBC6    	      set   0, (HL)
0A90: CBCE    	      set   1, (HL)
              	
0A92: 1856    	      jr    check_for_dst
              	
0A94:         	check3_day_equal
0A94: CBCE    	      set   1, (HL)                 ; Day matches, set match flag
              	
              	      ; Final check for starting DST is if the starting hour has been
              	      ; reached.
0A96: 3A6F60  	      ld    A, (clock_tz_hrs)
0A99: DD4609  	      ld    B, (IX+9)               ; Load start hour from TZ ROM
              	
0A9C: B8      	      cp    A, B
0A9D: 385A    	      jr    C, display_row          ; Hour is less than start, no DST
              	
0A9F: CBC6    	      set   0, (HL)                 ; Hour matches, set match flag
              	
0AA1: 1847    	      jr    check_for_dst
              	
              	
              	;---- DST check #4: Progressively check end conditions ---------------
0AA3:         	check_end_cond
0AA3: C1      	      pop   BC                      ; POP but dont PUSH again
0AA4: 3A7260  	      ld    A, (clock_tz_mon)
              	
0AA7: B9      	      cp    A, C                    ; In end month?
0AA8: 204F    	      jr    NZ, display_row         ; No if NZ (should have been?)
              	
              	      ; Yes - In end month
0AAA: 3A7260  	      ld    A, (clock_tz_mon)
0AAD: 217F60  	      ld    HL, row_flags
0AB0: CBD6    	      set   2, (HL)                 ; Set month match flag
              	
0AB2: 3A7060  	      ld    A, (clock_tz_day)       ; Load current day into B
0AB5: 47      	      ld    B, A
              	
0AB6: DD4E0E  	      ld    C, (IX+14)              ; Load end options from TZ ROM
              	
0AB9: CB41    	      bit   0, C                    ; If bit 0 of end options was set,
0ABB: 2805    	      jr    Z, check4_last_sun      ; find the day number of the first
0ABD: CD700C  	      call  find_first_sunday       ; Sunday of the month
0AC0: 1807    	      jr    check4_match_day
              	
0AC2:         	check4_last_sun
0AC2: CB49    	      bit   1, C                    ; If bit 1 of the start options
0AC4: 2833    	      jr    Z, display_row          ; was set, find the day number of
0AC6: CD8B0C  	      call  find_last_sunday        ; the last Sunday of the month. If
              	                                    ; bit 1 not set, some other bit is
              	                                    ; and that is unhandled (no DST).
              	
0AC9:         	check4_match_day
              	      ; There are 3 tests for matching the day:
              	      ;
              	      ; 1. Day of month is less than end day, DST in effect
              	      ; 2. Day of month is same as end day, DST may have ended
              	      ;    (depends on final check of hours)
              	      ; 3. Day of month is greater than end day, no DST
0AC9: B8      	      cp    A, B
0ACA: 2808    	      jr    Z, check4_day_equal     ; Maybe ended
0ACC: 381C    	      jr    C, check_for_dst        ; Greater than, not in effect
              	
              	      ; Day is less than end day, DST is IN EFFECT. Set remaining
              	      ; match flags
0ACE: CBC6    	      set   0, (HL)
0AD0: CBCE    	      set   1, (HL)
              	
0AD2: 1816    	      jr    check_for_dst
              	
0AD4:         	check4_day_equal
0AD4: CBCE    	      set   1, (HL)                 ; Day matches, set match flag
              	
              	      ; Final check for ending DST is if the ending hour has been
              	      ; reached.
0AD6: 3A6F60  	      ld    A, (clock_tz_hrs)
0AD9: DD460D  	      ld    B, (IX+13)              ; Load end hour from TZ ROM
              	
0ADC: 3C      	      inc   A                       ; What would the time be with DST?
0ADD: 27      	      daa
              	
0ADE: FE24    	      cp    A, 0x24                 ; Reset on overflow
0AE0: 2001    	      jr    NZ, $+3
0AE2: AF      	      xor   A, A
              	
0AE3: B8      	      cp    A, B
0AE4: 2813    	      jr    Z, display_row          ; cur_hour == end_hour, no DST
0AE6: 3011    	      jr    NC, display_row         ; cur_hour > end_hour, no DST
              	
0AE8: CBC6    	      set   0, (HL)                 ; Hour <, set match flag
              	
              	
              	;---- Check DST match flags ------------------------------------------
0AEA:         	check_for_dst
0AEA: 3A7F60  	      ld    A, (row_flags)
0AED: FE07    	      cp    A, 7                    ; Are all DST flags set?
0AEF: 2008    	      jr    NZ, display_row         ; No if NZ, update row display
              	
0AF1: CBFF    	      set   7, A                    ; Set "Apply DST" flag
0AF3: 327F60  	      ld    (row_flags), A
0AF6: C3FE08  	      jp    begin_computation       ; Re-run computation to add 1 hour
              	
              	
              	;---- Enable dimming, and display time or date on a row --------------
0AF9:         	display_row
              	      ; Enable dimming of the display if configured
0AF9: DB08    	      in    A, (BTN_REG)            ; Read buttons and switches
0AFB: 2F      	      cpl                           ; Buttons pull down, make positive
0AFC: 4F      	      ld    C, A                    ; Save A for later, determine d/c
0AFD: 1F      	      rra                           ; Move upper nibble to lower
0AFE: 1F      	      rra
0AFF: 1F      	      rra
0B00: 1F      	      rra
0B01: E603    	      and   A, DIMM_ROW>>4          ; 2 LSbs are row dimming selector
0B03: 47      	      ld    B, A                    ; Save for later
              	
0B04: 3A7460  	      ld    A, (clock_row)          ; Get display row counter and INC.
0B07: 3C      	      inc   A                       ; Row counter range is 0..2, so
              	                                    ; make comparable to switch config
              	                                    ; which is 1..3. Switches set to 0
              	                                    ; means dimming not enabled.
              	
0B08: B8      	      cp    A, B                    ; Compare row ctr with switches
0B09: 201B    	      jr    NZ, no_dimming          ; No match or dimming not enabled
              	
              	      ; Dimming enabled on this row. Dimming in effect between 2100
              	      ; and 0600 hours.
0B0B: 3A6F60  	      ld    A, (clock_tz_hrs)       ; Load hours for this row
              	
0B0E: FE21    	      cp    A, 0x21
0B10: 2806    	      jr    Z, dimming_on           ; hour == 2100
0B12: 3004    	      jr    NC, dimming_on          ; hour > 2100
              	
0B14: FE06    	      cp    A, 0x06
0B16: 300A    	      jr    NC, dimming_off         ; hour >= 0600
              	
0B18:         	dimming_on
0B18: 3E01    	      ld    A, 0x01                 ; Enable dimming (default 50% d/c)
              	
              	      ; Configure duty cycle, which is determined by the value of bit
              	      ; position 6 of the buttons register:
              	      ;
              	      ; Low (0): 50% duty cycle
              	      ; High (1): 25% duty cycle
              	
0B1A: CB71    	      bit   DUTY_CYCLE_BIT, C       ; Test switch position
0B1C: 2805    	      jr    Z, apply_dimming        ; Leave A as is for 50% d/c
              	
0B1E: 37      	      scf                           ; Set carry flag and rotate into A
0B1F: 17      	      rla                           ; for 25% d/c
              	
0B20: 1801    	      jr    apply_dimming
              	
0B22:         	dimming_off
0B22: AF      	      xor   A, A
              	
0B23:         	apply_dimming
0B23: 328A60  	      ld    (disp_dim), A
              	
0B26:         	no_dimming
              	      ; The MSb switch position indicates if the row should be
              	      ; displaying a time (low) or date (high)
0B26: 2A7560  	      ld    HL, (tz_sw_ptr)         ; Get value of timezone switches
0B29: 7E      	      ld    A, (HL)                 ; for this row
0B2A: 2F      	      cpl                           ; Switches pull down, so invert
0B2B: CB7F    	      bit   7, A
              	
0B2D: 203F    	      jr    NZ, display_date
              	
              	
              	;---- Time display ---------------------------------------------------
0B2F:         	display_time
              	      ; Load the name of the timezone into the beginning of this row
0B2F: 2A7960  	      ld    HL, (row_buf_ptr)       ; Row pointer to DE
0B32: EB      	      ex    DE, HL
0B33: 2A7760  	      ld    HL, (tz_rom_ptr)        ; TZ ROM pointer to HL, TZ name
0B36: 23      	      inc   HL                      ; begins from second byte
0B37: 010300  	      ld    BC, 3
0B3A: CD2015  	      call  strncpy
              	
0B3D: EB      	      ex    DE, HL                  ; Save ptr for later
0B3E: E5      	      push  HL
              	
              	      ; If in DST, add a + to indicate it
0B3F: 217F60  	      ld    HL, row_flags
0B42: 3E20    	      ld    A, ' '
              	
0B44: CB7E    	      bit   7, (HL)
0B46: 2802    	      jr    Z, $+4
0B48: 3E2B    	      ld    A, '+'
              	
0B4A: E1      	      pop   HL                      ; Restore ptr
0B4B: 77      	      ld    (HL), A
0B4C: 23      	      inc   HL
              	
              	      ; Place hours and minutes into display buffer
0B4D: 3A6F60  	      ld    A, (clock_tz_hrs)       ; Hours value, in BCD
0B50: 0602    	      ld    B, 2
              	
0B52:         	hrs_min_to_buf
0B52: 4F      	      ld    C, A                    ; Save a copy
              	
0B53: 1F      	      rra                           ; Tens digit is upper nibble, move
0B54: 1F      	      rra                           ; to lower nibble
0B55: 1F      	      rra
0B56: 1F      	      rra
0B57: E607    	      and   A, 0x07                 ; Remove AM/PM, keep only 3 LSb's
0B59: C630    	      add   A, 0x30                 ; Add 0x30 to make ASCII char val
0B5B: 77      	      ld    (HL), A                 ; Store char val into disp buf
0B5C: 23      	      inc   HL
              	
0B5D: 79      	      ld    A, C                    ; Units digit
0B5E: E60F    	      and   A, 0x0F
0B60: C630    	      add   A, 0x30
0B62: 77      	      ld    (HL), A
0B63: 23      	      inc   HL
              	
0B64: 3A6E60  	      ld    A, (clock_tz_min)       ; Load mins value for next iter
              	
0B67: 10E9    	      djnz  hrs_min_to_buf
              	
0B69: 227960  	      ld    (row_buf_ptr), HL       ; Save updated row buffer pointer
              	                                    ; which now points to the next row
0B6C: 1840    	      jr    row_loop_done
              	
              	
              	;---- Date display ---------------------------------------------------
0B6E:         	display_date
0B6E: 2A7960  	      ld    HL, (row_buf_ptr)       ; Row buffer is destination
0B71: EB      	      ex    DE, HL
              	
0B72: 3A7160  	      ld    A, (clock_tz_dow)       ; DOW forms offset after << 2
0B75: 17      	      rla
0B76: 17      	      rla
0B77: E61C    	      and   0x1C
              	
0B79: 21500C  	      ld    HL, short_day_names     ; Add offset to L
0B7C: 0600    	      ld    B, 0
0B7E: 4F      	      ld    C, A
0B7F: 09      	      add   HL, BC
              	
0B80: 010300  	      ld    BC, 3                   ; Copy day name to start of row
0B83: CD2015  	      call  strncpy
              	
0B86: EB      	      ex    DE, HL
              	
              	      ; Place month and day number into display buffer
0B87: 3A7260  	      ld    A, (clock_tz_mon)       ; Month value, in BCD
0B8A: 0602    	      ld    B, 2
              	
0B8C:         	mon_day_to_buf
0B8C: 4F      	      ld    C, A                    ; Save a copy
              	
0B8D: 1F      	      rra                           ; Tens digit is upper nibble, move
0B8E: 1F      	      rra                           ; to lower nibble
0B8F: 1F      	      rra
0B90: 1F      	      rra
0B91: E603    	      and   A, 0x03                 ; Keep only 2 LSb's
0B93: C630    	      add   A, 0x30                 ; Add 0x30 to make ASCII char val
0B95: 77      	      ld    (HL), A                 ; Store char val into disp buf
0B96: 23      	      inc   HL
              	
0B97: 79      	      ld    A, C                    ; Units digit
0B98: E60F    	      and   A, 0x0F
0B9A: C630    	      add   A, 0x30
0B9C: 77      	      ld    (HL), A
0B9D: 23      	      inc   HL
              	
0B9E: 78      	      ld    A, B                    ; Only add / between mon and day
0B9F: 3D      	      dec   A
0BA0: 2807    	      jr    Z, mon_day_dec
              	
0BA2: 3E2F    	      ld    A, '/'                  ; Add / to separate mon and day
0BA4: 77      	      ld    (HL), A
0BA5: 23      	      inc   HL
              	
0BA6: 3A7060  	      ld    A, (clock_tz_day)       ; Load day number for next iter
              	
0BA9:         	mon_day_dec
0BA9: 10E1    	      djnz  mon_day_to_buf
              	
0BAB: 227960  	      ld    (row_buf_ptr), HL       ; Save updated row buffer pointer
              	                                    ; which now points to the next row
              	
              	
              	;---- Row loop complete ----------------------------------------------
0BAE:         	row_loop_done
              	      ; Increment various pointers, counters, etc
0BAE: 217560  	      ld    HL, tz_sw_ptr           ; Next timezone switch
0BB1: 34      	      inc   (HL)
              	
0BB2: 217460  	      ld    HL, clock_row           ; Increment row counter itself
0BB5: 34      	      inc   (HL)
0BB6: 7E      	      ld    A, (HL)
              	
              	      ; Iterate again if row counter < 3
0BB7: FE03    	      cp    A, 3
0BB9: C2BE08  	      jp    NZ, row_loop
              	
              	      sem_post clock_upd_req_sem
0BBC: F5      	      push  AF
0BBD: E5      	      push  HL
              	
0BBE: ED57    	      ld    A, I                    ; IFF2 to P/V flag
0BC0: F5      	      push  AF                      ; Save flags
0BC1: F3      	      di                            ; Ensure interrupts disabled
              	
0BC2: 210360  	      ld    HL, clock_upd_req_sem
0BC5: 34      	      inc   (HL)
              	
0BC6: E1      	      pop   HL                      ; F into L
0BC7: CB55    	      bit   2, L                    ; Test IFF2 flag
0BC9: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
0BCB: FB      	      ei                            ; Re-enable interrupts
              	
0BCC: E1      	      pop   HL
0BCD: F1      	      pop   AF
              	      set_state clock_state, CLOCK_IDLE
0BCE: F5      	      push  AF
              	
0BCF: 3E02    	      ld    A, CLOCK_IDLE
0BD1: 326460  	      ld    (clock_state), A
              	
0BD4: F1      	      pop   AF
              	
0BD5: C9      	      ret
              	#endlocal
              	
              	;---- State 02 -------------------------------------------------------
              	;     The clock app idles in this state while waiting for one of two
              	;     events to happen:
              	;
              	;     1. Esc button is pressed, and the app is exited
              	;     2. clock_upd_sem contains a non-zero value, and the displays
              	;        are updated
0BD6:         	clock_idle
              	#local
0BD6: 3A5D60  	      ld    A, (btn_state)          ; Check if the escape button is
0BD9: CB5F    	      bit   BTN_ESC_BIT, A          ; pressed, if so, proceed to exit
0BDB: 280F    	      jr    Z, check_semaphore
              	
              	      ack_btn BTN_ESC_BIT
0BDD: E5      	      push  HL
              	
0BDE: 215C60  	      ld    HL, btn_ack             ; Ack the button
0BE1: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
0BE3: E1      	      pop   HL
              	      set_state clock_state, CLOCK_EXIT
0BE4: F5      	      push  AF
              	
0BE5: 3E03    	      ld    A, CLOCK_EXIT
0BE7: 326460  	      ld    (clock_state), A
              	
0BEA: F1      	      pop   AF
              	
0BEB: C9      	      ret
              	
0BEC:         	check_semaphore
              	      sem_trywait clock_upd_sem     ; Check clock_upd_sem and proceed
0BEC: E5      	      push  HL
              	
0BED: ED57    	      ld    A, I                    ; IFF2 to P/V flag
0BEF: F5      	      push  AF                      ; Save flags
0BF0: F3      	      di                            ; Ensure interrupts disabled
              	
0BF1: 210460  	      ld    HL, clock_upd_sem
0BF4: 7E      	      ld    A, (HL)                 ; Load semaphore value for return
0BF5: B7      	      or    A, A                    ; Semaphore value greater than 0?
0BF6: 2801    	      jr    Z, $+3                  ; If Z, return 0, go to done
              	
0BF8: 35      	      dec   (HL)                    ; Decrement semaphore
              	
0BF9: E1      	      pop   HL                      ; F into L
0BFA: CB55    	      bit   2, L                    ; Test IFF2 flag
0BFC: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
0BFE: FB      	      ei                            ; Re-enable interrupts
              	
0BFF: E1      	      pop   HL                      ; Done
              	
0C00: B7      	      or    A, A                    ; Set Z flag according to A
0C01: C8      	      ret   Z                       ; to update clock display if > 0
              	
              	      set_state clock_state, CLOCK_UPDATE
0C02: F5      	      push  AF
              	
0C03: 3E01    	      ld    A, CLOCK_UPDATE
0C05: 326460  	      ld    (clock_state), A
              	
0C08: F1      	      pop   AF
              	
0C09: C9      	      ret
              	#endlocal
              	
              	;---- State 03 -------------------------------------------------------
              	;     Exit the config app by releasing the foreground mutex.
0C0A:         	clock_exit_app
              	      set_state clock_state, CLOCK_APP_START
0C0A: F5      	      push  AF
              	
0C0B: 3E00    	      ld    A, CLOCK_APP_START
0C0D: 326460  	      ld    (clock_state), A
              	
0C10: F1      	      pop   AF
              	      mtx_unlock foreground_mtx
0C11: F5      	      push  AF
0C12: E5      	      push  HL
              	
0C13: ED57    	      ld    A, I                    ; IFF2 to P/V flag
0C15: F5      	      push  AF                      ; Save flags
0C16: F3      	      di                            ; Ensure interrupts disabled
              	
0C17: AF      	      xor   A, A                    ; Load zero to unlock the mutex
0C18: 320060  	      ld    (foreground_mtx), A
              	
0C1B: E1      	      pop   HL                      ; F into L
0C1C: CB55    	      bit   2, L                    ; Test IFF2 flag
0C1E: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
0C20: FB      	      ei                            ; Re-enable interrupts
              	
0C21: E1      	      pop   HL                      ; Done
0C22: F1      	      pop   AF
              	
0C23: C9      	      ret
              	
              	; State machine jump table
0C24: 4D08    	clock_jp_tbl            .dw   clock_app_start
0C26: 8008    	                        .dw   clock_update
0C28: D60B    	                        .dw   clock_idle
0C2A: 0A0C    	                        .dw   clock_exit_app
              	
              	; Days per month in a common year - keep aligned to 16 bytes
0C2C: FFFFFFFF	      .align 0x10
0C30: 31283130	days_common_year        .dm   0x31, 0x28, 0x31, 0x30, 0x31, 0x30
0C34: 3130    	
0C36: 31313031	                        .dm   0x31, 0x31, 0x30, 0x31, 0x30, 0x31
0C3A: 3031    	
              	
              	; Days per month in a leap year - keep aligned to 16 bytes
0C3C: FFFFFFFF	      .align 0x10
0C40: 31293130	days_leap_year          .dm   0x31, 0x29, 0x31, 0x30, 0x31, 0x30
0C44: 3130    	
0C46: 31313031	                        .dm   0x31, 0x31, 0x30, 0x31, 0x30, 0x31
0C4A: 3031    	
              	
              	; Short day of week names - keep aligned to 16 bytes
0C4C: FFFFFFFF	      .align 0x10
0C50: 00000000	short_day_names         .text 0, 0, 0, 0        ; Null entry
0C54: 53550000	                        .text 'SU', 0, 0        ; Each day name takes
0C58: 4D4F0000	                        .text 'MO', 0, 0        ; 4 bytes to that the
0C5C: 54550000	                        .text 'TU', 0, 0        ; day number can be
0C60: 57450000	                        .text 'WE', 0, 0        ; simply shifted by
0C64: 54480000	                        .text 'TH', 0, 0        ; two places to the
0C68: 46520000	                        .text 'FR', 0, 0        ; left for its offset.
0C6C: 53410000	                        .text 'SA', 0, 0
              	
              	
              	;---------------------------------------------------------------------
              	;     find_first_sunday                                              :
              	;                                                                    :
              	; Description                                                        :
              	;     Finds the day number of the first Sunday in a month.           :
              	;                                                                    :
              	;     Takes no parameters, but uses timezone row variables and       :
              	;     returns the result in A.                                       :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  Day number of first Sunday in BCD                           :
              	;---------------------------------------------------------------------
0C70:         	find_first_sunday
              	#local
0C70: C5      	      push  BC
              	
0C71: 3A7160  	      ld    A, (clock_tz_dow)       ; Day of week into B
0C74: 3D      	      dec   A                       ; Make day of week range 0..6
0C75: 47      	      ld    B, A
              	
0C76: 3A7060  	      ld    A, (clock_tz_day)       ; Day of month into A
0C79: CDA70C  	      call  bcd_to_dec              ; Convert from BCD to decimal
              	
0C7C: C607    	      add   A, 7                    ; Add an extra week to cater for
              	                                    ; low day numbers
              	
0C7E: 90      	      sub   A, B                    ; Subtract DOW from day
              	
0C7F: FE08    	      cp    A, 8                    ; Result is day 1-7?
0C81: 3806    	      jr    C, done                 ; Yes if C, done
              	
0C83:         	loop
0C83: D607    	      sub   A, 7                    ; Take a week off
0C85: FE08    	      cp    A, 8                    ; Result is day 1-7?
0C87: 30FA    	      jr    NC, loop                ; No if NC, go again
              	
0C89:         	done
0C89: C1      	      pop   BC
              	
0C8A: C9      	      ret
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     find_last_sunday                                               :
              	;                                                                    :
              	; Description                                                        :
              	;     Finds the day number of the last Sunday in a month.            :
              	;                                                                    :
              	;     This is done by calling find_first_sunday and then adding 7    :
              	;     as long as the day number does not exceed the number of days   :
              	;     in the current month (per clock_tz_days_in_mon).               :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  Day number of last Sunday in BCD                            :
              	;---------------------------------------------------------------------
0C8B:         	find_last_sunday
              	#local
0C8B: C5      	      push  BC
              	
0C8C: 3A7360  	      ld    A, (clock_tz_days_in_mon)
0C8F: 47      	      ld    B, A
              	
0C90: CD700C  	      call  find_first_sunday
              	
0C93:         	loop
0C93: C607    	      add   A, 7                    ; Add a week
0C95: 27      	      daa
              	
0C96: B8      	      cp    A, B                    ; Below number of days in month?
0C97: 38FA    	      jr    C, loop                 ; Yes if C, loop again
0C99: 2803    	      jr    Z, done                 ; Last day is Sunday if Z
              	
0C9B: D607    	      sub   A, 7                    ; Overshot in last loop iter, fix
0C9D: 27      	      daa
              	
0C9E:         	done
0C9E: C1      	      pop   BC
              	
0C9F: C9      	      ret
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     find_second_sunday                                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Finds the day number of the second Sunday in a month.          :
              	;                                                                    :
              	;     This is done by calling find_first_sunday and then adding 7.   :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  Day number of second Sunday in BCD                          :
              	;---------------------------------------------------------------------
0CA0:         	find_second_sunday
0CA0: CD700C  	      call  find_first_sunday
0CA3: C607    	      add   A, 7
0CA5: 27      	      daa
              	
0CA6: C9      	      ret
              	
              	
              	;---------------------------------------------------------------------
              	;     bcd_to_dec                                                     :
              	;                                                                    :
              	; Description                                                        :
              	;     Convert the BCD value in A to a decimal number.                :
              	;                                                                    :
              	; Returns                                                            :
              	;     A  Decimal converted number                                    :
              	;---------------------------------------------------------------------
0CA7:         	bcd_to_dec
0CA7: C5      	      push  BC                      ; Save BC, B is used as temp
0CA8: 4F      	      ld    C, A                    ; Store A for later
              	
0CA9: 1F      	      rra                           ; Tens to lower nibble
0CAA: 1F      	      rra
0CAB: 1F      	      rra
0CAC: 1F      	      rra
0CAD: E60F    	      and   A, 0xF                  ; Clear upper nibble
0CAF: 47      	      ld    B, A                    ; Save 1x lower nibble
0CB0: 87      	      add   A, A                    ; Lower nibble * 2
0CB1: 80      	      add   A, B                    ; Lower nibble * 3
0CB2: CB27    	      sla   A                       ; Lower nibble * 6
0CB4: 47      	      ld    B, A                    ; B = 6 * tens
0CB5: 79      	      ld    A, C                    ; Restore original BCD val
0CB6: 90      	      sub   A, B                    ; Subtract 6 * tens from BCD
              	
0CB7: C1      	      pop   BC
              	
0CB8: C9      	      ret
              	
              	; END clock_app.s
              	#include "configr_app.s"
              	;---------------------------------------------------------------------
              	;     Configuration Application                                      :
              	;                                                                    :
              	; Description                                                        :
              	;     This task is scheduled at boot and should not be descheduled.  :
              	;                                                                    :
              	;     This task runs as an application of sorts. It implements a     :
              	;     state machine which provides an interface that allows the user :
              	;     to configure the time and date of UTC (the base timezone)      :
              	;     which is then stored within the RTC peripheral.                :
              	;                                                                    :
              	;     The task self determines if it should run, signalled by the    :
              	;     foreground mutex either being null or owned.                   :
              	;---------------------------------------------------------------------
              	
              	; State machine states
0000:         	CONFIGR_APP_START       .equ  0
0001:         	CONFIGR_MAIN_MENU       .equ  0x01
0002:         	CONFIGR_ADJUST_TIME     .equ  0x02
0003:         	CONFIGR_HOURS_MSG       .equ  0x03
0004:         	CONFIGR_ADJUST_HOURS    .equ  0x04
0005:         	CONFIGR_MINUTES_MSG     .equ  0x05
0006:         	CONFIGR_ADJUST_MINS     .equ  0x06
0007:         	CONFIGR_APPLY_TIME      .equ  0x07
0008:         	CONFIGR_ADJUST_DATE     .equ  0x08
0009:         	CONFIGR_YEAR_MSG        .equ  0x09
000A:         	CONFIGR_ADJUST_YEAR     .equ  0x0A
000B:         	CONFIGR_MONTH_MSG       .equ  0x0B
000C:         	CONFIGR_ADJUST_MONTH    .equ  0x0C
000D:         	CONFIGR_DAY_MSG         .equ  0x0D
000E:         	CONFIGR_ADJUST_DAY      .equ  0x0E
000F:         	CONFIGR_DOW_MSG         .equ  0x0F
0010:         	CONFIGR_ADJUST_DOW      .equ  0x10
0011:         	CONFIGR_APPLY_DATE      .equ  0x11
0012:         	CONFIGR_EXIT            .equ  0x12
              	
              	#data RAM
6080: 00      	configr_state           .db 0       ; State machine value
6081: 00      	configr_menu_opt        .db 0       ; Current menu option
              	
6082: 00      	configr_rtc_min         .db 0       ; Copy of RTC registers for
6083: 00      	configr_rtc_hrs         .db 0       ; adjusting and setting time/date
6084: 00      	configr_rtc_day         .db 0
6085: 00      	configr_rtc_dow         .db 0
6086: 00      	configr_rtc_mon         .db 0
6087: 00      	configr_rtc_year        .db 0
              	
              	#data _INITIALIZED
              	#code _INITIALIZER
              	
              	#code ROM
0CB9: FFFFFFFF	      .align 0x100
0CBD: FF...   	
0D00:         	configr_app
              	      ; Try to lock the foreground mutex if it is available, or return
              	      mtx_trylock foreground_mtx, APP_CONFIGR
0D00: E5      	      push  HL
              	
0D01: ED57    	      ld    A, I                    ; IFF2 to P/V flag
0D03: F5      	      push  AF                      ; Save flags
0D04: F3      	      di                            ; Ensure interrupts disabled
              	
0D05: 210060  	      ld    HL, foreground_mtx
0D08: 7E      	      ld    A, (HL)                 ; Check current mutex owner
0D09: B7      	      or    A, A
0D0A: 2807    	      jr    Z, $+9                  ; If zero, acquire it
              	
0D0C: FE04    	      cp    A, APP_CONFIGR            ; If not zero, do we own it?
0D0E: 2806    	      jr    Z, $+8                  ; Yes if Z, return mutex value
              	
0D10: AF      	      xor   A, A                    ; No otherwise, return 0
0D11: 1803    	      jr    $+5                     ; Go to done
              	
0D13: 3E04    	      ld    A, APP_CONFIGR            ; Acquire by loading task_num into
0D15: 77      	      ld    (HL), A                 ; mutex
              	
0D16: E1      	      pop   HL                      ; F into L
0D17: CB55    	      bit   2, L                    ; Test IFF2 flag
0D19: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
0D1B: FB      	      ei                            ; Re-enable interrupts
              	
0D1C: E1      	      pop   HL                      ; Done
              	
0D1D: B7      	      or    A, A                    ; Set Z flag according to A
0D1E: C8      	      ret   Z
              	
              	      ; Check semaphore to determine if config app should run
              	      sem_trywait configr_app_sem
0D1F: E5      	      push  HL
              	
0D20: ED57    	      ld    A, I                    ; IFF2 to P/V flag
0D22: F5      	      push  AF                      ; Save flags
0D23: F3      	      di                            ; Ensure interrupts disabled
              	
0D24: 210260  	      ld    HL, configr_app_sem
0D27: 7E      	      ld    A, (HL)                 ; Load semaphore value for return
0D28: B7      	      or    A, A                    ; Semaphore value greater than 0?
0D29: 2801    	      jr    Z, $+3                  ; If Z, return 0, go to done
              	
0D2B: 35      	      dec   (HL)                    ; Decrement semaphore
              	
0D2C: E1      	      pop   HL                      ; F into L
0D2D: CB55    	      bit   2, L                    ; Test IFF2 flag
0D2F: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
0D31: FB      	      ei                            ; Re-enable interrupts
              	
0D32: E1      	      pop   HL                      ; Done
              	
0D33: B7      	      or    A, A                    ; Set Z flag according to A
0D34: C8      	      ret   Z
              	
              	      ; Get jump table entry and jump to state
0D35: 3A8060  	      ld    A, (configr_state)
              	      get_jp_table_entry configr_jp_tbl
0D38: D5      	      push DE
              	
0D39: 1600    	      ld    D, 0                    ; DE becomes offset by doubling A
0D3B: 5F      	      ld    E, A
0D3C: CB23    	      sla   E
0D3E: CB12    	      rl    D
              	
0D40: 219111  	      ld    HL, configr_jp_tbl              ; HL = pointer to jump table
0D43: 19      	      add   HL, DE                  ; Add offset to pointer
              	
0D44: 5E      	      ld    E, (HL)                 ; Load HL pair into DE
0D45: 23      	      inc   HL
0D46: 56      	      ld    D, (HL)
              	
0D47: EB      	      ex    DE, HL                  ; DE becomes HL for return
              	
0D48: D1      	      pop   DE
0D49: E9      	      jp    (HL)
              	
              	;---- State 00 -------------------------------------------------------
              	;     This is where the app starts from fresh.
0D4A:         	configr_app_start
0D4A: 010800  	      ld    BC, 8                   ; Display app title on row 1
0D4D: 114060  	      ld    DE, staging_row1
0D50: 21B711  	      ld    HL, configr_title
0D53: CD2015  	      call  strncpy
              	
0D56: 3E00    	      ld    A, 0                    ; Clear rows 2 and 3
0D58: 011300  	      ld    BC, 19
0D5B: 214860  	      ld    HL, staging_row2
0D5E: CD4015  	      call  memset
              	
0D61: AF      	      xor   A, A
0D62: 328160  	      ld    (configr_menu_opt), A   ; Reset selected menu option
0D65: 326360  	      ld    (display_effect), A     ; Disable display update effects
              	
              	      set_valid_btn_mask BTN_ALL
0D68: F5      	      push  AF
0D69: C5      	      push  BC
              	
0D6A: 3A5D60  	      ld    A, (btn_state)          ; Ack all un-ack'd buttons by
0D6D: 47      	      ld    B, A                    ; OR'ing them with all ack'd
0D6E: 3A5C60  	      ld    A, (btn_ack)            ; buttons.
0D71: B0      	      or    A, B
0D72: 325C60  	      ld    (btn_ack), A
              	
0D75: 3E0F    	      ld    A, BTN_ALL
0D77: 325B60  	      ld    (btn_valid), A          ; Load new mask
              	
0D7A: C1      	      pop   BC
0D7B: F1      	      pop   AF
              	      set_state configr_state, CONFIGR_MAIN_MENU
0D7C: F5      	      push  AF
              	
0D7D: 3E01    	      ld    A, CONFIGR_MAIN_MENU
0D7F: 328060  	      ld    (configr_state), A
              	
0D82: F1      	      pop   AF
              	
0D83: C9      	      ret
              	
              	;---- State 01 -------------------------------------------------------
              	;     Implements the main menu.
              	;
              	;     User can:
              	;     * Select between setting date and time using Up/Down buttons
              	;     * Proceed to perform that action by pressing the Enter button
              	;     * Exit configurator app using Escape button
0D84:         	configr_main_menu
              	#local
0D84: 010800  	      ld    BC, 8                   ; Prepare to set text on row 2,
0D87: 114860  	      ld    DE, staging_row2        ; default to "SET DATE"
0D8A: 21C811  	      ld    HL, configr_menu_set_date
              	
0D8D: 3A8160  	      ld    A, (configr_menu_opt)   ; If selected menu option is value
0D90: FE00    	      cp    A, 0                    ; 0 (zero), row 2 will display
0D92: 2003    	      jr    NZ, do_msg              ; "SET TIME" instead.
0D94: 21BF11  	      ld    HL, configr_menu_set_time
              	
0D97:         	do_msg
0D97: CD2015  	      call  strncpy
              	
              	      ; Handle button presses
0D9A: 3A5D60  	      ld    A, (btn_state)
              	
0D9D: CB5F    	      bit   BTN_ESC_BIT, A
0D9F: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape exits the config app
0DA1: E5      	      push  HL
              	
0DA2: 215C60  	      ld    HL, btn_ack             ; Ack the button
0DA5: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
0DA7: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_EXIT
0DA8: F5      	      push  AF
              	
0DA9: 3E12    	      ld    A, CONFIGR_EXIT
0DAB: 328060  	      ld    (configr_state), A
              	
0DAE: F1      	      pop   AF
              	
0DAF: C9      	      ret
              	
0DB0:         	test_enter_btn
0DB0: CB57    	      bit   BTN_ENT_BIT, A
0DB2: 281E    	      jr    Z, test_updn_btns
              	
              	      ack_btn BTN_ENT_BIT
0DB4: E5      	      push  HL
              	
0DB5: 215C60  	      ld    HL, btn_ack             ; Ack the button
0DB8: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
0DBA: E1      	      pop   HL
              	
0DBB: 3A8160  	      ld    A, (configr_menu_opt)
0DBE: FE00    	      cp    A, 0
0DC0: 2008    	      jr    NZ, enter_menu1
              	
              	      ; On Enter, if menu option was 0, proceed to set time
              	      set_state configr_state, CONFIGR_ADJUST_TIME
0DC2: F5      	      push  AF
              	
0DC3: 3E02    	      ld    A, CONFIGR_ADJUST_TIME
0DC5: 328060  	      ld    (configr_state), A
              	
0DC8: F1      	      pop   AF
              	
0DC9: C9      	      ret
              	
0DCA:         	enter_menu1
              	      ; Otherwise proceed to set date
              	      set_state configr_state, CONFIGR_ADJUST_DATE
0DCA: F5      	      push  AF
              	
0DCB: 3E08    	      ld    A, CONFIGR_ADJUST_DATE
0DCD: 328060  	      ld    (configr_state), A
              	
0DD0: F1      	      pop   AF
              	
0DD1: C9      	      ret
              	
0DD2:         	test_updn_btns
0DD2: 47      	      ld    B, A
0DD3: E603    	      and   A, 0x03
0DD5: C8      	      ret   Z
              	
              	      ; Up and Down buttons achieve essentially the same thing, so
              	      ; handle them as though they are the same - toggle the LSb to
              	      ; move between the two available options
0DD6: 218160  	      ld    HL, configr_menu_opt
0DD9: 7E      	      ld    A, (HL)
0DDA: EE01    	      xor   A, 0x01
0DDC: 77      	      ld    (HL), A
              	
              	      ack_btn BTN_UP_BIT
0DDD: E5      	      push  HL
              	
0DDE: 215C60  	      ld    HL, btn_ack             ; Ack the button
0DE1: CBC6    	      set   BTN_UP_BIT, (HL)
              	
0DE3: E1      	      pop   HL
              	      ack_btn BTN_DN_BIT
0DE4: E5      	      push  HL
              	
0DE5: 215C60  	      ld    HL, btn_ack             ; Ack the button
0DE8: CBCE    	      set   BTN_DN_BIT, (HL)
              	
0DEA: E1      	      pop   HL
              	
0DEB: C9      	      ret
              	#endlocal
              	
              	;---- State 02 -------------------------------------------------------
              	;     Adjust the time.
              	;
              	;     The hours and minutes registers of the RTC are copied to RAM so
              	;     they can be adjusted independently, and then applied at the end.
              	;
              	;     Falls through to next state.
0DEC:         	configr_adjust_time
              	      rtc_update_lock
0DEC: F5      	      push  AF
              	
0DED: 3E0E    	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
0DEF: D31E    	      out   (RTC_CTRL), A
              	
0DF1: F1      	      pop   AF
              	
0DF2: DB12    	      in    A, (RTC_MIN)
0DF4: 328260  	      ld    (configr_rtc_min), A
0DF7: DB14    	      in    A, (RTC_HRS)
0DF9: E67F    	      and   A, 0x7F                 ; Remove MSb (AM/PM indicator)
0DFB: 328360  	      ld    (configr_rtc_hrs), A
              	
              	      rtc_update_unlock
0DFE: F5      	      push  AF
              	
0DFF: 3E06    	      ld    A, RTC_CTRL_CFG
0E01: D31E    	      out   (RTC_CTRL), A
              	
0E03: F1      	      pop   AF
              	
0E04: 010800  	      ld    BC, 8                   ; Set title/row 1 to "TIME UTC"
0E07: 114060  	      ld    DE, staging_row1
0E0A: 21D111  	      ld    HL, configr_time_utc
0E0D: CD2015  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_HOURS_MSG
0E10: F5      	      push  AF
              	
0E11: 3E03    	      ld    A, CONFIGR_HOURS_MSG
0E13: 328060  	      ld    (configr_state), A
              	
0E16: F1      	      pop   AF
              	
              	;---- State 03 -------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
0E17:         	configr_hours_msg
0E17: 011000  	      ld    BC, 16                  ; Set row 2 to "HOURS" and clear
0E1A: 114860  	      ld    DE, staging_row2        ; row 3
0E1D: 21DA11  	      ld    HL, configr_set_hours
0E20: CD2015  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_HOURS
0E23: F5      	      push  AF
              	
0E24: 3E04    	      ld    A, CONFIGR_ADJUST_HOURS
0E26: 328060  	      ld    (configr_state), A
              	
0E29: F1      	      pop   AF
              	
              	;---- State 04 -------------------------------------------------------
              	;     Implements hours adjustment.
              	;
              	;     Hours value can be adjusted using the Up/Down buttons. Proceed
              	;     to Minutes adjustment using the Enter button, or exit back to
              	;     the main menu using the Escape button.
0E2A:         	configr_adjust_hours
              	#local
              	      ; Display tens digit in row 3 col 0
0E2A: 218360  	      ld    HL, configr_rtc_hrs
0E2D: 7E      	      ld    A, (HL)
0E2E: 0F      	      rrca
0E2F: 0F      	      rrca
0E30: 0F      	      rrca
0E31: 0F      	      rrca
0E32: E60F    	      and   A, 0x0F
0E34: C630    	      add   A, 0x30
0E36: 325060  	      ld    (staging_row3), A
              	
              	      ; Display units digit in row 3 col 1
0E39: 7E      	      ld    A, (HL)
0E3A: E60F    	      and   A, 0x0F
0E3C: C630    	      add   A, 0x30
0E3E: 325160  	      ld    (staging_row3+1), A
              	
              	      ; Handle button presses
0E41: 3A5D60  	      ld    A, (btn_state)
              	
0E44: CB5F    	      bit   BTN_ESC_BIT, A
0E46: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to main menu
0E48: E5      	      push  HL
              	
0E49: 215C60  	      ld    HL, btn_ack             ; Ack the button
0E4C: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
0E4E: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_APP_START
0E4F: F5      	      push  AF
              	
0E50: 3E00    	      ld    A, CONFIGR_APP_START
0E52: 328060  	      ld    (configr_state), A
              	
0E55: F1      	      pop   AF
              	
0E56: C9      	      ret
              	
0E57:         	test_enter_btn
0E57: CB57    	      bit   BTN_ENT_BIT, A
0E59: 280F    	      jr    Z, test_updn_btns
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to minutes adjust
0E5B: E5      	      push  HL
              	
0E5C: 215C60  	      ld    HL, btn_ack             ; Ack the button
0E5F: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
0E61: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_MINUTES_MSG
0E62: F5      	      push  AF
              	
0E63: 3E05    	      ld    A, CONFIGR_MINUTES_MSG
0E65: 328060  	      ld    (configr_state), A
              	
0E68: F1      	      pop   AF
              	
0E69: C9      	      ret
              	
0E6A:         	test_updn_btns
0E6A: 47      	      ld    B, A
0E6B: E603    	      and   A, 0x03                 ; Up or Down pressed?
0E6D: C8      	      ret   Z                       ; No if Z
              	
0E6E: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
0E6F: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
0E71: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
0E73: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
0E74: E5      	      push  HL
              	
0E75: 215C60  	      ld    HL, btn_ack             ; Ack the button
0E78: CBC6    	      set   BTN_UP_BIT, (HL)
              	
0E7A: E1      	      pop   HL
0E7B: 1808    	      jr    store
              	
0E7D:         	down_button
0E7D: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
0E7E: E5      	      push  HL
              	
0E7F: 215C60  	      ld    HL, btn_ack             ; Ack the button
0E82: CBCE    	      set   BTN_DN_BIT, (HL)
              	
0E84: E1      	      pop   HL
              	
0E85:         	store
0E85: 27      	      daa                           ; Format new value for BCD
0E86: 77      	      ld    (HL), A                 ; Store new value back
              	
0E87: FE24    	      cp    A, 0x24                 ; New value overflowed to 24?
0E89: 2003    	      jr    NZ, cp_99
0E8B: 3600    	      ld    (HL), 0                 ; Yes, reset to 0
              	
0E8D: C9      	      ret
              	
0E8E:         	cp_99
0E8E: FE99    	      cp    A, 0x99                 ; New value underflowed to 99?
0E90: C0      	      ret   NZ
0E91: 3623    	      ld    (HL), 0x23              ; Yes, reset to 23
              	
0E93: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 05 -------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
0E94:         	configr_minutes_msg
0E94: 011000  	      ld    BC, 16                  ; Set row 2 to "MINUTES" and clear
0E97: 114860  	      ld    DE, staging_row2        ; row 3
0E9A: 21E011  	      ld    HL, configr_set_minutes
0E9D: CD2015  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_MINS
0EA0: F5      	      push  AF
              	
0EA1: 3E06    	      ld    A, CONFIGR_ADJUST_MINS
0EA3: 328060  	      ld    (configr_state), A
              	
0EA6: F1      	      pop   AF
              	
              	;---- State 06 -------------------------------------------------------
              	;     Implements minutes adjustment.
              	;
              	;     Minutes value can be adjusted using the Up/Down buttons. Proceed
              	;     to apply new time using Enter button, or return to hours
              	;     adjustment using Escape button.
0EA7:         	configr_adjust_mins
              	#local
              	      ; Display tens digit in row 3 col 0
0EA7: 218260  	      ld    HL, configr_rtc_min
0EAA: 7E      	      ld    A, (HL)
0EAB: 0F      	      rrca
0EAC: 0F      	      rrca
0EAD: 0F      	      rrca
0EAE: 0F      	      rrca
0EAF: E60F    	      and   A, 0x0F
0EB1: C630    	      add   A, 0x30
0EB3: 325060  	      ld    (staging_row3), A
              	
              	      ; Display units digit in row 3 col 1
0EB6: 7E      	      ld    A, (HL)
0EB7: E60F    	      and   A, 0x0F
0EB9: C630    	      add   A, 0x30
0EBB: 325160  	      ld    (staging_row3+1), A
              	
              	      ; Handle button presses
0EBE: 3A5D60  	      ld    A, (btn_state)
              	
0EC1: CB5F    	      bit   BTN_ESC_BIT, A
0EC3: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to hours adjust
0EC5: E5      	      push  HL
              	
0EC6: 215C60  	      ld    HL, btn_ack             ; Ack the button
0EC9: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
0ECB: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_HOURS_MSG
0ECC: F5      	      push  AF
              	
0ECD: 3E03    	      ld    A, CONFIGR_HOURS_MSG
0ECF: 328060  	      ld    (configr_state), A
              	
0ED2: F1      	      pop   AF
              	
0ED3: C9      	      ret
              	
0ED4:         	test_enter_btn
0ED4: CB57    	      bit   BTN_ENT_BIT, A
0ED6: 280F    	      jr    Z, test_updn_btn
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to apply time
0ED8: E5      	      push  HL
              	
0ED9: 215C60  	      ld    HL, btn_ack             ; Ack the button
0EDC: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
0EDE: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_APPLY_TIME
0EDF: F5      	      push  AF
              	
0EE0: 3E07    	      ld    A, CONFIGR_APPLY_TIME
0EE2: 328060  	      ld    (configr_state), A
              	
0EE5: F1      	      pop   AF
              	
0EE6: C9      	      ret
              	
0EE7:         	test_updn_btn
0EE7: 47      	      ld    B, A
0EE8: E603    	      and   A, 0x03                 ; Up or Down pressed?
0EEA: C8      	      ret   Z                       ; No if Z
              	
0EEB: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
0EEC: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
0EEE: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
0EF0: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
0EF1: E5      	      push  HL
              	
0EF2: 215C60  	      ld    HL, btn_ack             ; Ack the button
0EF5: CBC6    	      set   BTN_UP_BIT, (HL)
              	
0EF7: E1      	      pop   HL
0EF8: 1808    	      jr    store
              	
0EFA:         	down_button
0EFA: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
0EFB: E5      	      push  HL
              	
0EFC: 215C60  	      ld    HL, btn_ack             ; Ack the button
0EFF: CBCE    	      set   BTN_DN_BIT, (HL)
              	
0F01: E1      	      pop   HL
              	
0F02:         	store
0F02: 27      	      daa                           ; Format new value for BCD
0F03: 77      	      ld    (HL), A                 ; Store new value back
              	
0F04: FE60    	      cp    A, 0x60                 ; New value overflowed to 60?
0F06: 2003    	      jr    NZ, cp_99
0F08: 3600    	      ld    (HL), 0                 ; Yes, reset to 0
              	
0F0A: C9      	      ret
              	
0F0B:         	cp_99
0F0B: FE99    	      cp    A, 0x99                 ; New value underflowed to 99?
0F0D: C0      	      ret   NZ
0F0E: 3659    	      ld    (HL), 0x59              ; Yes, reset to 59
              	
0F10: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 07 -------------------------------------------------------
              	;     The adjusted hours and minutes values are written to the RTC
              	;     registers to apply the new time.
0F11:         	configr_apply_time
              	      rtc_update_lock
0F11: F5      	      push  AF
              	
0F12: 3E0E    	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
0F14: D31E    	      out   (RTC_CTRL), A
              	
0F16: F1      	      pop   AF
              	
0F17: AF      	      xor   A, A                    ; Seconds are always reset to 0
0F18: D310    	      out   (RTC_SEC), A
              	
0F1A: 3A8260  	      ld    A, (configr_rtc_min)
0F1D: D312    	      out   (RTC_MIN), A
0F1F: 3A8360  	      ld    A, (configr_rtc_hrs)
0F22: D314    	      out   (RTC_HRS), A
              	
              	      rtc_update_unlock
0F24: F5      	      push  AF
              	
0F25: 3E06    	      ld    A, RTC_CTRL_CFG
0F27: D31E    	      out   (RTC_CTRL), A
              	
0F29: F1      	      pop   AF
              	
              	      ; Restart app after applying new time
              	      set_state configr_state, CONFIGR_APP_START
0F2A: F5      	      push  AF
              	
0F2B: 3E00    	      ld    A, CONFIGR_APP_START
0F2D: 328060  	      ld    (configr_state), A
              	
0F30: F1      	      pop   AF
              	
0F31: C9      	      ret
              	
              	;---- State 08 -------------------------------------------------------
              	;     Adjust the date.
              	;
              	;     The year, month, day and day of week registers of the RTC are
              	;     copied to RAM so they can be adjusted independently, and then
              	;     applied at the end.
              	;
              	;     Falls through to next state.
0F32:         	configr_adjust_date
              	      rtc_update_lock
0F32: F5      	      push  AF
              	
0F33: 3E0E    	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
0F35: D31E    	      out   (RTC_CTRL), A
              	
0F37: F1      	      pop   AF
              	
0F38: DB16    	      in    A, (RTC_DAY)
0F3A: 328460  	      ld    (configr_rtc_day), A
0F3D: DB18    	      in    A, (RTC_DOW)
0F3F: 328560  	      ld    (configr_rtc_dow), A
0F42: DB19    	      in    A, (RTC_MON)
0F44: 328660  	      ld    (configr_rtc_mon), A
0F47: DB1A    	      in    A, (RTC_YEAR)
0F49: 328760  	      ld    (configr_rtc_year), A
              	
              	      rtc_update_unlock
0F4C: F5      	      push  AF
              	
0F4D: 3E06    	      ld    A, RTC_CTRL_CFG
0F4F: D31E    	      out   (RTC_CTRL), A
              	
0F51: F1      	      pop   AF
              	
0F52: 010800  	      ld    BC, 8                   ; Set title/row 1 to "DATE UTC"
0F55: 114060  	      ld    DE, staging_row1
0F58: 21E811  	      ld    HL, configr_date_utc
0F5B: CD2015  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_YEAR_MSG
0F5E: F5      	      push  AF
              	
0F5F: 3E09    	      ld    A, CONFIGR_YEAR_MSG
0F61: 328060  	      ld    (configr_state), A
              	
0F64: F1      	      pop   AF
              	
              	;---- State 09 -------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
0F65:         	configr_year_msg
0F65: 011000  	      ld    BC, 16                  ; Set row 2 to "YEAR" and clear
0F68: 114860  	      ld    DE, staging_row2        ; row 3
0F6B: 21F111  	      ld    HL, configr_set_year
0F6E: CD2015  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_YEAR
0F71: F5      	      push  AF
              	
0F72: 3E0A    	      ld    A, CONFIGR_ADJUST_YEAR
0F74: 328060  	      ld    (configr_state), A
              	
0F77: F1      	      pop   AF
              	
              	;---- State 0A -------------------------------------------------------
0F78:         	configr_adjust_year
              	#local
              	      ; Display tens digit in row 3 col 0
0F78: 218760  	      ld    HL, configr_rtc_year
0F7B: 7E      	      ld    A, (HL)
0F7C: 0F      	      rrca
0F7D: 0F      	      rrca
0F7E: 0F      	      rrca
0F7F: 0F      	      rrca
0F80: E60F    	      and   A, 0x0F
0F82: C630    	      add   A, 0x30
0F84: 325060  	      ld    (staging_row3), A
              	
              	      ; Display units digit in row 3 col 1
0F87: 7E      	      ld    A, (HL)
0F88: E60F    	      and   A, 0x0F
0F8A: C630    	      add   A, 0x30
0F8C: 325160  	      ld    (staging_row3+1), A
              	
              	      ; Handle button presses
0F8F: 3A5D60  	      ld    A, (btn_state)
              	
0F92: CB5F    	      bit   BTN_ESC_BIT, A
0F94: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to main menu
0F96: E5      	      push  HL
              	
0F97: 215C60  	      ld    HL, btn_ack             ; Ack the button
0F9A: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
0F9C: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_APP_START
0F9D: F5      	      push  AF
              	
0F9E: 3E00    	      ld    A, CONFIGR_APP_START
0FA0: 328060  	      ld    (configr_state), A
              	
0FA3: F1      	      pop   AF
              	
0FA4: C9      	      ret
              	
0FA5:         	test_enter_btn
0FA5: CB57    	      bit   BTN_ENT_BIT, A
0FA7: 280F    	      jr    Z, test_updn_btn
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to month adjust
0FA9: E5      	      push  HL
              	
0FAA: 215C60  	      ld    HL, btn_ack             ; Ack the button
0FAD: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
0FAF: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_MONTH_MSG
0FB0: F5      	      push  AF
              	
0FB1: 3E0B    	      ld    A, CONFIGR_MONTH_MSG
0FB3: 328060  	      ld    (configr_state), A
              	
0FB6: F1      	      pop   AF
              	
0FB7: C9      	      ret
              	
0FB8:         	test_updn_btn
0FB8: 47      	      ld    B, A
0FB9: E603    	      and   A, 0x03                 ; Up or Down pressed?
0FBB: C8      	      ret   Z                       ; No if Z
              	
0FBC: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
0FBD: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
0FBF: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
0FC1: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
0FC2: E5      	      push  HL
              	
0FC3: 215C60  	      ld    HL, btn_ack             ; Ack the button
0FC6: CBC6    	      set   BTN_UP_BIT, (HL)
              	
0FC8: E1      	      pop   HL
0FC9: 1808    	      jr    store
              	
0FCB:         	down_button
0FCB: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
0FCC: E5      	      push  HL
              	
0FCD: 215C60  	      ld    HL, btn_ack             ; Ack the button
0FD0: CBCE    	      set   BTN_DN_BIT, (HL)
              	
0FD2: E1      	      pop   HL
              	
0FD3:         	store
0FD3: 27      	      daa                           ; Format new value for BCD
0FD4: 77      	      ld    (HL), A                 ; Store new value back
              	
0FD5: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 0B --------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
0FD6:         	configr_month_msg
0FD6: 011000  	      ld    BC, 16                  ; Set row 2 to "MONTH" and clear
0FD9: 114860  	      ld    DE, staging_row2        ; row 3
0FDC: 21F611  	      ld    HL, configr_set_month
0FDF: CD2015  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_MONTH
0FE2: F5      	      push  AF
              	
0FE3: 3E0C    	      ld    A, CONFIGR_ADJUST_MONTH
0FE5: 328060  	      ld    (configr_state), A
              	
0FE8: F1      	      pop   AF
              	
              	;---- State 0C --------------------------------------------------------
0FE9:         	configr_adjust_month
              	#local
              	      ; Display tens digit in row 3 col 0
0FE9: 218660  	      ld    HL, configr_rtc_mon
0FEC: 7E      	      ld    A, (HL)
0FED: 0F      	      rrca
0FEE: 0F      	      rrca
0FEF: 0F      	      rrca
0FF0: 0F      	      rrca
0FF1: E60F    	      and   A, 0x0F
0FF3: C630    	      add   A, 0x30
0FF5: 325060  	      ld    (staging_row3), A
              	
              	      ; Display units digit in row 3 col 1
0FF8: 7E      	      ld    A, (HL)
0FF9: E60F    	      and   A, 0x0F
0FFB: C630    	      add   A, 0x30
0FFD: 325160  	      ld    (staging_row3+1), A
              	
              	      ; Handle button presses
1000: 3A5D60  	      ld    A, (btn_state)
              	
1003: CB5F    	      bit   BTN_ESC_BIT, A
1005: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to year adjust
1007: E5      	      push  HL
              	
1008: 215C60  	      ld    HL, btn_ack             ; Ack the button
100B: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
100D: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_YEAR_MSG
100E: F5      	      push  AF
              	
100F: 3E09    	      ld    A, CONFIGR_YEAR_MSG
1011: 328060  	      ld    (configr_state), A
              	
1014: F1      	      pop   AF
              	
1015: C9      	      ret
              	
1016:         	test_enter_btn
1016: CB57    	      bit   BTN_ENT_BIT, A
1018: 280F    	      jr    Z, test_updn_btn
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to day adjust
101A: E5      	      push  HL
              	
101B: 215C60  	      ld    HL, btn_ack             ; Ack the button
101E: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
1020: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_DAY_MSG
1021: F5      	      push  AF
              	
1022: 3E0D    	      ld    A, CONFIGR_DAY_MSG
1024: 328060  	      ld    (configr_state), A
              	
1027: F1      	      pop   AF
              	
1028: C9      	      ret
              	
1029:         	test_updn_btn
1029: 47      	      ld    B, A
102A: E603    	      and   A, 0x03                 ; Up or Down pressed?
102C: C8      	      ret   Z                       ; No if Z
              	
102D: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
102E: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
1030: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
1032: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
1033: E5      	      push  HL
              	
1034: 215C60  	      ld    HL, btn_ack             ; Ack the button
1037: CBC6    	      set   BTN_UP_BIT, (HL)
              	
1039: E1      	      pop   HL
103A: 1808    	      jr    store
              	
103C:         	down_button
103C: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
103D: E5      	      push  HL
              	
103E: 215C60  	      ld    HL, btn_ack             ; Ack the button
1041: CBCE    	      set   BTN_DN_BIT, (HL)
              	
1043: E1      	      pop   HL
              	
1044:         	store
1044: 27      	      daa                           ; Format new value for BCD
1045: 77      	      ld    (HL), A                 ; Store new value back
              	
1046: FE13    	      cp    A, 0x13                 ; New value overflowed to 13?
1048: 2003    	      jr    NZ, cp_0
104A: 3601    	      ld    (HL), 0x01              ; Yes, reset to 1
              	
104C: C9      	      ret
              	
104D:         	cp_0
104D: FE00    	      cp    A, 0                    ; New value underflowed to 0?
104F: C0      	      ret   NZ
1050: 3612    	      ld    (HL), 0x12              ; Yes, reset to 12
              	
1052: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 0D --------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
1053:         	configr_day_msg
1053: 011000  	      ld    BC, 16                  ; Set row 2 to "DAY" and clear row
1056: 114860  	      ld    DE, staging_row2        ; 3
1059: 21FC11  	      ld    HL, configr_set_day
105C: CD2015  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_DAY
105F: F5      	      push  AF
              	
1060: 3E0E    	      ld    A, CONFIGR_ADJUST_DAY
1062: 328060  	      ld    (configr_state), A
              	
1065: F1      	      pop   AF
              	
              	;---- State 0E --------------------------------------------------------
1066:         	configr_adjust_day
              	#local
              	      ; Display tens digit in row 3 col 0
1066: 218460  	      ld    HL, configr_rtc_day
1069: 7E      	      ld    A, (HL)
106A: 0F      	      rrca
106B: 0F      	      rrca
106C: 0F      	      rrca
106D: 0F      	      rrca
106E: E60F    	      and   A, 0x0F
1070: C630    	      add   A, 0x30
1072: 325060  	      ld    (staging_row3), A
              	
              	      ; Display units digit in row 3 col 1
1075: 7E      	      ld    A, (HL)
1076: E60F    	      and   A, 0x0F
1078: C630    	      add   A, 0x30
107A: 325160  	      ld    (staging_row3+1), A
              	
              	      ; Handle button presses
107D: 3A5D60  	      ld    A, (btn_state)
              	
1080: CB5F    	      bit   BTN_ESC_BIT, A
1082: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to month adjust
1084: E5      	      push  HL
              	
1085: 215C60  	      ld    HL, btn_ack             ; Ack the button
1088: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
108A: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_MONTH_MSG
108B: F5      	      push  AF
              	
108C: 3E0B    	      ld    A, CONFIGR_MONTH_MSG
108E: 328060  	      ld    (configr_state), A
              	
1091: F1      	      pop   AF
              	
1092: C9      	      ret
              	
1093:         	test_enter_btn
1093: CB57    	      bit   BTN_ENT_BIT, A
1095: 280F    	      jr    Z, test_updn_btn
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to DOW adjust
1097: E5      	      push  HL
              	
1098: 215C60  	      ld    HL, btn_ack             ; Ack the button
109B: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
109D: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_DOW_MSG
109E: F5      	      push  AF
              	
109F: 3E0F    	      ld    A, CONFIGR_DOW_MSG
10A1: 328060  	      ld    (configr_state), A
              	
10A4: F1      	      pop   AF
              	
10A5: C9      	      ret
              	
10A6:         	test_updn_btn
10A6: 47      	      ld    B, A
10A7: E603    	      and   A, 0x03                 ; Up or Down pressed?
10A9: C8      	      ret   Z                       ; No if Z
              	
10AA: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
10AB: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
10AD: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
10AF: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
10B0: E5      	      push  HL
              	
10B1: 215C60  	      ld    HL, btn_ack             ; Ack the button
10B4: CBC6    	      set   BTN_UP_BIT, (HL)
              	
10B6: E1      	      pop   HL
10B7: 1808    	      jr    store
              	
10B9:         	down_button
10B9: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
10BA: E5      	      push  HL
              	
10BB: 215C60  	      ld    HL, btn_ack             ; Ack the button
10BE: CBCE    	      set   BTN_DN_BIT, (HL)
              	
10C0: E1      	      pop   HL
              	
10C1:         	store
10C1: 27      	      daa                           ; Format new value for BCD
10C2: 77      	      ld    (HL), A                 ; Store new value back
              	
10C3: FE32    	      cp    A, 0x32                 ; New value overflowed to 32?
10C5: 2003    	      jr    NZ, cp_0
10C7: 3601    	      ld    (HL), 0x01              ; Yes, reset to 1
              	
10C9: C9      	      ret
              	
10CA:         	cp_0
10CA: FE00    	      cp    A, 0                    ; New value underflowed to 0?
10CC: C0      	      ret   NZ
10CD: 3631    	      ld    (HL), 0x31              ; Yes, reset to 31
              	
10CF: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 0F --------------------------------------------------------
              	;     Updates display row 2 to indicate which value is being adjusted.
              	;
              	;     Falls through to next state.
10D0:         	configr_dow_msg
10D0: 011000  	      ld    BC, 16                  ; Set row 2 to "WEEKDAY" and
10D3: 114860  	      ld    DE, staging_row2        ; clear row 3
10D6: 210012  	      ld    HL, configr_set_weekday
10D9: CD2015  	      call  strncpy
              	
              	      set_state configr_state, CONFIGR_ADJUST_DOW
10DC: F5      	      push  AF
              	
10DD: 3E10    	      ld    A, CONFIGR_ADJUST_DOW
10DF: 328060  	      ld    (configr_state), A
              	
10E2: F1      	      pop   AF
              	
              	;---- State 10 --------------------------------------------------------
10E3:         	configr_adjust_dow
              	#local
10E3: 3A8560  	      ld    A, (configr_rtc_dow)    ; DOW value into A
10E6: 3D      	      dec   A                       ; Decrement by 1 and mult by 4 to
10E7: 87      	      add   A, A                    ; make offset (Sun = index 0)
10E8: 87      	      add   A, A
10E9: 1600    	      ld    D, 0                    ; A into DE
10EB: 5F      	      ld    E, A
10EC: 210812  	      ld    HL, configr_day_names   ; HL = pointer to first tbl entry
10EF: 19      	      add   HL, DE                  ; Add offset to pointer
              	
10F0: 010800  	      ld    BC, 8                   ; Write day name to row 3
10F3: 115060  	      ld    DE, staging_row3
10F6: CD2015  	      call  strncpy
              	
              	      ; Handle button presses
10F9: 3A5D60  	      ld    A, (btn_state)
              	
10FC: CB5F    	      bit   BTN_ESC_BIT, A
10FE: 280F    	      jr    Z, test_enter_btn
              	
              	      ack_btn BTN_ESC_BIT           ; Escape returns to day adjust
1100: E5      	      push  HL
              	
1101: 215C60  	      ld    HL, btn_ack             ; Ack the button
1104: CBDE    	      set   BTN_ESC_BIT, (HL)
              	
1106: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_DAY_MSG
1107: F5      	      push  AF
              	
1108: 3E0D    	      ld    A, CONFIGR_DAY_MSG
110A: 328060  	      ld    (configr_state), A
              	
110D: F1      	      pop   AF
              	
110E: C9      	      ret
              	
110F:         	test_enter_btn
110F: CB57    	      bit   BTN_ENT_BIT, A
1111: 280F    	      jr    Z, test_updn_btn
              	
              	      ack_btn BTN_ENT_BIT           ; Enter proceeds to apply date
1113: E5      	      push  HL
              	
1114: 215C60  	      ld    HL, btn_ack             ; Ack the button
1117: CBD6    	      set   BTN_ENT_BIT, (HL)
              	
1119: E1      	      pop   HL
              	      set_state configr_state, CONFIGR_APPLY_DATE
111A: F5      	      push  AF
              	
111B: 3E11    	      ld    A, CONFIGR_APPLY_DATE
111D: 328060  	      ld    (configr_state), A
              	
1120: F1      	      pop   AF
              	
1121: C9      	      ret
              	
1122:         	test_updn_btn
1122: 47      	      ld    B, A
1123: E603    	      and   A, 0x03                 ; Up or Down pressed?
1125: C8      	      ret   Z                       ; No if Z
              	
1126: 218560  	      ld    HL, configr_rtc_dow
1129: 7E      	      ld    A, (HL)                 ; Hours value into A
              	
112A: CB40    	      bit   BTN_UP_BIT, B           ; Up button pressed?
112C: 280A    	      jr    Z, down_button          ; No if Z, must be Down button
              	
112E: 3C      	      inc   A                       ; Increment on Up button
              	      ack_btn BTN_UP_BIT
112F: E5      	      push  HL
              	
1130: 215C60  	      ld    HL, btn_ack             ; Ack the button
1133: CBC6    	      set   BTN_UP_BIT, (HL)
              	
1135: E1      	      pop   HL
1136: 1808    	      jr    store
              	
1138:         	down_button
1138: 3D      	      dec   A                       ; Decrement on Down button
              	      ack_btn BTN_DN_BIT
1139: E5      	      push  HL
              	
113A: 215C60  	      ld    HL, btn_ack             ; Ack the button
113D: CBCE    	      set   BTN_DN_BIT, (HL)
              	
113F: E1      	      pop   HL
              	
1140:         	store
1140: 27      	      daa                           ; Format new value for BCD
1141: 77      	      ld    (HL), A                 ; Store new value back
              	
1142: FE08    	      cp    A, 0x08                 ; New value overflowed to 8?
1144: 2003    	      jr    NZ, cp_0
1146: 3601    	      ld    (HL), 0x01              ; Yes, reset to 1
              	
1148: C9      	      ret
              	
1149:         	cp_0
1149: FE00    	      cp    A, 0                    ; New value underflowed to 0?
114B: C0      	      ret   NZ
114C: 3607    	      ld    (HL), 0x07              ; Yes, reset to 7
              	
114E: C9      	      ret
              	
              	#endlocal
              	
              	;---- State 11 --------------------------------------------------------
              	;     The adjusted year, month, day and day of week values are written
              	;     to the RTC registers to apply the new date.
114F:         	configr_apply_date
              	      rtc_update_lock
114F: F5      	      push  AF
              	
1150: 3E0E    	      ld    A, RTC_CTRL_UTI | RTC_CTRL_CFG
1152: D31E    	      out   (RTC_CTRL), A
              	
1154: F1      	      pop   AF
              	
1155: 3A8460  	      ld    A, (configr_rtc_day)
1158: D316    	      out   (RTC_DAY), A
115A: 3A8560  	      ld    A, (configr_rtc_dow)
115D: D318    	      out   (RTC_DOW), A
115F: 3A8660  	      ld    A, (configr_rtc_mon)
1162: D319    	      out   (RTC_MON), A
1164: 3A8760  	      ld    A, (configr_rtc_year)
1167: D31A    	      out   (RTC_YEAR), A
              	
              	      rtc_update_unlock
1169: F5      	      push  AF
              	
116A: 3E06    	      ld    A, RTC_CTRL_CFG
116C: D31E    	      out   (RTC_CTRL), A
              	
116E: F1      	      pop   AF
              	
              	      ; Restart app after applying new date
              	      set_state configr_state, CONFIGR_APP_START
116F: F5      	      push  AF
              	
1170: 3E00    	      ld    A, CONFIGR_APP_START
1172: 328060  	      ld    (configr_state), A
              	
1175: F1      	      pop   AF
              	
1176: C9      	      ret
              	
              	;---- State 12 -------------------------------------------------------
              	;     Exit the config app by releasing the foreground mutex.
1177:         	configr_exit_app
              	      set_state configr_state, CONFIGR_APP_START
1177: F5      	      push  AF
              	
1178: 3E00    	      ld    A, CONFIGR_APP_START
117A: 328060  	      ld    (configr_state), A
              	
117D: F1      	      pop   AF
              	      mtx_unlock foreground_mtx
117E: F5      	      push  AF
117F: E5      	      push  HL
              	
1180: ED57    	      ld    A, I                    ; IFF2 to P/V flag
1182: F5      	      push  AF                      ; Save flags
1183: F3      	      di                            ; Ensure interrupts disabled
              	
1184: AF      	      xor   A, A                    ; Load zero to unlock the mutex
1185: 320060  	      ld    (foreground_mtx), A
              	
1188: E1      	      pop   HL                      ; F into L
1189: CB55    	      bit   2, L                    ; Test IFF2 flag
118B: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
118D: FB      	      ei                            ; Re-enable interrupts
              	
118E: E1      	      pop   HL                      ; Done
118F: F1      	      pop   AF
              	
1190: C9      	      ret
              	
              	; State machine jump table
1191: 4A0D    	configr_jp_tbl          .dw   configr_app_start
1193: 840D    	                        .dw   configr_main_menu
1195: EC0D    	                        .dw   configr_adjust_time
1197: 170E    	                        .dw   configr_hours_msg
1199: 2A0E    	                        .dw   configr_adjust_hours
119B: 940E    	                        .dw   configr_minutes_msg
119D: A70E    	                        .dw   configr_adjust_mins
119F: 110F    	                        .dw   configr_apply_time
11A1: 320F    	                        .dw   configr_adjust_date
11A3: 650F    	                        .dw   configr_year_msg
11A5: 780F    	                        .dw   configr_adjust_year
11A7: D60F    	                        .dw   configr_month_msg
11A9: E90F    	                        .dw   configr_adjust_month
11AB: 5310    	                        .dw   configr_day_msg
11AD: 6610    	                        .dw   configr_adjust_day
11AF: D010    	                        .dw   configr_dow_msg
11B1: E310    	                        .dw   configr_adjust_dow
11B3: 4F11    	                        .dw   configr_apply_date
11B5: 7711    	                        .dw   configr_exit_app
              	
11B7: 434F4E46	configr_title           .text "CONFIGR", 0
11BB: 49475200	
11BF: 53455420	configr_menu_set_time   .text "SET TIME", 0
11C3: 54494D45	
11C7: 00      	
11C8: 53455420	configr_menu_set_date   .text "SET DATE", 0
11CC: 44415445	
11D0: 00      	
11D1: 54494D45	configr_time_utc        .text "TIME UTC", 0
11D5: 20555443	
11D9: 00      	
11DA: 484F5552	configr_set_hours       .text "HOURS", 0
11DE: 5300    	
11E0: 4D494E55	configr_set_minutes     .text "MINUTES", 0
11E4: 54455300	
11E8: 44415445	configr_date_utc        .text "DATE UTC", 0
11EC: 20555443	
11F0: 00      	
11F1: 59454152	configr_set_year        .text "YEAR", 0
11F5: 00      	
11F6: 4D4F4E54	configr_set_month       .text "MONTH", 0
11FA: 4800    	
11FC: 44415900	configr_set_day         .text "DAY", 0
1200: 5745454B	configr_set_weekday     .text "WEEKDAY", 0
1204: 44415900	
              	
1208: 53554E00	configr_day_names       .text "SUN", 0    ; Keep day names contiguous
120C: 4D4F4E00	                        .text "MON", 0
1210: 54554500	                        .text "TUE", 0
1214: 57454400	                        .text "WED", 0
1218: 54485500	                        .text "THU", 0
121C: 46524900	                        .text "FRI", 0
1220: 53415400	                        .text "SAT", 0
              	
              	; END configr_app.s
              	#include "ctc_isr.s"
              	#data RAM
              	#code ROM
1224: FFFFFFFF	      .align 0x100
1228: FF...   	
1300:         	ctc_ch0_isr
1300: FB      	      ei
1301: ED4D    	      reti
              	
              	
              	;---------------------------------------------------------------------
              	;     CTC Channel 1 ISR - Display refresh                            :
              	;                                                                    :
              	; Description                                                        :
              	;     Runs in real time as opposed to being shceduled as a task      :
              	;     to ensure the least amount of jitter for display refreshing.   :
              	;                                                                    :
              	;     On each iteration of this ISR the working row is incremented,  :
              	;     and the character data is loaded from the character ROM and    :
              	;     shifted into the display driver shift registers.               :
              	;                                                                    :
              	;     External tasks are responsible for loading the display row     :
              	;     buffers with the data that is to be displayed.                 :
              	;---------------------------------------------------------------------
              	#data RAM
6088: 00      	disp_cur_row            .db 0       ; Current row being displayed
6089: 00      	disp_dim_ctr            .db 0       ; Display dimming counter
608A: 00      	disp_dim                .db 0       ; 0 = bright, 1 = dim
              	
              	#code ROM
1303: FFFFFFFF	      .align 0x80
1307: FF...   	
1380:         	ctc_ch1_isr
              	#local
1380: 08      	      ex    AF, AF'
1381: D9      	      exx
              	
              	;---- First thing to do is to determine the current row being worked
              	;     on. At boot, memory is zeroised, so incrementing early means
              	;     row 1 is the starting row. Each iteration the counter is inc'd
              	;     and once it reaches 4 it is reset back to 1 directly.
              	;
              	;     Also increment the display dimming row counter. The LSb of this
              	;     is used to determine if the current working row should be on or
              	;     off while dimming is active.
              	
1382: 218860  	      ld    HL, disp_cur_row        ; Increment row counter
1385: 34      	      inc   (HL)
1386: 7E      	      ld    A, (HL)
1387: FE04    	      cp    A, 4                    ; If at row 4, go back to 1
1389: 2007    	      jr    NZ, row_offset
              	
138B: 3E01    	      ld    A, 1                    ; Reset row counter to 1
138D: 77      	      ld    (HL), A
              	
138E: 218960  	      ld    HL, disp_dim_ctr        ; Increment dimming counter each
1391: 34      	      inc   (HL)                    ; time 3 rows have been displayed.
              	                                    ; This will result in a 50% duty
              	                                    ; cycle.
              	
              	;---- Once the working row is determined, the next step is to compute
              	;     an offset for the address where that rows buffer is located in
              	;     RAM. Start by loading the address of row 1's buffer, and then
              	;     subtract 1 from the current row counter. Each row is then some
              	;     multiple of 8 from that address.
              	;
              	;     Due to the layout of the display driver shift registers, the row
              	;     is iterated in reverse, from last character to first.
              	;
              	;     At the same time, compute a pointer to the dot point buffer for
              	;     the working row.
              	;
              	;     And finally, the buffer offset is added to a pointer for the row
              	;     data buffer.
              	
1392:         	row_offset
1392: 213860  	      ld    HL, display_dp1         ; Ptr to DP buffer for this row
              	
1395: 3D      	      dec   A                       ; Decrement row counter by 1
1396: 2807    	      jr    Z, row_offset_add       ; If row ctr == 0, skip offset adj
              	
1398: 47      	      ld    B, A                    ; Row counter becomes loop counter
1399: 3E04    	      ld    A, 4                    ; Offset start value
              	
139B:         	shift_offset
139B: 87      	      add   A, A                    ; Double for each row to offset
139C: 23      	      inc   HL                      ; Inc DP ptr for each row
139D: 10FC    	      djnz  shift_offset
              	
139F:         	row_offset_add
139F: E5      	      push  HL                      ; Save DP ptr for later
              	
13A0: 212760  	      ld    HL, display_row1+7      ; HL = pointer to row buffer.
              	                                    ; +7 to load data backwards.
13A3: 1600    	      ld    D, 0                    ; DE = row multiple offset
13A5: 5F      	      ld    E, A
13A6: 19      	      add   HL, DE                  ; Add row offset to pointer
              	
              	;---- The outer loop iterates over each of the 8 columns on the row.
              	;     The row buffer pointer points to the character to be displayed,
              	;     and is decremented each iteration to work backwards to the first
              	;     character of the row.
              	;
              	;     A pointer to the character ROM is computed and used by the
              	;     inner loop. Since each character on the display uses 2 bytes of
              	;     data to control 16 segments, the character value is doubled and
              	;     then added as an offset to the base addr of the character ROM.
              	
13A7: 0E20    	      ld    C, DISP_DATA            ; Display data shift register addr
13A9: 0608    	      ld    B, 8                    ; Outer loop - chars per row
              	
13AB:         	next_row_char
13AB: 1600    	      ld    D, 0                    ; DE = char value to display
13AD: 5E      	      ld    E, (HL)
13AE: EB      	      ex    DE, HL                  ; Each char ROM entry is 2 bytes
13AF: 29      	      add   HL, HL                  ; (16 segments), so double DE to
13B0: EB      	      ex    DE, HL                  ; make offset.
              	
13B1: E5      	      push  HL                      ; HL = ptr to row buf pos
              	
13B2: 2100E0  	      ld    HL, CHAR_ROM_BASE       ; HL = char ROM base addr
13B5: 19      	      add   HL, DE                  ; Add DE for char offset in ROM
              	
13B6: C5      	      push  BC                      ; BC contains outer loop counter
              	
13B7: 0602    	      ld    B, 2                    ; Inner loop - 2 chars from ROM
              	
13B9: EDB3    	      otir                          ; xfer char data
              	                                    ; 18 clocks between bytes
              	
13BB: C1      	      pop   BC                      ; Restore outer loop counter
13BC: E1      	      pop   HL                      ; Restore pointer to row buf
13BD: 2B      	      dec   HL                      ; Move to "next" row buffer pos
              	
13BE: 10EB    	      djnz  next_row_char
              	
              	;---- Finally, the dot points are loaded and shifted, and then the row
              	;     counter is written to an output register of the display driver
              	;     board, which also serves to latch in the data to drive that row.
              	
13C0: E1      	      pop   HL                      ; Restore DP ptr
13C1: 7E      	      ld    A, (HL)                 ; Load DP byte from buffer
13C2: 2F      	      cpl                           ; Invert for drivers that sink
13C3: ED79    	      out   (C), A
              	
              	;---- If the row is to be turned off while dimming is enabled, write
              	;     row 0 instead of the working row number to the display control
              	;     register.
              	;
              	;     Dimming is enabled by storing some number of 1's in the least
              	;     significant bit positions of the disp_dim variable. This value
              	;     is then ANDed with disp_dim_ctr, and when the Z flag is set, the
              	;     row will be enabled. This allows for a configurable duty cycle
              	;     down to some small fraction, but realistically, 2 levels of
              	;     dimming to be provided: 50% and 25% d/c
              	
13C5: 218960  	      ld    HL, disp_dim_ctr        ; Is the display being dimmed?
13C8: 3A8A60  	      ld    A, (disp_dim)
13CB: A6      	      and   A, (HL)
13CC: 3A8860  	      ld    A, (disp_cur_row)       ; Default write row counter
13CF: 2801    	      jr    Z, out_disp_ctrl
              	
13D1: AF      	      xor   A, A                    ; If dimming, this row will be off
              	
13D2:         	out_disp_ctrl
13D2: D321    	      out   (DISP_CTRL), A
              	
13D4: 08      	      ex    AF, AF'
13D5: D9      	      exx
              	
13D6: FB      	      ei
13D7: ED4D    	      reti
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     CTC Channel 2 ISR - Task scheduler                             :
              	;                                                                    :
              	; Description                                                        :
              	;     Tasks that are to be run periodically (every ~10ms) will be    :
              	;     scheduled through this ISR.                                    :
              	;                                                                    :
              	;     Additionally, semaphores that permit applications to run will  :
              	;     be incremented here.                                           :
              	;                                                                    :
              	;     The processor is halted once all scheduled tasks have          :
              	;     completed, so tasks can only start at the next interrupt, and  :
              	;     only if they are scheduled here.                               :
              	;---------------------------------------------------------------------
              	#data RAM
              	#code ROM
13D9: FFFFFFFF	      .align 0x80
13DD: FF...   	
1400:         	ctc_ch2_isr
              	#local
1400: 08      	      ex    AF, AF'
1401: D9      	      exx
              	
              	      ; Schedule periodic tasks
              	      schedule_task TASK_BUTTON_RD
1402: E5      	      push  HL
              	
1403: 211160  	      ld    HL, task_sched+TASK_BUTTON_RD
1406: 3601    	      ld    (HL), TASK_BUTTON_RD
              	
1408: E1      	      pop   HL
              	      schedule_task TASK_WD_POKE
1409: E5      	      push  HL
              	
140A: 211260  	      ld    HL, task_sched+TASK_WD_POKE
140D: 3602    	      ld    (HL), TASK_WD_POKE
              	
140F: E1      	      pop   HL
              	      schedule_task TASK_DISPLAY
1410: E5      	      push  HL
              	
1411: 211560  	      ld    HL, task_sched+TASK_DISPLAY
1414: 3605    	      ld    (HL), TASK_DISPLAY
              	
1416: E1      	      pop   HL
              	
              	      ; Increment semaphores to allow apps to run, but only where an
              	      ; app owns the foreground mutex. It is important that apps only
              	      ; run once per ~10ms to allow button acknowledges to be applied
              	      ; and reduce erratic behaviour.
1417:         	clock_sem
              	      mtx_owned foreground_mtx, APP_CLOCK
1417: E5      	      push  HL
              	
1418: ED57    	      ld    A, I                    ; IFF2 to P/V flag
141A: F5      	      push  AF                      ; Save flags
141B: F3      	      di                            ; Ensure interrupts disabled
              	
141C: 3A0060  	      ld    A, (foreground_mtx)             ; Compare the value stored in
141F: FE03    	      cp    A, APP_CLOCK            ; (mutex) with task_num.
1421: 2801    	      jr    Z, $+3
              	
1423: AF      	      xor   A, A                    ; Not equal, return 0
              	
1424: E1      	      pop   HL                      ; F into L
1425: CB55    	      bit   2, L                    ; Test IFF2 flag
1427: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
1429: FB      	      ei                            ; Re-enable interrupts
              	
142A: E1      	      pop   HL                      ; Done
              	
142B: B7      	      or    A, A
142C: 2812    	      jr    Z, configr_sem
              	      sem_post clock_app_sem
142E: F5      	      push  AF
142F: E5      	      push  HL
              	
1430: ED57    	      ld    A, I                    ; IFF2 to P/V flag
1432: F5      	      push  AF                      ; Save flags
1433: F3      	      di                            ; Ensure interrupts disabled
              	
1434: 210160  	      ld    HL, clock_app_sem
1437: 34      	      inc   (HL)
              	
1438: E1      	      pop   HL                      ; F into L
1439: CB55    	      bit   2, L                    ; Test IFF2 flag
143B: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
143D: FB      	      ei                            ; Re-enable interrupts
              	
143E: E1      	      pop   HL
143F: F1      	      pop   AF
              	
1440:         	configr_sem
              	      mtx_owned foreground_mtx, APP_CONFIGR
1440: E5      	      push  HL
              	
1441: ED57    	      ld    A, I                    ; IFF2 to P/V flag
1443: F5      	      push  AF                      ; Save flags
1444: F3      	      di                            ; Ensure interrupts disabled
              	
1445: 3A0060  	      ld    A, (foreground_mtx)             ; Compare the value stored in
1448: FE04    	      cp    A, APP_CONFIGR            ; (mutex) with task_num.
144A: 2801    	      jr    Z, $+3
              	
144C: AF      	      xor   A, A                    ; Not equal, return 0
              	
144D: E1      	      pop   HL                      ; F into L
144E: CB55    	      bit   2, L                    ; Test IFF2 flag
1450: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
1452: FB      	      ei                            ; Re-enable interrupts
              	
1453: E1      	      pop   HL                      ; Done
              	
1454: B7      	      or    A, A
1455: 2812    	      jr    Z, done
              	      sem_post configr_app_sem
1457: F5      	      push  AF
1458: E5      	      push  HL
              	
1459: ED57    	      ld    A, I                    ; IFF2 to P/V flag
145B: F5      	      push  AF                      ; Save flags
145C: F3      	      di                            ; Ensure interrupts disabled
              	
145D: 210260  	      ld    HL, configr_app_sem
1460: 34      	      inc   (HL)
              	
1461: E1      	      pop   HL                      ; F into L
1462: CB55    	      bit   2, L                    ; Test IFF2 flag
1464: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
1466: FB      	      ei                            ; Re-enable interrupts
              	
1467: E1      	      pop   HL
1468: F1      	      pop   AF
              	
1469:         	done
1469: 08      	      ex    AF, AF'
146A: D9      	      exx
              	
146B: FB      	      ei
146C: ED4D    	      reti
              	#endlocal
              	
              	;---------------------------------------------------------------------
              	;     CTC Channel 3 ISR - Clock display refresh scheduler            :
              	;                                                                    :
              	; Description                                                        :
              	;     The RTC is configured to generate an alarm once per minute     :
              	;     by asserting its INT/ output. This output is connected to      :
              	;     channel 3 of the CTC to provide a vectored interrupt for the   :
              	;     RTC alarm.                                                     :
              	;                                                                    :
              	;                                                                    :
              	;---------------------------------------------------------------------
              	#data RAM
              	#code ROM
146E: FFFFFFFF	      .align 0x80
1472: FF...   	
1480:         	ctc_ch3_isr
              	#local
1480: 08      	      ex    AF, AF'
1481: D9      	      exx
              	
              	;---- Before the clock_upd_sem can be incremented, such an update must
              	;     have been requested by the clock app. This prevents the
              	;     semaphore being incremented while not in the clock app.
              	;
              	;     Initially when the clock app starts it will read the time from
              	;     the RTC and use that to configure the display immediately. It
              	;     will then increment the clock_upd_req_sem semaphore, and wait
              	;     for the clock_upd_sem semaphore to be updated in turn.
              	      sem_trywait clock_upd_req_sem
1482: E5      	      push  HL
              	
1483: ED57    	      ld    A, I                    ; IFF2 to P/V flag
1485: F5      	      push  AF                      ; Save flags
1486: F3      	      di                            ; Ensure interrupts disabled
              	
1487: 210360  	      ld    HL, clock_upd_req_sem
148A: 7E      	      ld    A, (HL)                 ; Load semaphore value for return
148B: B7      	      or    A, A                    ; Semaphore value greater than 0?
148C: 2801    	      jr    Z, $+3                  ; If Z, return 0, go to done
              	
148E: 35      	      dec   (HL)                    ; Decrement semaphore
              	
148F: E1      	      pop   HL                      ; F into L
1490: CB55    	      bit   2, L                    ; Test IFF2 flag
1492: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
1494: FB      	      ei                            ; Re-enable interrupts
              	
1495: E1      	      pop   HL                      ; Done
              	
1496: B7      	      or    A, A                    ; Set Z flag according to A
1497: 2812    	      jr    Z, done
              	
              	      sem_post clock_upd_sem        ; Increment display update sem
1499: F5      	      push  AF
149A: E5      	      push  HL
              	
149B: ED57    	      ld    A, I                    ; IFF2 to P/V flag
149D: F5      	      push  AF                      ; Save flags
149E: F3      	      di                            ; Ensure interrupts disabled
              	
149F: 210460  	      ld    HL, clock_upd_sem
14A2: 34      	      inc   (HL)
              	
14A3: E1      	      pop   HL                      ; F into L
14A4: CB55    	      bit   2, L                    ; Test IFF2 flag
14A6: 2801    	      jr    Z, $+3                  ; If IFF2 was not set, go to done
14A8: FB      	      ei                            ; Re-enable interrupts
              	
14A9: E1      	      pop   HL
14AA: F1      	      pop   AF
              	
14AB:         	done
              	      ; Reconfigure things so they can happen again
14AB: DB1D    	      in    A, (RTC_FLAGS)          ; Read RTC flags to clear alarm
              	
14AD: 3EC5    	      ld    A, CTC_CH3_CFG          ; Reconfigure CTC channel to load
14AF: D303    	      out   (CTC_CH3), A            ; new time constant.
14B1: 3E01    	      ld    A, CTC_CH3_TCONST
14B3: D303    	      out   (CTC_CH3), A
              	
14B5: 08      	      ex    AF, AF'
14B6: D9      	      exx
              	
14B7: FB      	      ei
14B8: ED4D    	      reti
              	#endlocal
              	
              	; END ctc_isr.s
              	#include "c_lib.s"
              	#data RAM
              	#code ROM
              	;---------------------------------------------------------------------
              	;     memcpy                                                         :
              	;                                                                    :
              	; Description                                                        :
              	;     Copy block of memory.                                          :
              	;                                                                    :
              	;     Copies the values of BC bytes from the location pointed to by  :
              	;     HL directly to the memory block pointed to by DE.              :
              	;                                                                    :
              	; Parameters                                                         :
              	;     BC  Number of bytes to copy                                    :
              	;     DE  Pointer to the destination                                 :
              	;     HL  Pointer to the source of data to be copied                 :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;---------------------------------------------------------------------
14BA: FFFFFFFF	      .align 0x100
14BE: FF...   	
1500:         	memcpy:
1500: 78      	      ld    A, B                    ; BC == 0?
1501: B1      	      or    A, C
1502: C8      	      ret   Z                       ; Yes if Z, return
              	
1503: EDB0    	      ldir                          ; while (BC != 0) {
              	                                    ;   (DE) <- (HL);
              	                                    ;   DE++; HL++; BC--;
              	                                    ; }
1505: C9      	      ret
              	
              	
              	;---------------------------------------------------------------------
              	;     strncpy                                                        :
              	;                                                                    :
              	; Description                                                        :
              	;     Copy characters from string.                                   :
              	;                                                                    :
              	;     Copies the first BC characters from HL to DE. If the end of    :
              	;     the source string (which is signaled by a null-character) is   :
              	;     found before BC characters have been copied, DE is padded with :
              	;     zeros until a total of BC characters have been written to it.  :
              	;
              	;     No null-character is implicitly appended at the end of DE if   ;
              	;     HL is longer than BC. Thus, in this case, DE shall not be      ;
              	;     considered a null terminated string.                           ;
              	;                                                                    :
              	; Parameters                                                         :
              	;     BC  Maximum number of characters to be copied                  :
              	;     DE  Pointer to the destination                                 :
              	;     HL  String to be copied                                        :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;---------------------------------------------------------------------
1506: FFFFFFFF	      .align 0x20
150A: FF...   	
1520:         	strncpy:
              	#local
1520: 78      	      ld    A, B                    ; BC == 0?
1521: B1      	      or    A, C
1522: C8      	      ret   Z                       ; Yes if Z, return
              	
1523: 7E      	      ld    A, (HL)                 ; Load char from source
1524: B7      	      or    A, A                    ; Is it a zero?
1525: 2806    	      jr    Z, zero_fill            ; Yes if Z, zero fill from here
              	
1527: 12      	      ld    (DE), A                 ; No, store char to dest
              	
1528: 0B      	      dec   BC                      ; Dec byte count
1529: 13      	      inc   DE                      ; Inc dest pointer
152A: 23      	      inc   HL                      ; Inc source pointer
              	
152B: 18F3    	      jr    strncpy                 ; Next char
              	
152D:         	zero_fill:
152D: AF      	      xor   A, A                    ; Store 0 into DE
152E: 12      	      ld    (DE), A
              	
152F: 0B      	      dec   BC                      ; Dec byte count
1530: 13      	      inc   DE                      ; Inc dest pointer
              	
1531: 78      	      ld    A, B                    ; BC == 0?
1532: B1      	      or    A, C
1533: 20F8    	      jr    NZ, zero_fill           ; No if NZ, fill next char
              	
1535: C9      	      ret
              	#endlocal
              	
              	
              	;---------------------------------------------------------------------
              	;     memset                                                         :
              	;                                                                    :
              	; Description                                                        :
              	;     Fill block of memory.                                          :
              	;                                                                    :
              	;     Sets the first BC bytes of the block of memory pointed by HL   :
              	;     to the specified value in A.                                   :
              	;                                                                    :
              	; Parameters                                                         :
              	;     A   Value to be set                                            :
              	;     BC  Number of bytes to be set to the value of A                :
              	;     HL  Pointer to the block of memory to fill                     :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;                                                                    :
              	; Destroys                                                           :
              	;     D                                                              :
              	;---------------------------------------------------------------------
1536: FFFFFFFF	      .align 0x20
153A: FF...   	
1540:         	memset:
              	#local
1540: 57      	      ld    D, A
              	
1541:         	next:
1541: 78      	      ld    A, B                    ; BC == 0?
1542: B1      	      or    A, C
1543: C8      	      ret   Z                       ; Yes if Z, return
              	
1544: 72      	      ld    (HL), D                 ; Set
              	
1545: 0B      	      dec   BC                      ; Dec byte count
1546: 23      	      inc   HL                      ; Inc dest pointer
              	
1547: 18F8    	      jr    next
              	#endlocal
              	
              	; END c_lib.s
              	
              	
              	      .end


; +++ segments +++

#CODE ROM           = $0000 =     0,  size = $5F00 = 24320
#CODE _INITIALIZER  = $5F00 = 24320,  size = $0100 =   256
#DATA RAM           = $6000 = 24576,  size = $1F00 =  7936
#DATA _INITIALIZED  = $7F00 = 32512,  size = $0100 =   256

; +++ global symbols +++

APP_CLOCK           = $0003 =     3               clock.inc:83
APP_CONFIGR         = $0004 =     4               clock.inc:84
BTN_ALL             = $000F =    15               clock.inc:31
BTN_DN              = $0002 =     2               clock.inc:28 (unused)
BTN_DN_BIT          = $0001 =     1               clock.inc:36
BTN_ENT             = $0004 =     4               clock.inc:29 (unused)
BTN_ENT_BIT         = $0002 =     2               clock.inc:37
BTN_ESC             = $0008 =     8               clock.inc:30
BTN_ESC_BIT         = $0003 =     3               clock.inc:38
BTN_REG             = $0008 =     8               clock.inc:25
BTN_UP              = $0001 =     1               clock.inc:27 (unused)
BTN_UP_BIT          = $0000 =     0               clock.inc:35
CHAR_ROM_BASE       = $E000 = 57344               platform.inc:30
CHAR_ROM_SZ         = $2000 =  8192               platform.inc:31 (unused)
CLOCK_APP_START     = $0000 =     0  ROM          clock_app.s:18
CLOCK_EXIT          = $0003 =     3  ROM          clock_app.s:21
CLOCK_IDLE          = $0002 =     2  ROM          clock_app.s:20
CLOCK_UPDATE        = $0001 =     1  ROM          clock_app.s:19
CONFIGR_ADJUST_DATE = $0008 =     8  ROM          configr_app.s:25
CONFIGR_ADJUST_DAY  = $000E =    14  ROM          configr_app.s:31
CONFIGR_ADJUST_DOW  = $0010 =    16  ROM          configr_app.s:33
CONFIGR_ADJUST_HOURS = $0004 =     4  ROM          configr_app.s:21
CONFIGR_ADJUST_MINS = $0006 =     6  ROM          configr_app.s:23
CONFIGR_ADJUST_MONTH = $000C =    12  ROM          configr_app.s:29
CONFIGR_ADJUST_TIME = $0002 =     2  ROM          configr_app.s:19
CONFIGR_ADJUST_YEAR = $000A =    10  ROM          configr_app.s:27
CONFIGR_APPLY_DATE  = $0011 =    17  ROM          configr_app.s:34
CONFIGR_APPLY_TIME  = $0007 =     7  ROM          configr_app.s:24
CONFIGR_APP_START   = $0000 =     0  ROM          configr_app.s:17
CONFIGR_DAY_MSG     = $000D =    13  ROM          configr_app.s:30
CONFIGR_DOW_MSG     = $000F =    15  ROM          configr_app.s:32
CONFIGR_EXIT        = $0012 =    18  ROM          configr_app.s:35
CONFIGR_HOURS_MSG   = $0003 =     3  ROM          configr_app.s:20
CONFIGR_MAIN_MENU   = $0001 =     1  ROM          configr_app.s:18
CONFIGR_MINUTES_MSG = $0005 =     5  ROM          configr_app.s:22
CONFIGR_MONTH_MSG   = $000B =    11  ROM          configr_app.s:28
CONFIGR_YEAR_MSG    = $0009 =     9  ROM          configr_app.s:26
CTC_CH0             = $0000 =     0               clock.inc:6
CTC_CH0_CFG         = $0001 =     1               clock.inc:12 (unused)
CTC_CH1             = $0001 =     1               clock.inc:7
CTC_CH1_CFG         = $00A5 =   165               clock.inc:13
CTC_CH1_TCONST      = $0017 =    23               clock.inc:17
CTC_CH2             = $0002 =     2               clock.inc:8
CTC_CH2_CFG         = $00A5 =   165               clock.inc:14
CTC_CH2_TCONST      = $00EA =   234               clock.inc:18
CTC_CH3             = $0003 =     3               clock.inc:9
CTC_CH3_CFG         = $00C5 =   197               clock.inc:15
CTC_CH3_TCONST      = $0001 =     1               clock.inc:19
CTC_CTL_CLKTRG_ST   = $0008 =     8               ctc.inc:4 (unused)
CTC_CTL_CTR_MODE    = $0040 =    64               ctc.inc:7
CTC_CTL_INT_EN      = $0080 =   128               ctc.inc:8
CTC_CTL_PS_256      = $0020 =    32               ctc.inc:6
CTC_CTL_RISE        = $0010 =    16               ctc.inc:5 (unused)
CTC_CTL_SW_RESET    = $0002 =     2               ctc.inc:2 (unused)
CTC_CTL_TCONST      = $0004 =     4               ctc.inc:3
CTC_CTL_WORD        = $0001 =     1               ctc.inc:1
DEBUG_PORT          = $00DE =   222               clock.inc:90
DIMM_ROW            = $0030 =    48               clock.inc:32
DIMM_ROW_SW0        = $0004 =     4               clock.inc:39 (unused)
DIMM_ROW_SW1        = $0004 =     4               clock.inc:40 (unused)
DISP_CTRL           = $0021 =    33               clock.inc:71
DISP_DATA           = $0020 =    32               clock.inc:70
DUTY_CYCLE          = $0040 =    64               clock.inc:33 (unused)
DUTY_CYCLE_BIT      = $0006 =     6               clock.inc:41
FCTC                = $8000 =4096000               platform.inc:8 (unused)
FSYS                = $8D80 =6000000               platform.inc:7
FUART               = $8000 =7372800               platform.inc:9 (unused)
OUTPUT_REG          = $000C =    12               clock.inc:45 (unused)
RAM                 = $6000 = 24576  RAM          platform.inc:4 (unused)
RAM_BASE            = $6000 = 24576               platform.inc:23
RAM_SZ              = $2000 =  8192               platform.inc:24
RAM_end             = $7F00 = 32512  RAM          platform.inc:4
RAM_size            = $1F00 =  7936  RAM          platform.inc:4
ROM                 = $0000 =     0  ROM          platform.inc:6 (unused)
ROM_BASE            = $0000 =     0               platform.inc:20
ROM_SZ              = $6000 = 24576               platform.inc:21
ROM_end             = $5F00 = 24320  ROM          platform.inc:6 (unused)
ROM_size            = $5F00 = 24320  ROM          platform.inc:6 (unused)
RTC_ALM_ALM0        = $0040 =    64               rtc.inc:1
RTC_ALM_ALM1        = $0080 =   128               rtc.inc:2
RTC_ALM_CFG         = $00C0 =   192               clock.inc:64
RTC_CTRL            = $001E =    30               clock.inc:62
RTC_CTRL_24HR       = $0002 =     2               rtc.inc:41
RTC_CTRL_CFG        = $0006 =     6               clock.inc:67
RTC_CTRL_DSE        = $0001 =     1               rtc.inc:40 (unused)
RTC_CTRL_RUN_BAT    = $0004 =     4               rtc.inc:42
RTC_CTRL_UTI        = $0008 =     8               rtc.inc:43
RTC_DAY             = $0016 =    22               clock.inc:54
RTC_DAY_ALM         = $0017 =    23               clock.inc:55
RTC_DOW             = $0018 =    24               clock.inc:56
RTC_FLAGS           = $001D =    29               clock.inc:61
RTC_FLAG_AF         = $0008 =     8               rtc.inc:38 (unused)
RTC_FLAG_BVF        = $0001 =     1               rtc.inc:35 (unused)
RTC_FLAG_PF         = $0004 =     4               rtc.inc:37 (unused)
RTC_FLAG_PWRF       = $0002 =     2               rtc.inc:36 (unused)
RTC_HRS             = $0014 =    20               clock.inc:52
RTC_HRS_ALM         = $0015 =    21               clock.inc:53
RTC_INTS            = $001C =    28               clock.inc:60
RTC_INTS_CFG        = $0008 =     8               clock.inc:66
RTC_INT_ABE         = $0001 =     1               rtc.inc:30 (unused)
RTC_INT_AIE         = $0008 =     8               rtc.inc:33
RTC_INT_PIE         = $0004 =     4               rtc.inc:32 (unused)
RTC_INT_PWRIE       = $0002 =     2               rtc.inc:31 (unused)
RTC_MIN             = $0012 =    18               clock.inc:50
RTC_MIN_ALM         = $0013 =    19               clock.inc:51
RTC_MON             = $0019 =    25               clock.inc:57
RTC_RATES           = $001B =    27               clock.inc:59
RTC_RATES_CFG       = $0000 =     0               clock.inc:65
RTC_RS_122_070US    = $0030 =    48               rtc.inc:7 (unused)
RTC_RS_125MS        = $00D0 =   208               rtc.inc:17 (unused)
RTC_RS_15_625MS     = $00A0 =   160               rtc.inc:14 (unused)
RTC_RS_1_95315MS    = $0070 =   112               rtc.inc:11 (unused)
RTC_RS_244_141US    = $0040 =    64               rtc.inc:8 (unused)
RTC_RS_250MS        = $00E0 =   224               rtc.inc:18 (unused)
RTC_RS_30_5175US    = $0010 =    16               rtc.inc:5 (unused)
RTC_RS_31_25MS      = $00B0 =   176               rtc.inc:15 (unused)
RTC_RS_3_90625MS    = $0080 =   128               rtc.inc:12 (unused)
RTC_RS_488_281US    = $0050 =    80               rtc.inc:9 (unused)
RTC_RS_500MS        = $00F0 =   240               rtc.inc:19 (unused)
RTC_RS_61_035US     = $0020 =    32               rtc.inc:6 (unused)
RTC_RS_62_5MS       = $00C0 =   192               rtc.inc:16 (unused)
RTC_RS_7_8125MS     = $0090 =   144               rtc.inc:13 (unused)
RTC_RS_976_5625US   = $0060 =    96               rtc.inc:10 (unused)
RTC_RS_NONE         = $0000 =     0               rtc.inc:4
RTC_SEC             = $0010 =    16               clock.inc:48
RTC_SEC_ALM         = $0011 =    17               clock.inc:49
RTC_WD_187_5MS      = $0040 =    64               rtc.inc:25 (unused)
RTC_WD_1_5SEC       = $0000 =     0               rtc.inc:21
RTC_WD_23_4375MS    = $0010 =    16               rtc.inc:22 (unused)
RTC_WD_375MS        = $0050 =    80               rtc.inc:26 (unused)
RTC_WD_3S           = $0070 =   112               rtc.inc:28 (unused)
RTC_WD_46_875MS     = $0020 =    32               rtc.inc:23 (unused)
RTC_WD_750MS        = $0060 =    96               rtc.inc:27 (unused)
RTC_WD_93_75MS      = $0030 =    48               rtc.inc:24 (unused)
RTC_YEAR            = $001A =    26               clock.inc:58
TASK_BUTTON_RD      = $0001 =     1               clock.inc:81
TASK_DISPLAY        = $0005 =     5               clock.inc:85
TASK_WD_POKE        = $0002 =     2               clock.inc:82
TZ_ROM_BASE         = $C000 = 49152               platform.inc:27
TZ_ROM_SZ           = $2000 =  8192               platform.inc:28 (unused)
TZ_SW1_REG          = $0009 =     9               clock.inc:42
TZ_SW2_REG          = $000A =    10               clock.inc:43 (unused)
TZ_SW3_REG          = $000B =    11               clock.inc:44 (unused)
VECTOR_INT_PG       = $0001 =     1               platform.inc:36
WDT_POKE            = $0004 =     4               clock.inc:22
_INITIALIZED        = $7F00 = 32512  _INITIALIZED platform.inc:5
_INITIALIZED_end    = $8000 = 32768  _INITIALIZED platform.inc:5 (unused)
_INITIALIZED_size   = $0100 =   256  _INITIALIZED platform.inc:5 (unused)
_INITIALIZER        = $5F00 = 24320  _INITIALIZER platform.inc:7
_INITIALIZER_end    = $6000 = 24576  _INITIALIZER platform.inc:7 (unused)
_INITIALIZER_size   = $0100 =   256  _INITIALIZER platform.inc:7
bcd_to_dec          = $0CA7 =  3239  ROM          clock_app.s:1088
btn_ack             = $605C = 24668  RAM          clock.s:369
btn_debounce        = $605E = 24670  RAM          clock.s:371
btn_flags           = $605F = 24671  RAM          clock.s:372
btn_state           = $605D = 24669  RAM          clock.s:370
btn_valid           = $605B = 24667  RAM          clock.s:368
button_rd_task      = $0500 =  1280  ROM          clock.s:376
clock_app           = $0800 =  2048  ROM          clock_app.s:78
clock_app_sem       = $6001 = 24577  RAM          clock.s:233
clock_app_start     = $084D =  2125  ROM          clock_app.s:97
clock_exit_app      = $0C0A =  3082  ROM          clock_app.s:943
clock_idle          = $0BD6 =  3030  ROM          clock_app.s:921
clock_jp_tbl        = $0C24 =  3108  ROM          clock_app.s:950
clock_row           = $6074 = 24692  RAM          clock_app.s:44
clock_rtc_day       = $606A = 24682  RAM          clock_app.s:32 (unused)
clock_rtc_dow       = $606B = 24683  RAM          clock_app.s:33 (unused)
clock_rtc_hrs       = $6069 = 24681  RAM          clock_app.s:31 (unused)
clock_rtc_min       = $6068 = 24680  RAM          clock_app.s:30
clock_rtc_mon       = $606C = 24684  RAM          clock_app.s:34 (unused)
clock_rtc_year      = $606D = 24685  RAM          clock_app.s:35
clock_state         = $6064 = 24676  RAM          clock_app.s:24
clock_tz1_sw        = $6065 = 24677  RAM          clock_app.s:26
clock_tz2_sw        = $6066 = 24678  RAM          clock_app.s:27 (unused)
clock_tz3_sw        = $6067 = 24679  RAM          clock_app.s:28 (unused)
clock_tz_day        = $6070 = 24688  RAM          clock_app.s:39
clock_tz_days_in_mon = $6073 = 24691  RAM          clock_app.s:42
clock_tz_dow        = $6071 = 24689  RAM          clock_app.s:40
clock_tz_hrs        = $606F = 24687  RAM          clock_app.s:38
clock_tz_min        = $606E = 24686  RAM          clock_app.s:37
clock_tz_mon        = $6072 = 24690  RAM          clock_app.s:41
clock_upd_req_sem   = $6003 = 24579  RAM          clock.s:235
clock_upd_sem       = $6004 = 24580  RAM          clock.s:236
clock_update        = $0880 =  2176  ROM          clock_app.s:127
configr_adjust_date = $0F32 =  3890  ROM          configr_app.s:403
configr_adjust_day  = $1066 =  4198  ROM          configr_app.s:604
configr_adjust_dow  = $10E3 =  4323  ROM          configr_app.s:693
configr_adjust_hours = $0E2A =  3626  ROM          configr_app.s:204
configr_adjust_mins = $0EA7 =  3751  ROM          configr_app.s:298
configr_adjust_month = $0FE9 =  4073  ROM          configr_app.s:515
configr_adjust_time = $0DEC =  3564  ROM          configr_app.s:168
configr_adjust_year = $0F78 =  3960  ROM          configr_app.s:437
configr_app         = $0D00 =  3328  ROM          configr_app.s:53
configr_app_sem     = $6002 = 24578  RAM          clock.s:234
configr_app_start   = $0D4A =  3402  ROM          configr_app.s:69
configr_apply_date  = $114F =  4431  ROM          configr_app.s:769
configr_apply_time  = $0F11 =  3857  ROM          configr_app.s:377
configr_date_utc    = $11E8 =  4584  ROM          configr_app.s:823
configr_day_msg     = $1053 =  4179  ROM          configr_app.s:595
configr_day_names   = $1208 =  4616  ROM          configr_app.s:829
configr_dow_msg     = $10D0 =  4304  ROM          configr_app.s:684
configr_exit_app    = $1177 =  4471  ROM          configr_app.s:790
configr_hours_msg   = $0E17 =  3607  ROM          configr_app.s:190
configr_jp_tbl      = $1191 =  4497  ROM          configr_app.s:797
configr_main_menu   = $0D84 =  3460  ROM          configr_app.s:96
configr_menu_opt    = $6081 = 24705  RAM          configr_app.s:39
configr_menu_set_date = $11C8 =  4552  ROM          configr_app.s:819
configr_menu_set_time = $11BF =  4543  ROM          configr_app.s:818
configr_minutes_msg = $0E94 =  3732  ROM          configr_app.s:284
configr_month_msg   = $0FD6 =  4054  ROM          configr_app.s:506
configr_rtc_day     = $6084 = 24708  RAM          configr_app.s:43
configr_rtc_dow     = $6085 = 24709  RAM          configr_app.s:44
configr_rtc_hrs     = $6083 = 24707  RAM          configr_app.s:42
configr_rtc_min     = $6082 = 24706  RAM          configr_app.s:41
configr_rtc_mon     = $6086 = 24710  RAM          configr_app.s:45
configr_rtc_year    = $6087 = 24711  RAM          configr_app.s:46
configr_set_day     = $11FC =  4604  ROM          configr_app.s:826
configr_set_hours   = $11DA =  4570  ROM          configr_app.s:821
configr_set_minutes = $11E0 =  4576  ROM          configr_app.s:822
configr_set_month   = $11F6 =  4598  ROM          configr_app.s:825
configr_set_weekday = $1200 =  4608  ROM          configr_app.s:827
configr_set_year    = $11F1 =  4593  ROM          configr_app.s:824
configr_state       = $6080 = 24704  RAM          configr_app.s:38
configr_time_utc    = $11D1 =  4561  ROM          configr_app.s:820
configr_title       = $11B7 =  4535  ROM          configr_app.s:817
configr_year_msg    = $0F65 =  3941  ROM          configr_app.s:428
ctc_ch0_isr         = $1300 =  4864  ROM          ctc_isr.s:4
ctc_ch1_isr         = $1380 =  4992  ROM          ctc_isr.s:30
ctc_ch2_isr         = $1400 =  5120  ROM          ctc_isr.s:190
ctc_ch3_isr         = $1480 =  5248  ROM          ctc_isr.s:236
day_array_ptr       = $607B = 24699  RAM          clock_app.s:49
days_common_year    = $0C30 =  3120  ROM          clock_app.s:957
days_leap_year      = $0C40 =  3136  ROM          clock_app.s:962
disp_cur_row        = $6088 = 24712  RAM          ctc_isr.s:24
disp_dim            = $608A = 24714  RAM          ctc_isr.s:26
disp_dim_ctr        = $6089 = 24713  RAM          ctc_isr.s:25
display_ctr         = $6060 = 24672  RAM          clock.s:429
display_dp1         = $6038 = 24632  RAM          clock.s:249
display_dp2         = $6039 = 24633  RAM          clock.s:250 (unused)
display_dp3         = $603A = 24634  RAM          clock.s:251 (unused)
display_effect      = $6063 = 24675  RAM          clock.s:432
display_row1        = $6020 = 24608  RAM          clock.s:246
display_row2        = $6028 = 24616  RAM          clock.s:247 (unused)
display_row3        = $6030 = 24624  RAM          clock.s:248 (unused)
display_status      = $6061 = 24673  RAM          clock.s:430
display_syncd       = $6062 = 24674  RAM          clock.s:431 (unused)
display_task        = $0600 =  1536  ROM          clock.s:438
find_first_sunday   = $0C70 =  3184  ROM          clock_app.s:989
find_last_sunday    = $0C8B =  3211  ROM          clock_app.s:1033
find_second_sunday  = $0CA0 =  3232  ROM          clock_app.s:1071
foreground_mtx      = $6000 = 24576  RAM          clock.s:227
init                = $0300 =   768  ROM          clock.s:263
int_vector_table    = $0100 =   256  ROM          clock.s:51 (unused)
main_loop           = $0400 =  1024  ROM          clock.s:336
mem_test            = $0283 =   643  ROM          clock.s:182
memcpy              = $1500 =  5376  ROM          c_lib.s:21
memset              = $1540 =  5440  ROM          c_lib.s:111
nmi_vector          = $0066 =   102  ROM          clock.s:47 (unused)
proc_test           = $0200 =   512  ROM          clock.s:68
row_borrows         = $607E = 24702  RAM          clock_app.s:57
row_buf_ptr         = $6079 = 24697  RAM          clock_app.s:48
row_carrys          = $607D = 24701  RAM          clock_app.s:51
row_flags           = $607F = 24703  RAM          clock_app.s:63
short_day_names     = $0C50 =  3152  ROM          clock_app.s:967
staging_dp1         = $6058 = 24664  RAM          clock.s:257 (unused)
staging_dp2         = $6059 = 24665  RAM          clock.s:258 (unused)
staging_dp3         = $605A = 24666  RAM          clock.s:259 (unused)
staging_row1        = $6040 = 24640  RAM          clock.s:254
staging_row2        = $6048 = 24648  RAM          clock.s:255
staging_row3        = $6050 = 24656  RAM          clock.s:256
strncpy             = $1520 =  5408  ROM          c_lib.s:57
task_sched          = $6010 = 24592  RAM          clock.s:239
tz_rom_ptr          = $6077 = 24695  RAM          clock_app.s:47
tz_sw_ptr           = $6075 = 24693  RAM          clock_app.s:46
wd_poke_task        = $0700 =  1792  ROM          clock.s:508

; +++ local symbols +++

next_regs      = $0201 =   513  ROM          clock.s:73 (unused)
proc_test_done = $026B =   619  ROM          clock.s:147
proc_test_err  = $0282 =   642  ROM          clock.s:165
write_pattern  = $0253 =   595  ROM          clock.s:125

; +++ local symbols +++

mem_test_err      = $02A3 =   675  ROM          clock.s:215
mem_test_loop     = $0294 =   660  ROM          clock.s:199
mem_test_next     = $028A =   650  ROM          clock.s:190
mem_test_patterns = $02A4 =   676  ROM          clock.s:218

; +++ local symbols +++

done    = $0525 =  1317  ROM          clock.s:408

; +++ local symbols +++

done        = $063E =  1598  ROM          clock.s:487
dsky_effect = $0615 =  1557  ROM          clock.s:452

; +++ local symbols +++


; +++ local symbols +++

apply_dimming      = $0B23 =  2851  ROM          clock_app.s:765
begin_computation  = $08FE =  2302  ROM          clock_app.s:229
check1             = $0A1A =  2586  ROM          clock_app.s:489
check1_done        = $0A2E =  2606  ROM          clock_app.s:505
check2             = $0A46 =  2630  ROM          clock_app.s:542
check3_day_equal   = $0A94 =  2708  ROM          clock_app.s:615
check3_last_sun    = $0A79 =  2681  ROM          clock_app.s:584
check3_match_day   = $0A89 =  2697  ROM          clock_app.s:597
check3_second_sun  = $0A82 =  2690  ROM          clock_app.s:590
check4_day_equal   = $0AD4 =  2772  ROM          clock_app.s:679
check4_last_sun    = $0AC2 =  2754  ROM          clock_app.s:654
check4_match_day   = $0AC9 =  2761  ROM          clock_app.s:661
check_end_cond     = $0AA3 =  2723  ROM          clock_app.s:632
check_for_dst      = $0AEA =  2794  ROM          clock_app.s:702
check_start_cond   = $0A58 =  2648  ROM          clock_app.s:560
day_continue       = $099B =  2459  ROM          clock_app.s:364
dimming_off        = $0B22 =  2850  ROM          clock_app.s:762
dimming_on         = $0B18 =  2840  ROM          clock_app.s:745
display_date       = $0B6E =  2926  ROM          clock_app.s:836
display_row        = $0AF9 =  2809  ROM          clock_app.s:713
display_time       = $0B2F =  2863  ROM          clock_app.s:780 (unused)
dst_end_mon_higher = $0A17 =  2583  ROM          clock_app.s:486
hrs_min_to_buf     = $0B52 =  2898  ROM          clock_app.s:808
mon_borrow_fix_day = $09AE =  2478  ROM          clock_app.s:387
mon_day_dec        = $0BA9 =  2985  ROM          clock_app.s:887
mon_day_to_buf     = $0B8C =  2956  ROM          clock_app.s:859
no_day_borrow      = $0978 =  2424  ROM          clock_app.s:335
no_dimming         = $0B26 =  2854  ROM          clock_app.s:768
no_hrs_borrow      = $092E =  2350  ROM          clock_app.s:272
no_hrs_carry       = $0938 =  2360  ROM          clock_app.s:281
no_mon_borrow      = $09C9 =  2505  ROM          clock_app.s:409
no_mon_carry       = $09ED =  2541  ROM          clock_app.s:435
nodst_start_mon_higher = $0A43 =  2627  ROM          clock_app.s:539
not_leap_year      = $0948 =  2376  ROM          clock_app.s:295
row_loop           = $08BE =  2238  ROM          clock_app.s:176
row_loop_done      = $0BAE =  2990  ROM          clock_app.s:895

; +++ local symbols +++

check_semaphore = $0BEC =  3052  ROM          clock_app.s:932

; +++ local symbols +++

done    = $0C89 =  3209  ROM          clock_app.s:1013
loop    = $0C83 =  3203  ROM          clock_app.s:1008

; +++ local symbols +++

done    = $0C9E =  3230  ROM          clock_app.s:1053
loop    = $0C93 =  3219  ROM          clock_app.s:1042

; +++ local symbols +++

do_msg         = $0D97 =  3479  ROM          configr_app.s:107
enter_menu1    = $0DCA =  3530  ROM          configr_app.s:136
test_enter_btn = $0DB0 =  3504  ROM          configr_app.s:121
test_updn_btns = $0DD2 =  3538  ROM          configr_app.s:142

; +++ local symbols +++

cp_99          = $0E8E =  3726  ROM          configr_app.s:271
down_button    = $0E7D =  3709  ROM          configr_app.s:257
store          = $0E85 =  3717  ROM          configr_app.s:261
test_enter_btn = $0E57 =  3671  ROM          configr_app.s:234
test_updn_btns = $0E6A =  3690  ROM          configr_app.s:243

; +++ local symbols +++

cp_99          = $0F0B =  3851  ROM          configr_app.s:365
down_button    = $0EFA =  3834  ROM          configr_app.s:351
store          = $0F02 =  3842  ROM          configr_app.s:355
test_enter_btn = $0ED4 =  3796  ROM          configr_app.s:328
test_updn_btn  = $0EE7 =  3815  ROM          configr_app.s:337

; +++ local symbols +++

down_button    = $0FCB =  4043  ROM          configr_app.s:490
store          = $0FD3 =  4051  ROM          configr_app.s:494
test_enter_btn = $0FA5 =  4005  ROM          configr_app.s:467
test_updn_btn  = $0FB8 =  4024  ROM          configr_app.s:476

; +++ local symbols +++

cp_0           = $104D =  4173  ROM          configr_app.s:582
down_button    = $103C =  4156  ROM          configr_app.s:568
store          = $1044 =  4164  ROM          configr_app.s:572
test_enter_btn = $1016 =  4118  ROM          configr_app.s:545
test_updn_btn  = $1029 =  4137  ROM          configr_app.s:554

; +++ local symbols +++

cp_0           = $10CA =  4298  ROM          configr_app.s:671
down_button    = $10B9 =  4281  ROM          configr_app.s:657
store          = $10C1 =  4289  ROM          configr_app.s:661
test_enter_btn = $1093 =  4243  ROM          configr_app.s:634
test_updn_btn  = $10A6 =  4262  ROM          configr_app.s:643

; +++ local symbols +++

cp_0           = $1149 =  4425  ROM          configr_app.s:757
down_button    = $1138 =  4408  ROM          configr_app.s:743
store          = $1140 =  4416  ROM          configr_app.s:747
test_enter_btn = $110F =  4367  ROM          configr_app.s:719
test_updn_btn  = $1122 =  4386  ROM          configr_app.s:728

; +++ local symbols +++

next_row_char  = $13AB =  5035  ROM          ctc_isr.s:109
out_disp_ctrl  = $13D2 =  5074  ROM          ctc_isr.s:162
row_offset     = $1392 =  5010  ROM          ctc_isr.s:73
row_offset_add = $139F =  5023  ROM          ctc_isr.s:87
shift_offset   = $139B =  5019  ROM          ctc_isr.s:82

; +++ local symbols +++

clock_sem   = $1417 =  5143  ROM          ctc_isr.s:204 (unused)
configr_sem = $1440 =  5184  ROM          ctc_isr.s:209
done        = $1469 =  5225  ROM          ctc_isr.s:214

; +++ local symbols +++

done    = $14AB =  5291  ROM          ctc_isr.s:254

; +++ local symbols +++

zero_fill = $152D =  5421  ROM          c_lib.s:75

; +++ local symbols +++

next    = $1541 =  5441  ROM          c_lib.s:115


total time: 0.0419 sec.
no errors
