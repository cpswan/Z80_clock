              	; --------------------------------------
              	; zasm: assemble "clock.a80"
              	; opts: --reqcolon
              	; date: 2019-04-28 13:53:20
              	; --------------------------------------


              	;*********************************************************************
              	; Z80 based, 3 time zone clock
              	;
              	; This code has been written to be compiled with the zasm assembler
              	; available from:
              	;
              	; https://k1.spdns.de/Develop/Projects/zasm/Distributions/
              	;
              	; Command line options used:
              	;
              	; ./zasm --hex --opcodes --labels --reqcolon -v2 clock.a80
              	;*********************************************************************
              	
              	#target ROM
              	
              	;---- Oscillator frequencies (in Hz)
              	;     FSYS is the primary system oscillator which drives the CPU.
              	;     FCTC is a secondary oscillator external to the CTC which can be
              	;     prescaled and is fed in to the TRG1 input for more precise
              	;     millisecond timing, e.g. for display refresh.
              	;
              	;     These values are used to
8D80:         	FSYS              .EQU  6000000
8000:         	FCTC              .EQU  4096000
              	
              	
              	;---- Vector interrupt page number
              	;     Forms the most significant byte of the interrupt vector address
              	;     for Mode 2 interrupts. The least significant byte is supplied by
              	;     the peripheral generating the interrupt. The addressed memory
              	;     location contains a word (address) pointing to an ISR where the
              	;     CPU will jump.
0001:         	VECTOR_INT_PG     .EQU  0x01
              	
              	
              	;---- Memory sizes (in bytes)
              	;     Defines the start (base) and size of ROMs and RAM. ZASM will
              	;     also create some similar and additional variables, e.g. ROM_BASE
              	;     will become ROM generated by ZASM, and a computation of
              	;     ROM_BASE + ROM_SZ will become ROM_end generated by ZASM, plus
              	;     some others. A combination of these values is used throughout.
0000:         	ROM_BASE          .EQU  0
6000:         	ROM_SZ            .EQU  24576
              	
8000:         	RAM_BASE          .EQU  0x8000
2000:         	RAM_SZ            .EQU  8192
              	
C000:         	TZ_ROM_BASE       .EQU  0xC000
2000:         	TZ_ROM_SZ         .EQU  8192
              	
E000:         	CHAR_ROM_BASE     .EQU  0xE000
2000:         	CHAR_ROM_SZ       .EQU  8192
              	
              	
              	;---- CTC constants
              	;     Various values etc used to configure and control a CTC.
0010:         	CTC_CH0_DIV       .EQU  16
B8D8:         	CTC_CH0_FCY       .EQU  FSYS / CTC_CH0_DIV
0000:         	CTC_CH0_PS        .EQU  (CTC_CH0_DIV & 0x100) >> 3
              	
0100:         	CTC_CH2_DIV       .EQU  256
5B8D:         	CTC_CH2_FCY       .EQU  FSYS / CTC_CH2_DIV
0020:         	CTC_CH2_PS        .EQU  (CTC_CH2_DIV & 0x100) >> 3
              	
0080:         	CTC_CH_INTEN      .EQU  0x80  ; Interrupt enable (0 = off)
0040:         	CTC_CH_CTR_MODE   .EQU  0x40  ; Counter enable (0 = timer)
0020:         	CTC_CH_PS256      .EQU  0x20  ; 256 prescaler (0 = 16)
0010:         	CTC_CH_RISE       .EQU  0x10  ; Timer triggers on rising edge
              	                              ; (0 = falling)
0008:         	CTC_CH_EXT_TRG    .EQU  0x08  ; Timer triggered externally
              	                              ; (0 = trigger on constant load)
0004:         	CTC_CH_TCONST     .EQU  0x04  ; Timer constant follows
0002:         	CTC_CH_SOFT_RST   .EQU  0x02  ; Soft reset channel
0001:         	CTC_CH_CTRL       .EQU  0x01  ; Word is control word
              	
              	
              	;---- CTC time constants
              	;     Some calculated values which can be loaded in to CTC channels.
002E:         	TC_4000HZ         .EQU  CTC_CH0_FCY / 4000 / 2
002D:         	TC_4100HZ         .EQU  CTC_CH0_FCY / 4100 / 2
00EA:         	TC_DLY_10MS       .EQU  CTC_CH2_FCY / 100
              	
              	
              	;---- Peripheral addresses
0000:         	CTC_CH0           .EQU  0           ; Address of CTC Ch0
0001:         	CTC_CH1           .EQU  0x01        ; Address of CTC Ch1
0002:         	CTC_CH2           .EQU  0x02        ; Address of CTC Ch2
0003:         	CTC_CH3           .EQU  0x03        ; Address of CTC Ch3
              	
0004:         	WD_POKE           .EQU  0x04        ; Poke the watchdog
              	
0008:         	BTN_REG           .EQU  0x08        ; To read buttons
0009:         	TZ1_REG           .EQU  0x09        ; To read Timezone 1 value
000A:         	TZ2_REG           .EQU  0x0A        ; To read Timezone 2 value
000B:         	TZ3_REG           .EQU  0x0B        ; To read Timezone 3 value
000C:         	OUTPUT_REG        .EQU  0x0C        ; To write outputs, e.g. buzzer
              	
0010:         	RTC_SEC           .EQU  0x10        ; Seconds
0011:         	RTC_SEC_ALM       .EQU  0x11        ; Seconds alarm
0012:         	RTC_MIN           .EQU  0x12        ; Minutes
0013:         	RTC_MIN_ALM       .EQU  0x13        ; Minutes alarm
0014:         	RTC_HRS           .EQU  0x14        ; Hours
0015:         	RTC_HRS_ALM       .EQU  0x15        ; Hours alarm
0016:         	RTC_DAY           .EQU  0x16        ; Day
0017:         	RTC_DAY_ALM       .EQU  0x17        ; Day alarm
0018:         	RTC_DOW           .EQU  0x18        ; Day of week
0019:         	RTC_MON           .EQU  0x19        ; Month
001A:         	RTC_YEAR          .EQU  0x1A        ; Year
001B:         	RTC_RATES         .EQU  0x1B        ; Watchdog/interrupt rate
001C:         	RTC_INTS          .EQU  0x1C        ; Interrupt enables
001D:         	RTC_FLAGS         .EQU  0x1D        ; Status flags
001E:         	RTC_CTRL          .EQU  0x1E        ; Control
001F:         	RTC_UNUSED        .EQU  0x1F
              	
              	
              	;---- Button values and masks
0000:         	BTN_UP_BIT        .EQU  0
0001:         	BTN_DN_BIT        .EQU  1
0002:         	BTN_ENT_BIT       .EQU  2
0003:         	BTN_ESC_BIT       .EQU  3
0002:         	BTN_UP_MASK       .EQU  1 << BTN_DN_BIT
0001:         	BTN_DN_MASK       .EQU  1 << BTN_UP_BIT
0004:         	BTN_ENT_MASK      .EQU  1 << BTN_ENT_BIT
0008:         	BTN_ESC_MASK      .EQU  1 << BTN_ESC_BIT
              	
              	
              	;---- OUTPUT_REG values and masks
0007:         	BEEPER_BIT        .EQU  7
0080:         	BEEPER_MASK       .EQU  1 << BEEPER_BIT
              	
              	;---- State machine values
0001:         	SM_MAIN_RESET     .EQU  0x01        ; Reset state
              	
              	
              	;---------------------------------------------------------------------­
              	;                          GLOBAL VARIABLES                          :
              	;---------------------------------------------------------------------
8000:         	#data RAM, RAM_BASE, RAM_SZ
              	
              	;---- OUTPUT_REG value
              	;     Stores the value which is written to the OUTPUT_REG.
8000: 00      	OUTPUT_REG_VAL:         .DB   0
              	
              	;---- Button variables
              	;     BTN_MASK:  Each bit determines which buttons are valid to be
              	;                pressed in the current state of execution.
              	;     BTN_STATE: Each bit represents a valid button that is currently
              	;                pressed and has not yet been serviced.
              	;     BTN_ACK:   Each bit represents which button press which has been
              	;                serviced.
8001: 00      	BTN_MASK:               .DB   0
8002: 00      	BTN_STATE:              .DB   0
8003: 00      	BTN_ACK:                .DB   0
              	
              	;---- Beeper variables
              	;     BEEP_LEN: A value which is decremented for each interrupt cycle
              	;               when generating a beep. The cycle is considered to be
              	;               two interrupts for writing high and low to the beeper
              	;               pin of OUTPUT_REG.
8004: 00      	BEEP_LEN:               .DB   0
              	
              	
              	;---------------------------------------------------------------------­
              	;                          APPLICATION CODE                          :
              	;---------------------------------------------------------------------
0000:         	#code ROM, ROM_BASE, ROM_SZ
              	
              	;---- Restart vectors
              	      .ORG 0
0000:         	RST0:
0000: C30002  	      JP    PROC_TEST
              	
              	
0003: FFFFFFFF	      .ORG 0x08
0007: FF      	
0008:         	RST1:
0008: 76      	      HALT
              	
              	
0009: FFFFFFFF	      .ORG 0x10
000D: FFFFFF  	
0010:         	RST2:
0010: 76      	      HALT
              	
              	
0011: FFFFFFFF	      .ORG 0x18
0015: FFFFFF  	
0018:         	RST3:
0018: 76      	      HALT
              	
              	
0019: FFFFFFFF	      .ORG 0x20
001D: FFFFFF  	
0020:         	RST4:
0020: 76      	      HALT
              	
              	
0021: FFFFFFFF	      .ORG 0x28
0025: FFFFFF  	
0028:         	RST5:
0028: 76      	      HALT
              	
              	
0029: FFFFFFFF	      .ORG 0x30
002D: FFFFFF  	
0030:         	RST6:
0030: 76      	      HALT
              	
              	
0031: FFFFFFFF	      .ORG 0x38
0035: FFFFFF  	
0038:         	RST7:
0038: 76      	      HALT
              	
              	
              	;---------------------------------------------------------------------­
              	;                         INTERRUPT VECTORS                          :
              	;---------------------------------------------------------------------
0039: FFFFFFFF	      .ORG 0x0066
003D: FF...   	
0066:         	NMI_VECTOR:
0066: ED45    	      RETN
              	
              	
0068: FFFFFFFF	      .ORG 0x0100
006C: FF...   	
0100:         	INT_VECTOR_TABLE:
0100: 3703    	      .DW   CTC_CH0_INT             ; CTC Ch0 vector
0102: 5503    	      .DW   CTC_CH1_INT             ; CTC Ch1 vector
0104: 5803    	      .DW   CTC_CH2_INT             ; CTC Ch2 vector
0106: 7E03    	      .DW   CTC_CH3_INT             ; CTC Ch3 vector
              	
0108: 00000000	      .DS   248, 0                  ; Fill rest of table with 0's
010C: 00...   	
              	
              	
              	      .ORG 0x0200
              	;---------------------------------------------------------------------
              	;     Z80 PROCESSOR TEST                                             :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Verify Z80 flags, registers (except IX/IY) and conditional     :
              	;     jumps, including all shadow register pairs.                    :
              	;                                                                    :
              	;     Adapted from IBM 5150 BIOS.                                    :
              	;---------------------------------------------------------------------
0200:         	PROC_TEST:
0200: F3      	      DI                            ; Ensure interrupts disabled
              	
              	;---- First tests for normal flags register
0201: AF      	      XOR   A
0202: 386D    	      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
0204: E27102  	      JP    PO, PROC_TEST_ERR       ; PARITY should be EVEN
0207: 2068    	      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO
0209: FA7102  	      JP    M, PROC_TEST_ERR        ; Result should be POSITIVE
              	
020C: D601    	      SUB   1
020E: 3061    	      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
0210: EA7102  	      JP    PE, PROC_TEST_ERR       ; PARITY should be ODD
0213: 285C    	      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO
0215: F27102  	      JP    P, PROC_TEST_ERR        ; Result should be NEGATIVE
              	
0218: 3E01    	      LD    A, 0x01
021A: CB3F    	      SRL   A
021C: 3053    	      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
021E: 2051    	      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO
              	
0220: CB17    	      RL    A
0222: 384D    	      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
0224: 284B    	      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO
              	
              	;---- Repeat tests for shadow flags register
0226: 08      	      EX    AF, AF'
0227: AF      	      XOR   A
0228: 3847    	      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
022A: E27102  	      JP    PO, PROC_TEST_ERR       ; PARITY should be EVEN
022D: 2042    	      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO
022F: FA7102  	      JP    M, PROC_TEST_ERR        ; Result should be POSITIVE
              	
0232: D601    	      SUB   1
0234: 303B    	      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
0236: EA7102  	      JP    PE, PROC_TEST_ERR       ; PARITY should be ODD
0239: 2836    	      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO
023B: F27102  	      JP    P, PROC_TEST_ERR        ; Result should be NEGATIVE
              	
023E: 3E01    	      LD    A, 0x01
0240: CB3F    	      SRL   A
0242: 302D    	      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
0244: 202B    	      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO
              	
0246: CB17    	      RL    A
0248: 3827    	      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
024A: 2825    	      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO
              	
              	;---- Load a test pattern through all registers
024C: 08      	      EX    AF, AF'
024D: 3EFF    	      LD    A, 0xFF                 ; Setup one's pattern in A
024F: 37      	      SCF
              	
0250:         	WRITE_PATTERN:
0250: ED47    	      LD    I, A                    ; Write pattern to all regs
0252: ED57    	      LD    A, I
0254: 6F      	      LD    L, A
0255: 65      	      LD    H, L
0256: 5C      	      LD    E, H
0257: 53      	      LD    D, E
0258: 4A      	      LD    C, D
0259: 41      	      LD    B, C
025A: 78      	      LD    A, B
025B: D9      	      EXX
025C: 6F      	      LD    L, A
025D: 65      	      LD    H, L
025E: 5C      	      LD    E, H
025F: 53      	      LD    D, E
0260: 4A      	      LD    C, D
0261: 41      	      LD    B, C
0262: 3008    	      JR    NC, PROC_TEST_DONE
0264: 08      	      EX    AF, AF'
0265: 78      	      LD    A, B
0266: EEFF    	      XOR   0xFF                    ; Pattern make it through all regs
0268: 2007    	      JR    NZ, PROC_TEST_ERR       ; NO - go to err routine
026A: 18E4    	      JR    WRITE_PATTERN
              	
026C:         	PROC_TEST_DONE:
026C: ED57    	      LD    A, I                    ; Zero pattern make it through?
026E: B0      	      OR    B
026F: 2801    	      JR    Z, INDEX_REG_TEST             ; Next test if yes
              	
0271:         	PROC_TEST_ERR:
0271: 76      	      HALT                          ; HALT on error
              	
              	
              	;---------------------------------------------------------------------
              	;     INDEX REGISTER TEST                                            :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Performs a test on the IX and IY registers via SP to cover off :
              	;     remaining internal registers.                                  :
              	;---------------------------------------------------------------------
0272:         	INDEX_REG_TEST:
0272: 06FF    	      LD    B, 0xFF
              	
0274:         	INDEX_REG_TEST_NEXT:
0274: 78      	      LD    A, B
0275: FEFF    	      CP    0xFF
0277: 2806    	      JR    Z, INDEX_REG_TEST_FF
              	
0279: DD210000	      LD    IX, 0                   ; Load test pattern, all zeroes
027D: 1804    	      JR    INDEX_REG_TEST_LOOP
              	
027F:         	INDEX_REG_TEST_FF:
027F: DD21FFFF	      LD    IX, 0xFFFF              ; Load test pattern, all ones
              	
0283:         	INDEX_REG_TEST_LOOP:
0283: FD210000	      LD    IY, 0
0287: 210000  	      LD    HL, 0
              	
028A: DDF9    	      LD    SP, IX                  ; Move IX through IY and SP to HL
028C: FD39    	      ADD   IY, SP                  ; so it can be compared
028E: FDF9    	      LD    SP, IY
0290: 39      	      ADD   HL, SP
              	
0291: 7C      	      LD    A, H                    ; XOR H and L, result should be 0
0292: AD      	      XOR   L
0293: 2007    	      JR    NZ, INDEX_REG_TEST_ERR  ; Error if not 0
              	
0295: B0      	      OR    B                       ; If pattern is all zeroes, finish
0296: 2805    	      JR    Z, MEM_TEST
              	
0298: 0600    	      LD    B, 0                    ; Setup for all ones test
029A: 18D8    	      JR    INDEX_REG_TEST_NEXT
              	
029C:         	INDEX_REG_TEST_ERR:
029C: 76      	      HALT                          ; Halt on error
              	
              	
              	;---------------------------------------------------------------------
              	;     RAM TEST                                                       :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Performs a read/write storage test on RAM address space as     :
              	;     defined by RAM_BASE and RAM_SZ variables.                      :
              	;                                                                    :
              	;     Writes a series of patterns (0xAA, 0x55, 0xFF, 0x01 and 0x00)  :
              	;     and reads them back to check for errors.                       :
              	;                                                                    :
              	;     !!! DESTROYS CONTENTS OF ENTIRE MEMORY BLOCK !!!               :
              	;---------------------------------------------------------------------
029D:         	MEM_TEST:
029D: 1E00    	      LD    E, 0
              	
029F:         	MEM_TEST_NEXT:
029F: 210080  	      LD    HL, RAM_BASE            ; HL is address to begin test from
02A2: 010020  	      LD    BC, RAM_SZ              ; BC is number of bytes to test
              	
02A5: 7B      	      LD    A, E                    ; Select next test pattern
02A6: FEAA    	      CP    0xAA
02A8: 2810    	      JR    Z, MEM_TEST_55
02AA: FE55    	      CP    0x55
02AC: 2810    	      JR    Z, MEM_TEST_FF
02AE: FEFF    	      CP    0xFF
02B0: 2810    	      JR    Z, MEM_TEST_01
02B2: FE01    	      CP    0x01
02B4: 2810    	      JR    Z, MEM_TEST_0
              	
02B6: 1EAA    	      LD    E, 0xAA
02B8: 1810    	      JR    MEM_TEST_LOOP
              	
02BA:         	MEM_TEST_55:
02BA: 1E55    	      LD    E, 0x55
02BC: 180C    	      JR    MEM_TEST_LOOP
              	
02BE:         	MEM_TEST_FF:
02BE: 1EFF    	      LD    E, 0xFF
02C0: 1808    	      JR    MEM_TEST_LOOP
              	
02C2:         	MEM_TEST_01:
02C2: 1E01    	      LD    E, 0x01
02C4: 1804    	      JR    MEM_TEST_LOOP
              	
02C6:         	MEM_TEST_0:
02C6: 1E00    	      LD    E, 0
02C8: 1800    	      JR    MEM_TEST_LOOP
              	
              	
02CA:         	MEM_TEST_LOOP:
02CA: 73      	      LD    (HL), E                 ; Write test pattern from E, read
02CB: 7E      	      LD    A, (HL)                 ; back, XOR and ensure result is
02CC: AB      	      XOR   E                       ; zero to indicate success.
02CD: 200C    	      JR    NZ, MEM_TEST_ERR
              	
02CF: 23      	      INC   HL
02D0: 0B      	      DEC   BC
              	
02D1: 78      	      LD    A, B                    ; BC = 0?
02D2: B1      	      OR    C
02D3: 20F5    	      JR    NZ, MEM_TEST_LOOP       ; NO
              	
02D5: B3      	      OR    E                       ; Completed zero test?
02D6: 20C7    	      JR    NZ, MEM_TEST_NEXT       ; NO - next test pattern
              	
02D8:         	MEM_TEST_DONE:
02D8: C30003  	      JP    INIT
              	
02DB:         	MEM_TEST_ERR:
02DB: 76      	      HALT                          ; Halt on error
              	
              	
              	;---------------------------------------------------------------------
              	;     MAIN APPLICATION LOOP                                          :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Implemented here is a state machine responsible for scheduling :
              	;     various tasks and implementing high level workflow.            :
              	;---------------------------------------------------------------------
02DC: FFFFFFFF	      .ORG 0x0300
02E0: FF...   	
              	#data RAM
              	;---- LOCAL variables for MAIN
              	
              	
              	#code ROM
0300:         	INIT:
0300: 3100A0  	      LD    SP, RAM_end             ; Stack starts at top of RAM
              	
              	;---- Configure CTC Ch0 to ...
              	
              	;---- Configure CTC Ch1 to ...
              	
              	;---- Configure CTC Ch2 for 10ms period for reading button presses
0303: 3EA5    	      LD    A, CTC_CH_INTEN | CTC_CH2_PS | CTC_CH_TCONST | CTC_CH_CTRL
0305: D302    	      OUT   (CTC_CH2), A
0307: 3EEA    	      LD    A, TC_DLY_10MS
0309: D302    	      OUT   (CTC_CH2), A
              	
              	;---- Configure CTC Ch3 to ...
              	
              	;---- Configure CTC interrupt vector
030B: AF      	      XOR   A
030C: D300    	      OUT   (CTC_CH0), A
              	
030E: ED5E    	      IM    2                       ; Z80 family vectored interrupts
0310: 3E01    	      LD    A, VECTOR_INT_PG        ; INT vector table in page 1
0312: ED47    	      LD    I, A
0314: FB      	      EI
              	
0315: 3E01    	      LD    A, 0x01                 ; Configure valid button mask
0317: 320180  	      LD    (BTN_MASK), A
              	
              	
031A:         	MAIN:
              	;---- Check for button presses, and generate a beep on press
031A: 3A0280  	      LD    A, (BTN_STATE)
031D: B7      	      OR    A
031E: 47      	      LD    B, A
              	
031F: 28F9    	      JR    Z, MAIN                 ; Loop again if zero (no buttons)
              	
0321: 3A0380  	      LD    A, (BTN_ACK)            ; Store pressed buttons as acks
0324: B0      	      OR    B
0325: 320380  	      LD    (BTN_ACK), A
              	
              	;---- With valid buttons pressed and ackd, do a beep
0328: CD2E03  	      CALL  BEEPER_ENABLE
              	
032B: 18ED    	      JR    MAIN
              	
032D: 76      	      HALT
              	
              	
              	;---------------------------------------------------------------------
              	;     ENABLE BEEPER                                                  :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Configures interrupts etc to start generating a beep for       :
              	;     button presses.                                                :
              	;---------------------------------------------------------------------
032E:         	BEEPER_ENABLE:
032E: 3E85    	      LD    A, CTC_CH_INTEN | CTC_CH0_PS | CTC_CH_TCONST | CTC_CH_CTRL
0330: D300    	      OUT   (CTC_CH0), A
0332: 3E2E    	      LD    A, TC_4000HZ
0334: D300    	      OUT   (CTC_CH0), A
              	
0336: C9      	      RET
              	
              	
              	;---------------------------------------------------------------------
              	;     CTC CHANNEL 0 ISR - BEEPER                                     :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Used to generate beeps.                                        :
              	;---------------------------------------------------------------------
              	#data RAM
              	
              	#code ROM
0337:         	CTC_CH0_INT::
0337: 08      	      EX    AF, AF'                 ; Swap to shadow registers
0338: D9      	      EXX
              	
0339: 210080  	      LD    HL, OUTPUT_REG_VAL
033C: 3E80    	      LD    A, BEEPER_MASK          ; Toggle beeper bit
033E: AE      	      XOR   (HL)
033F: 77      	      LD    (HL), A
0340: D30C    	      OUT   (OUTPUT_REG), A         ; Write it out
              	
0342: E680    	      AND   BEEPER_MASK             ; Is beeper bit set or clear?
0344: 200A    	      JR    NZ, CTC_CH0_INT_EXIT
              	
0346: 210480  	      LD    HL, BEEP_LEN            ; Beeper bit is clear, decrement
0349: 35      	      DEC   (HL)                    ; BEEP_LEN, and if zero disable
034A: 2004    	      JR    NZ, CTC_CH0_INT_EXIT    ; interrupt.
              	
034C: 3E01    	      LD    A, CTC_CH_CTRL
034E: D300    	      OUT   (CTC_CH0), A
              	
0350:         	CTC_CH0_INT_EXIT:
0350: D9      	      EXX                           ; Swap registers back
0351: 08      	      EX    AF, AF'
0352: FB      	      EI                            ; Re-enable interrupts
              	
0353: ED4D    	      RETI
              	
              	
              	;---------------------------------------------------------------------
              	;     CTC CHANNEL 1 ISR - ...                                        :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;---------------------------------------------------------------------
              	#data RAM
              	
              	#code ROM
0355:         	CTC_CH1_INT:
0355: FB      	      EI
0356: ED4D    	      RETI
              	
              	
              	;---------------------------------------------------------------------
              	;     CTC CHANNEL 2 ISR - READ BUTTONS                               :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Reads button state, masks out invalid buttons and serviced     :
              	;     button presses, debounces.                                     :
              	;                                                                    :
              	;     Result is placed in to global BTN_STATE where it can be read   :
              	;     by current process.                                            :
              	;---------------------------------------------------------------------
              	#data RAM
8005: 00      	BTN_DEBOUNCE:           .DB   0
              	
              	#code ROM
0358:         	CTC_CH2_INT:
0358: 08      	      EX    AF, AF'                 ; Swap to shadow registers
0359: D9      	      EXX
              	
035A: DB08    	      IN    A, (BTN_REG)            ; Read in button state
035C: 2F      	      CPL                           ; Buttons pull down, make positive
035D: 47      	      LD    B, A                    ; Save for later
              	
035E: 3A0180  	      LD    A, (BTN_MASK)           ; Mask out invalid buttons
0361: A0      	      AND   B
0362: 47      	      LD    B, A                    ; B is now valid buttons only
              	
0363: 210380  	      LD    HL, BTN_ACK             ; Make mask to hide serviced btns
0366: A6      	      AND   (HL)
0367: 4F      	      LD    C, A                    ; C is mask
              	
0368: A8      	      XOR   B                       ; Remove svcd btns, leave unsvcd
0369: 47      	      LD    B, A                    ; B is now unserviced buttons only
036A: B1      	      OR    C                       ; Make mask to clear old ACKs
036B: 57      	      LD    D, A                    ; D is mask
              	
036C: A6      	      AND   (HL)                    ; Clear ACKs from released btns
036D: 320380  	      LD    (BTN_ACK), A
              	
0370: 210580  	      LD    HL, BTN_DEBOUNCE        ; De-bounce button presses
0373: 7E      	      LD    A, (HL)
0374: A0      	      AND   B
0375: 320280  	      LD    (BTN_STATE), A
0378: 70      	      LD    (HL), B
              	
0379: D9      	      EXX                           ; Swap registers back
037A: 08      	      EX    AF, AF'
037B: FB      	      EI                            ; Re-enable interrupts
              	
037C: ED4D    	      RETI
              	
              	
              	;---------------------------------------------------------------------
              	;     CTC CHANNEL 1 ISR - ...                                        :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;---------------------------------------------------------------------
              	#data RAM
              	
              	#code ROM
037E:         	CTC_CH3_INT:
037E: FB      	      EI
037F: ED4D    	      RETI
              	
              	#end


; +++ segments +++

#CODE ROM      = $0000 =     0,  size = $6000 = 24576
#DATA RAM      = $8000 = 32768,  size = $2000 =  8192

; +++ global symbols +++

BEEPER_BIT          = $0007 =     7          clock.a80:128
BEEPER_ENABLE       = $032E =   814  ROM     clock.a80:507
BEEPER_MASK         = $0080 =   128          clock.a80:129
BEEP_LEN            = $8004 = 32772  RAM     clock.a80:160
BTN_ACK             = $8003 = 32771  RAM     clock.a80:153
BTN_DEBOUNCE        = $8005 = 32773  RAM     clock.a80:577
BTN_DN_BIT          = $0001 =     1          clock.a80:118
BTN_DN_MASK         = $0001 =     1          clock.a80:122 (unused)
BTN_ENT_BIT         = $0002 =     2          clock.a80:119
BTN_ENT_MASK        = $0004 =     4          clock.a80:123 (unused)
BTN_ESC_BIT         = $0003 =     3          clock.a80:120
BTN_ESC_MASK        = $0008 =     8          clock.a80:124 (unused)
BTN_MASK            = $8001 = 32769  RAM     clock.a80:151
BTN_REG             = $0008 =     8          clock.a80:92
BTN_STATE           = $8002 = 32770  RAM     clock.a80:152
BTN_UP_BIT          = $0000 =     0          clock.a80:117
BTN_UP_MASK         = $0002 =     2          clock.a80:121 (unused)
CHAR_ROM_BASE       = $E000 = 57344          clock.a80:51 (unused)
CHAR_ROM_SZ         = $2000 =  8192          clock.a80:52 (unused)
CTC_CH0             = $0000 =     0          clock.a80:85
CTC_CH0_DIV         = $0010 =    16          clock.a80:57
CTC_CH0_FCY         = $B8D8 =375000          clock.a80:58
CTC_CH0_INT         = $0337 =   823  ROM     clock.a80:525
CTC_CH0_INT_EXIT    = $0350 =   848  ROM     clock.a80:545
CTC_CH0_PS          = $0000 =     0          clock.a80:59
CTC_CH1             = $0001 =     1          clock.a80:86 (unused)
CTC_CH1_INT         = $0355 =   853  ROM     clock.a80:561
CTC_CH2             = $0002 =     2          clock.a80:87
CTC_CH2_DIV         = $0100 =   256          clock.a80:61
CTC_CH2_FCY         = $5B8D = 23437          clock.a80:62
CTC_CH2_INT         = $0358 =   856  ROM     clock.a80:580
CTC_CH2_PS          = $0020 =    32          clock.a80:63
CTC_CH3             = $0003 =     3          clock.a80:88 (unused)
CTC_CH3_INT         = $037E =   894  ROM     clock.a80:625
CTC_CH_CTRL         = $0001 =     1          clock.a80:74
CTC_CH_CTR_MODE     = $0040 =    64          clock.a80:66 (unused)
CTC_CH_EXT_TRG      = $0008 =     8          clock.a80:70 (unused)
CTC_CH_INTEN        = $0080 =   128          clock.a80:65
CTC_CH_PS256        = $0020 =    32          clock.a80:67 (unused)
CTC_CH_RISE         = $0010 =    16          clock.a80:68 (unused)
CTC_CH_SOFT_RST     = $0002 =     2          clock.a80:73 (unused)
CTC_CH_TCONST       = $0004 =     4          clock.a80:72
FCTC                = $8000 =4096000          clock.a80:24 (unused)
FSYS                = $8D80 =6000000          clock.a80:23
INDEX_REG_TEST      = $0272 =   626  ROM     clock.a80:330
INDEX_REG_TEST_ERR  = $029C =   668  ROM     clock.a80:363
INDEX_REG_TEST_FF   = $027F =   639  ROM     clock.a80:341
INDEX_REG_TEST_LOOP = $0283 =   643  ROM     clock.a80:344
INDEX_REG_TEST_NEXT = $0274 =   628  ROM     clock.a80:333
INIT                = $0300 =   768  ROM     clock.a80:452
INT_VECTOR_TABLE    = $0100 =   256  ROM     clock.a80:218 (unused)
MAIN                = $031A =   794  ROM     clock.a80:480
MEM_TEST            = $029D =   669  ROM     clock.a80:379
MEM_TEST_0          = $02C6 =   710  ROM     clock.a80:411
MEM_TEST_01         = $02C2 =   706  ROM     clock.a80:407
MEM_TEST_55         = $02BA =   698  ROM     clock.a80:399
MEM_TEST_DONE       = $02D8 =   728  ROM     clock.a80:432 (unused)
MEM_TEST_ERR        = $02DB =   731  ROM     clock.a80:435
MEM_TEST_FF         = $02BE =   702  ROM     clock.a80:403
MEM_TEST_LOOP       = $02CA =   714  ROM     clock.a80:416
MEM_TEST_NEXT       = $029F =   671  ROM     clock.a80:382
NMI_VECTOR          = $0066 =   102  ROM     clock.a80:213 (unused)
OUTPUT_REG          = $000C =    12          clock.a80:96
OUTPUT_REG_VAL      = $8000 = 32768  RAM     clock.a80:142
PROC_TEST           = $0200 =   512  ROM     clock.a80:237
PROC_TEST_DONE      = $026C =   620  ROM     clock.a80:314
PROC_TEST_ERR       = $0271 =   625  ROM     clock.a80:319
RAM                 = $8000 = 32768  RAM     clock.a80:137 (unused)
RAM_BASE            = $8000 = 32768          clock.a80:45
RAM_SZ              = $2000 =  8192          clock.a80:46
RAM_end             = $A000 = 40960  RAM     clock.a80:137
RAM_size            = $2000 =  8192  RAM     clock.a80:137 (unused)
ROM                 = $0000 =     0  ROM     clock.a80:165 (unused)
ROM_BASE            = $0000 =     0          clock.a80:42
ROM_SZ              = $6000 = 24576          clock.a80:43
ROM_end             = $6000 = 24576  ROM     clock.a80:165 (unused)
ROM_size            = $6000 = 24576  ROM     clock.a80:165 (unused)
RST0                = $0000 =     0  ROM     clock.a80:170 (unused)
RST1                = $0008 =     8  ROM     clock.a80:175 (unused)
RST2                = $0010 =    16  ROM     clock.a80:180 (unused)
RST3                = $0018 =    24  ROM     clock.a80:185 (unused)
RST4                = $0020 =    32  ROM     clock.a80:190 (unused)
RST5                = $0028 =    40  ROM     clock.a80:195 (unused)
RST6                = $0030 =    48  ROM     clock.a80:200 (unused)
RST7                = $0038 =    56  ROM     clock.a80:205 (unused)
RTC_CTRL            = $001E =    30          clock.a80:112 (unused)
RTC_DAY             = $0016 =    22          clock.a80:104 (unused)
RTC_DAY_ALM         = $0017 =    23          clock.a80:105 (unused)
RTC_DOW             = $0018 =    24          clock.a80:106 (unused)
RTC_FLAGS           = $001D =    29          clock.a80:111 (unused)
RTC_HRS             = $0014 =    20          clock.a80:102 (unused)
RTC_HRS_ALM         = $0015 =    21          clock.a80:103 (unused)
RTC_INTS            = $001C =    28          clock.a80:110 (unused)
RTC_MIN             = $0012 =    18          clock.a80:100 (unused)
RTC_MIN_ALM         = $0013 =    19          clock.a80:101 (unused)
RTC_MON             = $0019 =    25          clock.a80:107 (unused)
RTC_RATES           = $001B =    27          clock.a80:109 (unused)
RTC_SEC             = $0010 =    16          clock.a80:98 (unused)
RTC_SEC_ALM         = $0011 =    17          clock.a80:99 (unused)
RTC_UNUSED          = $001F =    31          clock.a80:113 (unused)
RTC_YEAR            = $001A =    26          clock.a80:108 (unused)
SM_MAIN_RESET       = $0001 =     1          clock.a80:132 (unused)
TC_4000HZ           = $002E =    46          clock.a80:79
TC_4100HZ           = $002D =    45          clock.a80:80 (unused)
TC_DLY_10MS         = $00EA =   234          clock.a80:81
TZ1_REG             = $0009 =     9          clock.a80:93 (unused)
TZ2_REG             = $000A =    10          clock.a80:94 (unused)
TZ3_REG             = $000B =    11          clock.a80:95 (unused)
TZ_ROM_BASE         = $C000 = 49152          clock.a80:48 (unused)
TZ_ROM_SZ           = $2000 =  8192          clock.a80:49 (unused)
VECTOR_INT_PG       = $0001 =     1          clock.a80:33
WD_POKE             = $0004 =     4          clock.a80:90 (unused)
WRITE_PATTERN       = $0250 =   592  ROM     clock.a80:290
_reqcolon_          = $0001 =     1          :1 (unused)


total time: 0.0083 sec.
no errors
