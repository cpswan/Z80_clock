              	; --------------------------------------
              	; zasm: assemble "clock.a80"
              	; opts: --reqcolon
              	; date: 2019-05-06 22:41:11
              	; --------------------------------------


              	;*********************************************************************
              	; Z80 based, 3 time zone clock
              	;
              	; This code has been written to be compiled with the zasm assembler
              	; available from:
              	;
              	; https://k1.spdns.de/Develop/Projects/zasm/Distributions/
              	;
              	; Command line options used:
              	;
              	; ./zasm --hex --opcodes --labels --reqcolon -v2 clock.a80
              	;*********************************************************************
              	
              	#target ROM
              	
              	;---- Oscillator frequencies (in Hz)
              	;     FSYS is the primary system oscillator which drives the CPU.
              	;     FCTC is a secondary oscillator external to the CTC which can be
              	;     prescaled and is fed in to the TRG1 input for more precise
              	;     millisecond timing, e.g. for display refresh.
              	;
              	;     These values are used to
8D80:         	FSYS              .EQU  6000000
8000:         	FCTC              .EQU  4096000
              	
              	
              	;---- Vector interrupt page number
              	;     Forms the most significant byte of the interrupt vector address
              	;     for Mode 2 interrupts. The least significant byte is supplied by
              	;     the peripheral generating the interrupt. The addressed memory
              	;     location contains a word (address) pointing to an ISR where the
              	;     CPU will jump.
0001:         	VECTOR_INT_PG     .EQU  0x01
              	
              	
              	;---- Memory sizes (in bytes)
              	;     Defines the start (base) and size of ROMs and RAM. ZASM will
              	;     also create some similar and additional variables, e.g. ROM_BASE
              	;     will become ROM generated by ZASM, and a computation of
              	;     ROM_BASE + ROM_SZ will become ROM_end generated by ZASM, plus
              	;     some others. A combination of these values is used throughout.
0000:         	ROM_BASE          .EQU  0
6000:         	ROM_SZ            .EQU  24576
              	
8000:         	RAM_BASE          .EQU  0x8000
2000:         	RAM_SZ            .EQU  8192
              	
C000:         	TZ_ROM_BASE       .EQU  0xC000
2000:         	TZ_ROM_SZ         .EQU  8192
              	
E000:         	CHAR_ROM_BASE     .EQU  0xE000
2000:         	CHAR_ROM_SZ       .EQU  8192
              	
              	
              	;---- CTC constants
              	;     Various values etc used to configure and control a CTC.
0010:         	CTC_CH0_DIV       .EQU  16
B8D8:         	CTC_CH0_FCY       .EQU  FSYS / CTC_CH0_DIV
0000:         	CTC_CH0_PS        .EQU  (CTC_CH0_DIV & 0x100) >> 3
              	
0100:         	CTC_CH1_DIV       .EQU  256
5B8D:         	CTC_CH1_FCY       .EQU  FSYS / CTC_CH1_DIV
0020:         	CTC_CH1_PS        .EQU  (CTC_CH1_DIV & 0x100) >> 3
              	
0100:         	CTC_CH2_DIV       .EQU  256
5B8D:         	CTC_CH2_FCY       .EQU  FSYS / CTC_CH2_DIV
0020:         	CTC_CH2_PS        .EQU  (CTC_CH2_DIV & 0x100) >> 3
              	
0080:         	CTC_CH_INTEN      .EQU  0x80  ; Interrupt enable (0 = off)
0040:         	CTC_CH_CTR_MODE   .EQU  0x40  ; Counter enable (0 = timer)
0020:         	CTC_CH_PS256      .EQU  0x20  ; 256 prescaler (0 = 16)
0010:         	CTC_CH_RISE       .EQU  0x10  ; Timer triggers on rising edge
              	                              ; (0 = falling)
0008:         	CTC_CH_EXT_TRG    .EQU  0x08  ; Timer triggered externally
              	                              ; (0 = trigger on constant load)
0004:         	CTC_CH_TCONST     .EQU  0x04  ; Timer constant follows
0002:         	CTC_CH_SOFT_RST   .EQU  0x02  ; Soft reset channel
0001:         	CTC_CH_CTRL       .EQU  0x01  ; Word is control word
              	
              	
              	;---- CTC time constants
              	;     Some calculated values which can be loaded in to CTC channels.
002E:         	TC_CH0_4000HZ     .EQU  CTC_CH0_FCY / 4000 / 2
002D:         	TC_CH0_4100HZ     .EQU  CTC_CH0_FCY / 4100 / 2
0017:         	TC_CH1_DLY_1MS    .EQU  CTC_CH1_FCY / 1000
00EA:         	TC_CH2_DLY_10MS   .EQU  CTC_CH2_FCY / 100
              	
              	
              	;---- Peripheral addresses
0000:         	CTC_CH0           .EQU  0           ; Address of CTC Ch0
0001:         	CTC_CH1           .EQU  0x01        ; Address of CTC Ch1
0002:         	CTC_CH2           .EQU  0x02        ; Address of CTC Ch2
0003:         	CTC_CH3           .EQU  0x03        ; Address of CTC Ch3
              	
0004:         	WD_POKE           .EQU  0x04        ; Poke the watchdog
              	
0008:         	BTN_REG           .EQU  0x08        ; To read buttons
0009:         	TZ1_REG           .EQU  0x09        ; To read Timezone 1 value
000A:         	TZ2_REG           .EQU  0x0A        ; To read Timezone 2 value
000B:         	TZ3_REG           .EQU  0x0B        ; To read Timezone 3 value
000C:         	OUTPUT_REG        .EQU  0x0C        ; To write outputs, e.g. buzzer
              	
0010:         	RTC_SEC           .EQU  0x10        ; Seconds
0011:         	RTC_SEC_ALM       .EQU  0x11        ; Seconds alarm
0012:         	RTC_MIN           .EQU  0x12        ; Minutes
0013:         	RTC_MIN_ALM       .EQU  0x13        ; Minutes alarm
0014:         	RTC_HRS           .EQU  0x14        ; Hours
0015:         	RTC_HRS_ALM       .EQU  0x15        ; Hours alarm
0016:         	RTC_DAY           .EQU  0x16        ; Day
0017:         	RTC_DAY_ALM       .EQU  0x17        ; Day alarm
0018:         	RTC_DOW           .EQU  0x18        ; Day of week
0019:         	RTC_MON           .EQU  0x19        ; Month
001A:         	RTC_YEAR          .EQU  0x1A        ; Year
001B:         	RTC_RATES         .EQU  0x1B        ; Watchdog/interrupt rate
001C:         	RTC_INTS          .EQU  0x1C        ; Interrupt enables
001D:         	RTC_FLAGS         .EQU  0x1D        ; Status flags
001E:         	RTC_CTRL          .EQU  0x1E        ; Control
001F:         	RTC_UNUSED        .EQU  0x1F
              	
0020:         	DISP_DATA         .EQU  0x20        ; Display data register
0021:         	DISP_CTRL         .EQU  0x21        ; Display control register
              	
              	
              	;---- Button values and masks
0000:         	BTN_UP_BIT        .EQU  0
0001:         	BTN_DN_BIT        .EQU  1
0002:         	BTN_ENT_BIT       .EQU  2
0003:         	BTN_ESC_BIT       .EQU  3
0002:         	BTN_UP_MASK       .EQU  1 << BTN_DN_BIT
0001:         	BTN_DN_MASK       .EQU  1 << BTN_UP_BIT
0004:         	BTN_ENT_MASK      .EQU  1 << BTN_ENT_BIT
0008:         	BTN_ESC_MASK      .EQU  1 << BTN_ESC_BIT
              	
              	
              	;---- OUTPUT_REG values and masks
0007:         	BEEPER_BIT        .EQU  7
0080:         	BEEPER_MASK       .EQU  1 << BEEPER_BIT
              	
              	;---- State machine values
0001:         	SM_MAIN_RESET     .EQU  0x01        ; Reset state
              	
              	;---- Display buffer values
0009:         	DISP_BUF_SZ       .EQU  9
              	
              	
              	;---------------------------------------------------------------------­
              	;                          GLOBAL VARIABLES                          :
              	;---------------------------------------------------------------------
8000:         	#data RAM, RAM_BASE, RAM_SZ
              	
              	;---- OUTPUT_REG value
              	;     Stores the value which is written to the OUTPUT_REG.
8000: 00      	OUTPUT_REG_VAL:         .DB   0
              	
              	;---- Button variables
              	;     BTN_MASK:  Each bit determines which buttons are valid to be
              	;                pressed in the current state of execution.
              	;     BTN_STATE: Each bit represents a valid button that is currently
              	;                pressed and has not yet been serviced.
              	;     BTN_ACK:   Each bit represents which button press which has been
              	;                serviced.
8001: 00      	BTN_MASK:               .DB   0
8002: 00      	BTN_STATE:              .DB   0
8003: 00      	BTN_ACK:                .DB   0
              	
              	;---- Beeper variables
              	;     BEEP_LEN: A value which is decremented for each interrupt cycle
              	;               when generating a beep. The cycle is considered to be
              	;               two interrupts for writing high and low to the beeper
              	;               pin of OUTPUT_REG.
8004: 00      	BEEP_LEN:               .DB   0
              	
              	;---- Display buffers
              	;     3x 9 byte buffers used to hold the ASCII equivalent text to be
              	;     displayed plus the dot points for each row of the display. The
              	;     values are translated to memory addresses to read from the
              	;     character ROM.
              	;     NOTE: THESE BUFFERS MUST BE ALLOCATED CONTIGUOUSLY !!!
8005: 00000000	DISP_ROW0:              .DS   DISP_BUF_SZ, 0
8009: 00...   	
800E: 00000000	DISP_ROW1:              .DS   DISP_BUF_SZ, 0
8012: 00...   	
8017: 00000000	DISP_ROW2:              .DS   DISP_BUF_SZ, 0
801B: 00...   	
              	
              	
              	;---------------------------------------------------------------------­
              	;                          APPLICATION CODE                          :
              	;---------------------------------------------------------------------
0000:         	#code ROM, ROM_BASE, ROM_SZ
              	
              	;---- Restart vectors
              	      .ORG 0
0000:         	RST0:
0000: C30002  	      JP    PROC_TEST
              	
              	
0003: FFFFFFFF	      .ORG 0x08
0007: FF      	
0008:         	RST1:
0008: 76      	      HALT
              	
              	
0009: FFFFFFFF	      .ORG 0x10
000D: FFFFFF  	
0010:         	RST2:
0010: 76      	      HALT
              	
              	
0011: FFFFFFFF	      .ORG 0x18
0015: FFFFFF  	
0018:         	RST3:
0018: 76      	      HALT
              	
              	
0019: FFFFFFFF	      .ORG 0x20
001D: FFFFFF  	
0020:         	RST4:
0020: 76      	      HALT
              	
              	
0021: FFFFFFFF	      .ORG 0x28
0025: FFFFFF  	
0028:         	RST5:
0028: 76      	      HALT
              	
              	
0029: FFFFFFFF	      .ORG 0x30
002D: FFFFFF  	
0030:         	RST6:
0030: 76      	      HALT
              	
              	
0031: FFFFFFFF	      .ORG 0x38
0035: FFFFFF  	
0038:         	RST7:
0038: 76      	      HALT
              	
              	
              	;---------------------------------------------------------------------­
              	;                         INTERRUPT VECTORS                          :
              	;---------------------------------------------------------------------
0039: FFFFFFFF	      .ORG 0x0066
003D: FF...   	
0066:         	NMI_VECTOR:
0066: ED45    	      RETN
              	
              	
0068: FFFFFFFF	      .ORG 0x0100
006C: FF...   	
0100:         	INT_VECTOR_TABLE:
0100: 3F03    	      .DW   CTC_CH0_ISR             ; CTC Ch0 vector
0102: 5D03    	      .DW   CTC_CH1_ISR             ; CTC Ch1 vector
0104: 9003    	      .DW   CTC_CH2_ISR             ; CTC Ch2 vector
0106: B203    	      .DW   CTC_CH3_ISR             ; CTC Ch3 vector
              	
0108: 00000000	      .DS   248, 0                  ; Fill rest of table with 0's
010C: 00...   	
              	
              	
              	      .ORG 0x0200
              	;---------------------------------------------------------------------
              	;     Z80 PROCESSOR TEST                                             :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Verify Z80 flags, registers (except IX/IY) and conditional     :
              	;     jumps, including all shadow register pairs.                    :
              	;                                                                    :
              	;     Adapted from IBM 5150 BIOS.                                    :
              	;---------------------------------------------------------------------
0200:         	PROC_TEST:
0200: F3      	      DI                            ; Ensure interrupts disabled
              	
              	;---- First tests for normal flags register
0201: AF      	      XOR   A
0202: 386D    	      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
0204: E27102  	      JP    PO, PROC_TEST_ERR       ; PARITY should be EVEN
0207: 2068    	      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO
0209: FA7102  	      JP    M, PROC_TEST_ERR        ; Result should be POSITIVE
              	
020C: D601    	      SUB   1
020E: 3061    	      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
0210: EA7102  	      JP    PE, PROC_TEST_ERR       ; PARITY should be ODD
0213: 285C    	      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO
0215: F27102  	      JP    P, PROC_TEST_ERR        ; Result should be NEGATIVE
              	
0218: 3E01    	      LD    A, 0x01
021A: CB3F    	      SRL   A
021C: 3053    	      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
021E: 2051    	      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO
              	
0220: CB17    	      RL    A
0222: 384D    	      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
0224: 284B    	      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO
              	
              	;---- Repeat tests for shadow flags register
0226: 08      	      EX    AF, AF'
0227: AF      	      XOR   A
0228: 3847    	      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
022A: E27102  	      JP    PO, PROC_TEST_ERR       ; PARITY should be EVEN
022D: 2042    	      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO
022F: FA7102  	      JP    M, PROC_TEST_ERR        ; Result should be POSITIVE
              	
0232: D601    	      SUB   1
0234: 303B    	      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
0236: EA7102  	      JP    PE, PROC_TEST_ERR       ; PARITY should be ODD
0239: 2836    	      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO
023B: F27102  	      JP    P, PROC_TEST_ERR        ; Result should be NEGATIVE
              	
023E: 3E01    	      LD    A, 0x01
0240: CB3F    	      SRL   A
0242: 302D    	      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
0244: 202B    	      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO
              	
0246: CB17    	      RL    A
0248: 3827    	      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
024A: 2825    	      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO
              	
              	;---- Load a test pattern through all registers
024C: 08      	      EX    AF, AF'
024D: 3EFF    	      LD    A, 0xFF                 ; Setup one's pattern in A
024F: 37      	      SCF
              	
0250:         	WRITE_PATTERN:
0250: ED47    	      LD    I, A                    ; Write pattern to all regs
0252: ED57    	      LD    A, I
0254: 6F      	      LD    L, A
0255: 65      	      LD    H, L
0256: 5C      	      LD    E, H
0257: 53      	      LD    D, E
0258: 4A      	      LD    C, D
0259: 41      	      LD    B, C
025A: 78      	      LD    A, B
025B: D9      	      EXX
025C: 6F      	      LD    L, A
025D: 65      	      LD    H, L
025E: 5C      	      LD    E, H
025F: 53      	      LD    D, E
0260: 4A      	      LD    C, D
0261: 41      	      LD    B, C
0262: 3008    	      JR    NC, PROC_TEST_DONE
0264: 08      	      EX    AF, AF'
0265: 78      	      LD    A, B
0266: EEFF    	      XOR   0xFF                    ; Pattern make it through all regs
0268: 2007    	      JR    NZ, PROC_TEST_ERR       ; NO - go to err routine
026A: 18E4    	      JR    WRITE_PATTERN
              	
026C:         	PROC_TEST_DONE:
026C: ED57    	      LD    A, I                    ; Zero pattern make it through?
026E: B0      	      OR    B
026F: 2801    	      JR    Z, INDEX_REG_TEST             ; Next test if yes
              	
0271:         	PROC_TEST_ERR:
0271: 76      	      HALT                          ; HALT on error
              	
              	
              	;---------------------------------------------------------------------
              	;     INDEX REGISTER TEST                                            :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Performs a test on the IX and IY registers via SP to cover off :
              	;     remaining internal registers.                                  :
              	;---------------------------------------------------------------------
0272:         	INDEX_REG_TEST:
0272: 06FF    	      LD    B, 0xFF
              	
0274:         	INDEX_REG_TEST_NEXT:
0274: 78      	      LD    A, B
0275: FEFF    	      CP    0xFF
0277: 2806    	      JR    Z, INDEX_REG_TEST_FF
              	
0279: DD210000	      LD    IX, 0                   ; Load test pattern, all zeroes
027D: 1804    	      JR    INDEX_REG_TEST_LOOP
              	
027F:         	INDEX_REG_TEST_FF:
027F: DD21FFFF	      LD    IX, 0xFFFF              ; Load test pattern, all ones
              	
0283:         	INDEX_REG_TEST_LOOP:
0283: FD210000	      LD    IY, 0
0287: 210000  	      LD    HL, 0
              	
028A: DDF9    	      LD    SP, IX                  ; Move IX through IY and SP to HL
028C: FD39    	      ADD   IY, SP                  ; so it can be compared
028E: FDF9    	      LD    SP, IY
0290: 39      	      ADD   HL, SP
              	
0291: 7C      	      LD    A, H                    ; XOR H and L, result should be 0
0292: AD      	      XOR   L
0293: 2007    	      JR    NZ, INDEX_REG_TEST_ERR  ; Error if not 0
              	
0295: B0      	      OR    B                       ; If pattern is all zeroes, finish
0296: 2805    	      JR    Z, MEM_TEST
              	
0298: 0600    	      LD    B, 0                    ; Setup for all ones test
029A: 18D8    	      JR    INDEX_REG_TEST_NEXT
              	
029C:         	INDEX_REG_TEST_ERR:
029C: 76      	      HALT                          ; Halt on error
              	
              	
              	;---------------------------------------------------------------------
              	;     RAM TEST                                                       :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Performs a read/write storage test on RAM address space as     :
              	;     defined by RAM_BASE and RAM_SZ variables.                      :
              	;                                                                    :
              	;     Writes a series of patterns (0xAA, 0x55, 0xFF, 0x01 and 0x00)  :
              	;     and reads them back to check for errors.                       :
              	;                                                                    :
              	;     !!! DESTROYS CONTENTS OF ENTIRE MEMORY BLOCK !!!               :
              	;---------------------------------------------------------------------
029D:         	MEM_TEST:
029D: 1E00    	      LD    E, 0
              	
029F:         	MEM_TEST_NEXT:
029F: 210080  	      LD    HL, RAM_BASE            ; HL is address to begin test from
02A2: 010020  	      LD    BC, RAM_SZ              ; BC is number of bytes to test
              	
02A5: 7B      	      LD    A, E                    ; Select next test pattern
02A6: FEAA    	      CP    0xAA
02A8: 2810    	      JR    Z, MEM_TEST_55
02AA: FE55    	      CP    0x55
02AC: 2810    	      JR    Z, MEM_TEST_FF
02AE: FEFF    	      CP    0xFF
02B0: 2810    	      JR    Z, MEM_TEST_01
02B2: FE01    	      CP    0x01
02B4: 2810    	      JR    Z, MEM_TEST_0
              	
02B6: 1EAA    	      LD    E, 0xAA
02B8: 1810    	      JR    MEM_TEST_LOOP
              	
02BA:         	MEM_TEST_55:
02BA: 1E55    	      LD    E, 0x55
02BC: 180C    	      JR    MEM_TEST_LOOP
              	
02BE:         	MEM_TEST_FF:
02BE: 1EFF    	      LD    E, 0xFF
02C0: 1808    	      JR    MEM_TEST_LOOP
              	
02C2:         	MEM_TEST_01:
02C2: 1E01    	      LD    E, 0x01
02C4: 1804    	      JR    MEM_TEST_LOOP
              	
02C6:         	MEM_TEST_0:
02C6: 1E00    	      LD    E, 0
02C8: 1800    	      JR    MEM_TEST_LOOP
              	
              	
02CA:         	MEM_TEST_LOOP:
02CA: 73      	      LD    (HL), E                 ; Write test pattern from E, read
02CB: 7E      	      LD    A, (HL)                 ; back, XOR and ensure result is
02CC: AB      	      XOR   E                       ; zero to indicate success.
02CD: 200C    	      JR    NZ, MEM_TEST_ERR
              	
02CF: 23      	      INC   HL
02D0: 0B      	      DEC   BC
              	
02D1: 78      	      LD    A, B                    ; BC = 0?
02D2: B1      	      OR    C
02D3: 20F5    	      JR    NZ, MEM_TEST_LOOP       ; NO
              	
02D5: B3      	      OR    E                       ; Completed zero test?
02D6: 20C7    	      JR    NZ, MEM_TEST_NEXT       ; NO - next test pattern
              	
02D8:         	MEM_TEST_DONE:
02D8: C30003  	      JP    INIT
              	
02DB:         	MEM_TEST_ERR:
02DB: 76      	      HALT                          ; Halt on error
              	
              	
              	;---------------------------------------------------------------------
              	;     MAIN APPLICATION LOOP                                          :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Implemented here is a state machine responsible for scheduling :
              	;     various tasks and implementing high level workflow.            :
              	;---------------------------------------------------------------------
02DC: FFFFFFFF	      .ORG 0x0300
02E0: FF...   	
              	#data RAM
              	;---- LOCAL variables for MAIN
              	
              	
              	#code ROM
0300:         	INIT:
0300: 3100A0  	      LD    SP, RAM_end             ; Stack starts at top of RAM
              	
              	;---- Configure CTC Ch0 to ...
              	
              	;---- Configure CTC Ch1 for 1ms period to update displays
0303: 3EA5    	      LD    A, CTC_CH_INTEN | CTC_CH1_PS | CTC_CH_TCONST | CTC_CH_CTRL
0305: D301    	      OUT   (CTC_CH1), A
0307: 3E17    	      LD    A, TC_CH1_DLY_1MS
0309: D301    	      OUT   (CTC_CH1), A
              	
              	;---- Configure CTC Ch2 for 10ms period for reading button presses
030B: 3EA5    	      LD    A, CTC_CH_INTEN | CTC_CH2_PS | CTC_CH_TCONST | CTC_CH_CTRL
030D: D302    	      OUT   (CTC_CH2), A
030F: 3EEA    	      LD    A, TC_CH2_DLY_10MS
0311: D302    	      OUT   (CTC_CH2), A
              	
              	;---- Configure CTC Ch3 to ...
              	
              	;---- Configure CTC interrupt vector
0313: AF      	      XOR   A
0314: D300    	      OUT   (CTC_CH0), A
              	
0316: ED5E    	      IM    2                       ; Z80 family vectored interrupts
0318: 3E01    	      LD    A, VECTOR_INT_PG        ; INT vector table in page 1
031A: ED47    	      LD    I, A
031C: FB      	      EI
              	
031D: 3E01    	      LD    A, 0x01                 ; Configure valid button mask
031F: 320180  	      LD    (BTN_MASK), A
              	
              	
0322:         	MAIN:
              	;---- Check for button presses, and generate a beep on press
0322: 3A0280  	      LD    A, (BTN_STATE)
0325: B7      	      OR    A
0326: 47      	      LD    B, A
              	
0327: 28F9    	      JR    Z, MAIN                 ; Loop again if zero (no buttons)
              	
0329: 3A0380  	      LD    A, (BTN_ACK)            ; Store pressed buttons as acks
032C: B0      	      OR    B
032D: 320380  	      LD    (BTN_ACK), A
              	
              	;---- With valid buttons pressed and ackd, do a beep
0330: CD3603  	      CALL  BEEPER_ENABLE
              	
0333: 18ED    	      JR    MAIN
              	
0335: 76      	      HALT
              	
              	
              	;---------------------------------------------------------------------
              	;     ENABLE BEEPER                                                  :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Configures interrupts etc to start generating a beep for       :
              	;     button presses.                                                :
              	;---------------------------------------------------------------------
0336:         	BEEPER_ENABLE:
0336: 3E85    	      LD    A, CTC_CH_INTEN | CTC_CH0_PS | CTC_CH_TCONST | CTC_CH_CTRL
0338: D300    	      OUT   (CTC_CH0), A
033A: 3E2E    	      LD    A, TC_CH0_4000HZ
033C: D300    	      OUT   (CTC_CH0), A
              	
033E: C9      	      RET
              	
              	
              	;---------------------------------------------------------------------
              	;     CTC CHANNEL 0 ISR - BEEPER                                     :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Used to generate beeps e.g. when buttons are pressed.          :
              	;---------------------------------------------------------------------
              	#data RAM
              	
              	#code ROM
033F:         	CTC_CH0_ISR:
033F: 08      	      EX    AF, AF'                 ; Swap to shadow registers
0340: D9      	      EXX
              	
0341: 210080  	      LD    HL, OUTPUT_REG_VAL
0344: 3E80    	      LD    A, BEEPER_MASK          ; Toggle beeper bit
0346: AE      	      XOR   (HL)
0347: 77      	      LD    (HL), A
0348: D30C    	      OUT   (OUTPUT_REG), A         ; Write it out
              	
034A: E680    	      AND   BEEPER_MASK             ; Is beeper bit set or clear?
034C: 200A    	      JR    NZ, CTC_CH0_ISR_EXIT
              	
034E: 210480  	      LD    HL, BEEP_LEN            ; Beeper bit is clear, decrement
0351: 35      	      DEC   (HL)                    ; BEEP_LEN, and if zero disable
0352: 2004    	      JR    NZ, CTC_CH0_ISR_EXIT    ; interrupt.
              	
0354: 3E01    	      LD    A, CTC_CH_CTRL
0356: D300    	      OUT   (CTC_CH0), A
              	
0358:         	CTC_CH0_ISR_EXIT:
0358: D9      	      EXX                           ; Swap registers back
0359: 08      	      EX    AF, AF'
035A: FB      	      EI                            ; Re-enable interrupts
              	
035B: ED4D    	      RETI
              	
              	
              	;---------------------------------------------------------------------
              	;     CTC CHANNEL 1 ISR - DISPLAY UPDATE                             :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     The display is made up of 3 rows of 8x 16 segment displays.    :
              	;     Each iteration of this ISR cycles to the next display row
              	;     after shifting out the data corresponding to the currently
              	;     selected row.
              	;---------------------------------------------------------------------
              	#data RAM
8020: 00      	DISP_CONTROL:           .DB   0
              	
              	#code ROM
              	#local
035D:         	CTC_CH1_ISR::
035D: 08      	      EX    AF, AF'                 ; Swap to shadow registers
035E: D9      	      EXX
              	
              	;---- Pre-check: make sure the row counter in the display control
              	;                byte always remains in the range 1-3. At boot, memory
              	;                is initialised to all zeroes, and at the end of the
              	;                ISR the counter can overflow from 3 to 0. This check
              	;                will take care of both situations.
035F: 212080  	      LD    HL, DISP_CONTROL
0362: 7E      	      LD    A, (HL)
0363: 47      	      LD    B, A
              	
0364: E603    	      AND   0x03
0366: 2005    	      JR    NZ, DO_ROW
              	
0368: 78      	      LD    A, B
0369: 3C      	      INC   A                       ; If count == 0, inc to 1
036A: 77      	      LD    (HL), A                 ; Store back in to memory
              	
036B: E603    	      AND   0x03                    ; Prep A with new row count
              	
036D:         	DO_ROW:
036D: 3D      	      DEC   A                       ; Index row count to zero
036E: 47      	      LD    B, A                    ; B is num of times to add offset
036F: 210580  	      LD    HL, DISP_ROW0           ; Setup default buffer pointer
0372: 110900  	      LD    DE, DISP_BUF_SZ
              	
0375: FE00    	      CP    0                       ; Add offset?
0377: 2803    	      JR    Z, NO_OFFSET
              	
0379:         	ADD_OFFSET:
0379: 19      	      ADD   HL, DE                  ; Add DE to HL B times
037A: 10FD    	      DJNZ  ADD_OFFSET
              	
037C:         	NO_OFFSET:
037C: 00      	      NOP
              	
037D:         	CTC_CH1_ISR_EXIT:
037D: 212080  	      LD    HL, DISP_CONTROL        ; Load display control byte
0380: 7E      	      LD    A, (HL)
0381: 4F      	      LD    C, A                    ; Keep a copy
              	
0382: 3C      	      INC   A                       ; Increment row counter
0383: E603    	      AND   0x03                    ; Mask out upper bits
0385: 47      	      LD    B, A
              	
0386: 79      	      LD    A, C                    ; Make new control byte preserving
0387: E6FC    	      AND   0xFC                    ; upper 6 bits.
0389: B0      	      OR    B
038A: 77      	      LD    (HL), A                 ; Store back to memory
              	
038B: D9      	      EXX                           ; Swap registers back
038C: 08      	      EX    AF, AF'
038D: FB      	      EI
              	
038E: ED4D    	      RETI
              	#endlocal
              	
              	;---------------------------------------------------------------------
              	;     CTC CHANNEL 2 ISR - READ BUTTONS                               :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;     Reads button state, masks out invalid buttons and serviced     :
              	;     button presses, debounces.                                     :
              	;                                                                    :
              	;     Result is placed in to global BTN_STATE where it can be read   :
              	;     by current process.                                            :
              	;---------------------------------------------------------------------
              	#data RAM
8021: 00      	BTN_DEBOUNCE:           .DB   0
              	
              	#code ROM
0390:         	CTC_CH2_ISR:
0390: 08      	      EX    AF, AF'                 ; Swap to shadow registers
0391: D9      	      EXX
              	
0392: DB08    	      IN    A, (BTN_REG)            ; Read in button state
0394: 2F      	      CPL                           ; Buttons pull down, make positive
              	
0395: 210180  	      LD    HL, BTN_MASK            ; Mask out invalid buttons
0398: A6      	      AND   (HL)
0399: 47      	      LD    B, A                    ; B is valid buttons only
              	
039A: 210380  	      LD    HL, BTN_ACK             ; Make mask to hide serviced btns
039D: A6      	      AND   (HL)
039E: 4F      	      LD    C, A                    ; C is mask
              	
039F: A8      	      XOR   B                       ; Remove svcd btns, leave unsvcd
03A0: 47      	      LD    B, A                    ; B is now unserviced buttons only
03A1: B1      	      OR    C                       ; Make mask to clear old ACKs
              	
03A2: A6      	      AND   (HL)                    ; Clear ACKs from released btns
03A3: 77      	      LD    (HL), A
              	
03A4: 212180  	      LD    HL, BTN_DEBOUNCE        ; De-bounce button presses
03A7: 7E      	      LD    A, (HL)
03A8: A0      	      AND   B
03A9: 320280  	      LD    (BTN_STATE), A
03AC: 70      	      LD    (HL), B
              	
03AD: D9      	      EXX                           ; Swap registers back
03AE: 08      	      EX    AF, AF'
03AF: FB      	      EI                            ; Re-enable interrupts
              	
03B0: ED4D    	      RETI
              	
              	
              	;---------------------------------------------------------------------
              	;     CTC CHANNEL 1 ISR - ...                                        :
              	;                                                                    :
              	; DESCRIPTION                                                        :
              	;---------------------------------------------------------------------
              	#data RAM
              	
              	#code ROM
03B2:         	CTC_CH3_ISR:
03B2: FB      	      EI
03B3: ED4D    	      RETI
              	
              	#end


; +++ segments +++

#CODE ROM      = $0000 =     0,  size = $6000 = 24576
#DATA RAM      = $8000 = 32768,  size = $2000 =  8192

; +++ global symbols +++

BEEPER_BIT          = $0007 =     7          clock.a80:136
BEEPER_ENABLE       = $0336 =   822  ROM     clock.a80:532
BEEPER_MASK         = $0080 =   128          clock.a80:137
BEEP_LEN            = $8004 = 32772  RAM     clock.a80:171
BTN_ACK             = $8003 = 32771  RAM     clock.a80:164
BTN_DEBOUNCE        = $8021 = 32801  RAM     clock.a80:662
BTN_DN_BIT          = $0001 =     1          clock.a80:126
BTN_DN_MASK         = $0001 =     1          clock.a80:130 (unused)
BTN_ENT_BIT         = $0002 =     2          clock.a80:127
BTN_ENT_MASK        = $0004 =     4          clock.a80:131 (unused)
BTN_ESC_BIT         = $0003 =     3          clock.a80:128
BTN_ESC_MASK        = $0008 =     8          clock.a80:132 (unused)
BTN_MASK            = $8001 = 32769  RAM     clock.a80:162
BTN_REG             = $0008 =     8          clock.a80:97
BTN_STATE           = $8002 = 32770  RAM     clock.a80:163
BTN_UP_BIT          = $0000 =     0          clock.a80:125
BTN_UP_MASK         = $0002 =     2          clock.a80:129 (unused)
CHAR_ROM_BASE       = $E000 = 57344          clock.a80:51 (unused)
CHAR_ROM_SZ         = $2000 =  8192          clock.a80:52 (unused)
CTC_CH0             = $0000 =     0          clock.a80:90
CTC_CH0_DIV         = $0010 =    16          clock.a80:57
CTC_CH0_FCY         = $B8D8 =375000          clock.a80:58
CTC_CH0_ISR         = $033F =   831  ROM     clock.a80:550
CTC_CH0_ISR_EXIT    = $0358 =   856  ROM     clock.a80:570
CTC_CH0_PS          = $0000 =     0          clock.a80:59
CTC_CH1             = $0001 =     1          clock.a80:91
CTC_CH1_DIV         = $0100 =   256          clock.a80:61
CTC_CH1_FCY         = $5B8D = 23437          clock.a80:62
CTC_CH1_ISR         = $035D =   861  ROM     clock.a80:592
CTC_CH1_PS          = $0020 =    32          clock.a80:63
CTC_CH2             = $0002 =     2          clock.a80:92
CTC_CH2_DIV         = $0100 =   256          clock.a80:65
CTC_CH2_FCY         = $5B8D = 23437          clock.a80:66
CTC_CH2_ISR         = $0390 =   912  ROM     clock.a80:665
CTC_CH2_PS          = $0020 =    32          clock.a80:67
CTC_CH3             = $0003 =     3          clock.a80:93 (unused)
CTC_CH3_ISR         = $03B2 =   946  ROM     clock.a80:708
CTC_CH_CTRL         = $0001 =     1          clock.a80:78
CTC_CH_CTR_MODE     = $0040 =    64          clock.a80:70 (unused)
CTC_CH_EXT_TRG      = $0008 =     8          clock.a80:74 (unused)
CTC_CH_INTEN        = $0080 =   128          clock.a80:69
CTC_CH_PS256        = $0020 =    32          clock.a80:71 (unused)
CTC_CH_RISE         = $0010 =    16          clock.a80:72 (unused)
CTC_CH_SOFT_RST     = $0002 =     2          clock.a80:77 (unused)
CTC_CH_TCONST       = $0004 =     4          clock.a80:76
DISP_BUF_SZ         = $0009 =     9          clock.a80:143
DISP_CONTROL        = $8020 = 32800  RAM     clock.a80:588
DISP_CTRL           = $0021 =    33          clock.a80:121 (unused)
DISP_DATA           = $0020 =    32          clock.a80:120 (unused)
DISP_ROW0           = $8005 = 32773  RAM     clock.a80:179
DISP_ROW1           = $800E = 32782  RAM     clock.a80:180 (unused)
DISP_ROW2           = $8017 = 32791  RAM     clock.a80:181 (unused)
FCTC                = $8000 =4096000          clock.a80:24 (unused)
FSYS                = $8D80 =6000000          clock.a80:23
INDEX_REG_TEST      = $0272 =   626  ROM     clock.a80:351
INDEX_REG_TEST_ERR  = $029C =   668  ROM     clock.a80:384
INDEX_REG_TEST_FF   = $027F =   639  ROM     clock.a80:362
INDEX_REG_TEST_LOOP = $0283 =   643  ROM     clock.a80:365
INDEX_REG_TEST_NEXT = $0274 =   628  ROM     clock.a80:354
INIT                = $0300 =   768  ROM     clock.a80:473
INT_VECTOR_TABLE    = $0100 =   256  ROM     clock.a80:239 (unused)
MAIN                = $0322 =   802  ROM     clock.a80:505
MEM_TEST            = $029D =   669  ROM     clock.a80:400
MEM_TEST_0          = $02C6 =   710  ROM     clock.a80:432
MEM_TEST_01         = $02C2 =   706  ROM     clock.a80:428
MEM_TEST_55         = $02BA =   698  ROM     clock.a80:420
MEM_TEST_DONE       = $02D8 =   728  ROM     clock.a80:453 (unused)
MEM_TEST_ERR        = $02DB =   731  ROM     clock.a80:456
MEM_TEST_FF         = $02BE =   702  ROM     clock.a80:424
MEM_TEST_LOOP       = $02CA =   714  ROM     clock.a80:437
MEM_TEST_NEXT       = $029F =   671  ROM     clock.a80:403
NMI_VECTOR          = $0066 =   102  ROM     clock.a80:234 (unused)
OUTPUT_REG          = $000C =    12          clock.a80:101
OUTPUT_REG_VAL      = $8000 = 32768  RAM     clock.a80:153
PROC_TEST           = $0200 =   512  ROM     clock.a80:258
PROC_TEST_DONE      = $026C =   620  ROM     clock.a80:335
PROC_TEST_ERR       = $0271 =   625  ROM     clock.a80:340
RAM                 = $8000 = 32768  RAM     clock.a80:148 (unused)
RAM_BASE            = $8000 = 32768          clock.a80:45
RAM_SZ              = $2000 =  8192          clock.a80:46
RAM_end             = $A000 = 40960  RAM     clock.a80:148
RAM_size            = $2000 =  8192  RAM     clock.a80:148 (unused)
ROM                 = $0000 =     0  ROM     clock.a80:186 (unused)
ROM_BASE            = $0000 =     0          clock.a80:42
ROM_SZ              = $6000 = 24576          clock.a80:43
ROM_end             = $6000 = 24576  ROM     clock.a80:186 (unused)
ROM_size            = $6000 = 24576  ROM     clock.a80:186 (unused)
RST0                = $0000 =     0  ROM     clock.a80:191 (unused)
RST1                = $0008 =     8  ROM     clock.a80:196 (unused)
RST2                = $0010 =    16  ROM     clock.a80:201 (unused)
RST3                = $0018 =    24  ROM     clock.a80:206 (unused)
RST4                = $0020 =    32  ROM     clock.a80:211 (unused)
RST5                = $0028 =    40  ROM     clock.a80:216 (unused)
RST6                = $0030 =    48  ROM     clock.a80:221 (unused)
RST7                = $0038 =    56  ROM     clock.a80:226 (unused)
RTC_CTRL            = $001E =    30          clock.a80:117 (unused)
RTC_DAY             = $0016 =    22          clock.a80:109 (unused)
RTC_DAY_ALM         = $0017 =    23          clock.a80:110 (unused)
RTC_DOW             = $0018 =    24          clock.a80:111 (unused)
RTC_FLAGS           = $001D =    29          clock.a80:116 (unused)
RTC_HRS             = $0014 =    20          clock.a80:107 (unused)
RTC_HRS_ALM         = $0015 =    21          clock.a80:108 (unused)
RTC_INTS            = $001C =    28          clock.a80:115 (unused)
RTC_MIN             = $0012 =    18          clock.a80:105 (unused)
RTC_MIN_ALM         = $0013 =    19          clock.a80:106 (unused)
RTC_MON             = $0019 =    25          clock.a80:112 (unused)
RTC_RATES           = $001B =    27          clock.a80:114 (unused)
RTC_SEC             = $0010 =    16          clock.a80:103 (unused)
RTC_SEC_ALM         = $0011 =    17          clock.a80:104 (unused)
RTC_UNUSED          = $001F =    31          clock.a80:118 (unused)
RTC_YEAR            = $001A =    26          clock.a80:113 (unused)
SM_MAIN_RESET       = $0001 =     1          clock.a80:140 (unused)
TC_CH0_4000HZ       = $002E =    46          clock.a80:83
TC_CH0_4100HZ       = $002D =    45          clock.a80:84 (unused)
TC_CH1_DLY_1MS      = $0017 =    23          clock.a80:85
TC_CH2_DLY_10MS     = $00EA =   234          clock.a80:86
TZ1_REG             = $0009 =     9          clock.a80:98 (unused)
TZ2_REG             = $000A =    10          clock.a80:99 (unused)
TZ3_REG             = $000B =    11          clock.a80:100 (unused)
TZ_ROM_BASE         = $C000 = 49152          clock.a80:48 (unused)
TZ_ROM_SZ           = $2000 =  8192          clock.a80:49 (unused)
VECTOR_INT_PG       = $0001 =     1          clock.a80:33
WD_POKE             = $0004 =     4          clock.a80:95 (unused)
WRITE_PATTERN       = $0250 =   592  ROM     clock.a80:311
_reqcolon_          = $0001 =     1          :1 (unused)

; +++ local symbols +++

ADD_OFFSET       = $0379 =   889  ROM     clock.a80:623
CTC_CH1_ISR_EXIT = $037D =   893  ROM     clock.a80:630 (unused)
DO_ROW           = $036D =   877  ROM     clock.a80:614
NO_OFFSET        = $037C =   892  ROM     clock.a80:627


total time: 0.0078 sec.
no errors
