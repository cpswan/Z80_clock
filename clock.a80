;*********************************************************************
; Z80 based, 3 time zone clock
;
; This code has been written to be compiled with the zasm assembler
; available from:
;
; https://k1.spdns.de/Develop/Projects/zasm/Distributions/
;
; Command line options used:
;
; ./zasm --hex --opcodes --labels --reqcolon -v2 clock.a80
;*********************************************************************

#target ROM

;---- Oscillator frequencies (in Hz)
;     FSYS is the primary system oscillator which drives the CPU.
;     FCTC is a secondary oscillator external to the CTC which can be
;     prescaled and is fed in to the TRG1 input for more precise
;     millisecond timing, e.g. for display refresh.
;
;     These values are used to
FSYS              .EQU  6000000
FCTC              .EQU  4096000


;---- Vector interrupt page number
;     Forms the most significant byte of the interrupt vector address
;     for Mode 2 interrupts. The least significant byte is supplied by
;     the peripheral generating the interrupt. The addressed memory
;     location contains a word (address) pointing to an ISR where the
;     CPU will jump.
VECTOR_INT_PG     .EQU  0x01


;---- Memory sizes (in bytes)
;     Defines the start (base) and size of ROMs and RAM. ZASM will
;     also create some similar and additional variables, e.g. ROM_BASE
;     will become ROM generated by ZASM, and a computation of
;     ROM_BASE + ROM_SZ will become ROM_end generated by ZASM, plus
;     some others. A combination of these values is used throughout.
ROM_BASE          .EQU  0
ROM_SZ            .EQU  24576

RAM_BASE          .EQU  0x8000
RAM_SZ            .EQU  8192

TZ_ROM_BASE       .EQU  0xC000
TZ_ROM_SZ         .EQU  8192

CHAR_ROM_BASE     .EQU  0xE000
CHAR_ROM_SZ       .EQU  8192


;---- CTC constants
;     Various values etc used to configure and control a CTC.
CTC_CH0_DIV       .EQU  16
CTC_CH0_FCY       .EQU  FSYS / CTC_CH0_DIV
CTC_CH0_PS        .EQU  (CTC_CH0_DIV & 0x100) >> 3

CTC_CH1_DIV       .EQU  256
CTC_CH1_FCY       .EQU  FSYS / CTC_CH1_DIV
CTC_CH1_PS        .EQU  (CTC_CH1_DIV & 0x100) >> 3

CTC_CH2_DIV       .EQU  256
CTC_CH2_FCY       .EQU  FSYS / CTC_CH2_DIV
CTC_CH2_PS        .EQU  (CTC_CH2_DIV & 0x100) >> 3

CTC_CH_INTEN      .EQU  0x80  ; Interrupt enable (0 = off)
CTC_CH_CTR_MODE   .EQU  0x40  ; Counter enable (0 = timer)
CTC_CH_PS256      .EQU  0x20  ; 256 prescaler (0 = 16)
CTC_CH_RISE       .EQU  0x10  ; Timer triggers on rising edge
                              ; (0 = falling)
CTC_CH_EXT_TRG    .EQU  0x08  ; Timer triggered externally
                              ; (0 = trigger on constant load)
CTC_CH_TCONST     .EQU  0x04  ; Timer constant follows
CTC_CH_SOFT_RST   .EQU  0x02  ; Soft reset channel
CTC_CH_CTRL       .EQU  0x01  ; Word is control word


;---- CTC time constants
;     Some calculated values which can be loaded in to CTC channels.
TC_CH0_4000HZ     .EQU  CTC_CH0_FCY / 4000 / 2
TC_CH0_4100HZ     .EQU  CTC_CH0_FCY / 4100 / 2
TC_CH1_DLY_1MS    .EQU  CTC_CH1_FCY / 1000
TC_CH2_DLY_10MS   .EQU  CTC_CH2_FCY / 100


;---- Peripheral addresses
CTC_CH0           .EQU  0           ; Address of CTC Ch0
CTC_CH1           .EQU  0x01        ; Address of CTC Ch1
CTC_CH2           .EQU  0x02        ; Address of CTC Ch2
CTC_CH3           .EQU  0x03        ; Address of CTC Ch3

WD_POKE           .EQU  0x04        ; Poke the watchdog

BTN_REG           .EQU  0x08        ; To read buttons
TZ1_REG           .EQU  0x09        ; To read Timezone 1 value
TZ2_REG           .EQU  0x0A        ; To read Timezone 2 value
TZ3_REG           .EQU  0x0B        ; To read Timezone 3 value
OUTPUT_REG        .EQU  0x0C        ; To write outputs, e.g. buzzer

RTC_SEC           .EQU  0x10        ; Seconds
RTC_SEC_ALM       .EQU  0x11        ; Seconds alarm
RTC_MIN           .EQU  0x12        ; Minutes
RTC_MIN_ALM       .EQU  0x13        ; Minutes alarm
RTC_HRS           .EQU  0x14        ; Hours
RTC_HRS_ALM       .EQU  0x15        ; Hours alarm
RTC_DAY           .EQU  0x16        ; Day
RTC_DAY_ALM       .EQU  0x17        ; Day alarm
RTC_DOW           .EQU  0x18        ; Day of week
RTC_MON           .EQU  0x19        ; Month
RTC_YEAR          .EQU  0x1A        ; Year
RTC_RATES         .EQU  0x1B        ; Watchdog/interrupt rate
RTC_INTS          .EQU  0x1C        ; Interrupt enables
RTC_FLAGS         .EQU  0x1D        ; Status flags
RTC_CTRL          .EQU  0x1E        ; Control
RTC_UNUSED        .EQU  0x1F

DISP_DATA         .EQU  0x20        ; Display data register
DISP_CTRL         .EQU  0x21        ; Display control register


;---- Button values and masks
BTN_UP_BIT        .EQU  0
BTN_DN_BIT        .EQU  1
BTN_ENT_BIT       .EQU  2
BTN_ESC_BIT       .EQU  3
BTN_UP_MASK       .EQU  1 << BTN_DN_BIT
BTN_DN_MASK       .EQU  1 << BTN_UP_BIT
BTN_ENT_MASK      .EQU  1 << BTN_ENT_BIT
BTN_ESC_MASK      .EQU  1 << BTN_ESC_BIT


;---- OUTPUT_REG values and masks
BEEPER_BIT        .EQU  7
BEEPER_MASK       .EQU  1 << BEEPER_BIT

;---- State machine values
SM_MAIN_RESET     .EQU  0x01        ; Reset state

;---- Display buffer values
DISP_BUF_SZ       .EQU  8


;---------------------------------------------------------------------
;                          GLOBAL VARIABLES                          :
;---------------------------------------------------------------------
#data RAM, RAM_BASE, RAM_SZ

;---- OUTPUT_REG value
;     Stores the value which is written to the OUTPUT_REG.
OUTPUT_REG_VAL:         .DB   0

;---- Button variables
;     BTN_MASK:  Each bit determines which buttons are valid to be
;                pressed in the current state of execution.
;     BTN_STATE: Each bit represents a valid button that is currently
;                pressed and has not yet been serviced.
;     BTN_ACK:   Each bit represents which button press which has been
;                serviced.
BTN_MASK:               .DB   0
BTN_STATE:              .DB   0
BTN_ACK:                .DB   0

;---- Beeper variables
;     BEEP_LEN: A value which is decremented for each interrupt cycle
;               when generating a beep. The cycle is considered to be
;               two interrupts for writing high and low to the beeper
;               pin of OUTPUT_REG.
BEEP_LEN:               .DB   0

;---- Display buffers
;     * 3x 8 byte buffers used to hold the ASCII equivalent text to be
;       displayed for each row of the display. The values are
;       translated to memory addresses to read from the character ROM.
;       NOTE: THESE BUFFERS MUST BE ALLOCATED CONTIGUOUSLY !!!
;     * 3x bytes which hold the dot point data for each row.
DISP_ROW0:              .DS   DISP_BUF_SZ, 0
DISP_ROW1:              .DS   DISP_BUF_SZ, 0
DISP_ROW2:              .DS   DISP_BUF_SZ, 0
DISP_ROW0_DP:           .DB   0
DISP_ROW1_DP:           .DB   0
DISP_ROW2_DP:           .DB   0


;---------------------------------------------------------------------
;                          APPLICATION CODE                          :
;---------------------------------------------------------------------
#code ROM, ROM_BASE, ROM_SZ

;---- Restart vectors
      .ORG 0
RST0:
      JP    PROC_TEST


      .ORG 0x08
RST1:
      HALT


      .ORG 0x10
RST2:
      HALT


      .ORG 0x18
RST3:
      HALT


      .ORG 0x20
RST4:
      HALT


      .ORG 0x28
RST5:
      HALT


      .ORG 0x30
RST6:
      HALT


      .ORG 0x38
RST7:
      HALT


;---------------------------------------------------------------------
;                         INTERRUPT VECTORS                          :
;---------------------------------------------------------------------
      .ORG 0x0066
NMI_VECTOR:
      RETN


      .ORG 0x0100
INT_VECTOR_TABLE:
      .DW   CTC_CH0_ISR             ; CTC Ch0 vector
      .DW   CTC_CH1_ISR             ; CTC Ch1 vector
      .DW   CTC_CH2_ISR             ; CTC Ch2 vector
      .DW   CTC_CH3_ISR             ; CTC Ch3 vector

      .DS   248, 0                  ; Fill rest of table with 0's


      .ORG 0x0200
;---------------------------------------------------------------------
;     Z80 PROCESSOR TEST                                             :
;                                                                    :
; DESCRIPTION                                                        :
;     Verify Z80 flags, registers (except IX/IY) and conditional     :
;     jumps, including all shadow register pairs.                    :
;                                                                    :
;     Adapted from IBM 5150 BIOS.                                    :
;---------------------------------------------------------------------
PROC_TEST:
      DI                            ; Ensure interrupts disabled

;---- First tests for normal flags register
      XOR   A
      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
      JP    PO, PROC_TEST_ERR       ; PARITY should be EVEN
      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO
      JP    M, PROC_TEST_ERR        ; Result should be POSITIVE

      SUB   1
      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
      JP    PE, PROC_TEST_ERR       ; PARITY should be ODD
      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO
      JP    P, PROC_TEST_ERR        ; Result should be NEGATIVE

      LD    A, 0x01
      SRL   A
      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO

      RL    A
      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO

;---- Repeat tests for shadow flags register
      EX    AF, AF'
      XOR   A
      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
      JP    PO, PROC_TEST_ERR       ; PARITY should be EVEN
      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO
      JP    M, PROC_TEST_ERR        ; Result should be POSITIVE

      SUB   1
      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
      JP    PE, PROC_TEST_ERR       ; PARITY should be ODD
      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO
      JP    P, PROC_TEST_ERR        ; Result should be NEGATIVE

      LD    A, 0x01
      SRL   A
      JR    NC, PROC_TEST_ERR       ; CARRY should be SET
      JR    NZ, PROC_TEST_ERR       ; Result should be ZERO

      RL    A
      JR    C, PROC_TEST_ERR        ; CARRY should be CLEAR
      JR    Z, PROC_TEST_ERR        ; Result should be NON-ZERO

;---- Load a test pattern through all registers
      EX    AF, AF'
      LD    A, 0xFF                 ; Setup one's pattern in A
      SCF

WRITE_PATTERN:
      LD    I, A                    ; Write pattern to all regs
      LD    A, I
      LD    L, A
      LD    H, L
      LD    E, H
      LD    D, E
      LD    C, D
      LD    B, C
      LD    A, B
      EXX
      LD    L, A
      LD    H, L
      LD    E, H
      LD    D, E
      LD    C, D
      LD    B, C
      JR    NC, PROC_TEST_DONE
      EX    AF, AF'
      LD    A, B
      XOR   0xFF                    ; Pattern make it through all regs
      JR    NZ, PROC_TEST_ERR       ; NO - go to err routine
      JR    WRITE_PATTERN

PROC_TEST_DONE:
      LD    A, I                    ; Zero pattern make it through?
      OR    B
      JR    Z, INDEX_REG_TEST             ; Next test if yes

PROC_TEST_ERR:
      HALT                          ; HALT on error


;---------------------------------------------------------------------
;     INDEX REGISTER TEST                                            :
;                                                                    :
; DESCRIPTION                                                        :
;     Performs a test on the IX and IY registers via SP to cover off :
;     remaining internal registers.                                  :
;---------------------------------------------------------------------
INDEX_REG_TEST:
      LD    B, 0xFF

INDEX_REG_TEST_NEXT:
      LD    A, B
      CP    0xFF
      JR    Z, INDEX_REG_TEST_FF

      LD    IX, 0                   ; Load test pattern, all zeroes
      JR    INDEX_REG_TEST_LOOP

INDEX_REG_TEST_FF:
      LD    IX, 0xFFFF              ; Load test pattern, all ones

INDEX_REG_TEST_LOOP:
      LD    IY, 0
      LD    HL, 0

      LD    SP, IX                  ; Move IX through IY and SP to HL
      ADD   IY, SP                  ; so it can be compared
      LD    SP, IY
      ADD   HL, SP

      LD    A, H                    ; XOR H and L, result should be 0
      XOR   L
      JR    NZ, INDEX_REG_TEST_ERR  ; Error if not 0

      OR    B                       ; If pattern is all zeroes, finish
      JR    Z, MEM_TEST

      LD    B, 0                    ; Setup for all ones test
      JR    INDEX_REG_TEST_NEXT

INDEX_REG_TEST_ERR:
      HALT                          ; Halt on error


;---------------------------------------------------------------------
;     RAM TEST                                                       :
;                                                                    :
; DESCRIPTION                                                        :
;     Performs a read/write storage test on RAM address space as     :
;     defined by RAM_BASE and RAM_SZ variables.                      :
;                                                                    :
;     Writes a series of patterns (0xAA, 0x55, 0xFF, 0x01 and 0x00)  :
;     and reads them back to check for errors.                       :
;                                                                    :
;     !!! DESTROYS CONTENTS OF ENTIRE MEMORY BLOCK !!!               :
;---------------------------------------------------------------------
MEM_TEST:
      LD    E, 0

MEM_TEST_NEXT:
      LD    HL, RAM_BASE            ; HL is address to begin test from
      LD    BC, RAM_SZ              ; BC is number of bytes to test

      LD    A, E                    ; Select next test pattern
      CP    0xAA
      JR    Z, MEM_TEST_55
      CP    0x55
      JR    Z, MEM_TEST_FF
      CP    0xFF
      JR    Z, MEM_TEST_01
      CP    0x01
      JR    Z, MEM_TEST_0

      LD    E, 0xAA
      JR    MEM_TEST_LOOP

MEM_TEST_55:
      LD    E, 0x55
      JR    MEM_TEST_LOOP

MEM_TEST_FF:
      LD    E, 0xFF
      JR    MEM_TEST_LOOP

MEM_TEST_01:
      LD    E, 0x01
      JR    MEM_TEST_LOOP

MEM_TEST_0:
      LD    E, 0
      JR    MEM_TEST_LOOP


MEM_TEST_LOOP:
      LD    (HL), E                 ; Write test pattern from E, read
      LD    A, (HL)                 ; back, XOR and ensure result is
      XOR   E                       ; zero to indicate success.
      JR    NZ, MEM_TEST_ERR

      INC   HL
      DEC   BC

      LD    A, B                    ; BC = 0?
      OR    C
      JR    NZ, MEM_TEST_LOOP       ; NO

      OR    E                       ; Completed zero test?
      JR    NZ, MEM_TEST_NEXT       ; NO - next test pattern

MEM_TEST_DONE:
      JP    INIT

MEM_TEST_ERR:
      HALT                          ; Halt on error


;---------------------------------------------------------------------
;     MAIN APPLICATION LOOP                                          :
;                                                                    :
; DESCRIPTION                                                        :
;     Implemented here is a state machine responsible for scheduling :
;     various tasks and implementing high level workflow.            :
;---------------------------------------------------------------------
      .ORG 0x0300
#data RAM
;---- LOCAL variables for MAIN


#code ROM
INIT:
      LD    SP, RAM_end             ; Stack starts at top of RAM

;---- Configure CTC Ch0 to ...

;---- Configure CTC Ch1 for 1ms period to update displays
      LD    A, CTC_CH_INTEN | CTC_CH1_PS | CTC_CH_TCONST | CTC_CH_CTRL
      OUT   (CTC_CH1), A
      LD    A, TC_CH1_DLY_1MS
      OUT   (CTC_CH1), A

;---- Configure CTC Ch2 for 10ms period for reading button presses
      LD    A, CTC_CH_INTEN | CTC_CH2_PS | CTC_CH_TCONST | CTC_CH_CTRL
      OUT   (CTC_CH2), A
      LD    A, TC_CH2_DLY_10MS
      OUT   (CTC_CH2), A

;---- Configure CTC Ch3 to ...

;---- Configure CTC interrupt vector
      XOR   A
      OUT   (CTC_CH0), A

      IM    2                       ; Z80 family vectored interrupts
      LD    A, VECTOR_INT_PG        ; INT vector table in page 1
      LD    I, A
      EI

      LD    A, 0x01                 ; Configure valid button mask
      LD    (BTN_MASK), A


MAIN:
;---- Check for button presses, and generate a beep on press
      LD    A, (BTN_STATE)
      OR    A
      LD    B, A

      JR    Z, MAIN                 ; Loop again if zero (no buttons)

      LD    A, (BTN_ACK)            ; Store pressed buttons as acks
      OR    B
      LD    (BTN_ACK), A

;---- With valid buttons pressed and ackd, do a beep
      CALL  BEEPER_ENABLE

      JR    MAIN

      HALT


;---------------------------------------------------------------------
;     ENABLE BEEPER                                                  :
;                                                                    :
; DESCRIPTION                                                        :
;     Configures interrupts etc to start generating a beep for       :
;     button presses.                                                :
;---------------------------------------------------------------------
BEEPER_ENABLE:
      LD    A, CTC_CH_INTEN | CTC_CH0_PS | CTC_CH_TCONST | CTC_CH_CTRL
      OUT   (CTC_CH0), A
      LD    A, TC_CH0_4000HZ
      OUT   (CTC_CH0), A

      RET


;---------------------------------------------------------------------
;     CTC CHANNEL 0 ISR - BEEPER                                     :
;                                                                    :
; DESCRIPTION                                                        :
;     Used to generate beeps e.g. when buttons are pressed.          :
;---------------------------------------------------------------------
#data RAM

#code ROM
CTC_CH0_ISR:
      EX    AF, AF'                 ; Swap to shadow registers
      EXX

      LD    HL, OUTPUT_REG_VAL
      LD    A, BEEPER_MASK          ; Toggle beeper bit
      XOR   (HL)
      LD    (HL), A
      OUT   (OUTPUT_REG), A         ; Write it out

      AND   BEEPER_MASK             ; Is beeper bit set or clear?
      JR    NZ, CTC_CH0_ISR_EXIT

      LD    HL, BEEP_LEN            ; Beeper bit is clear, decrement
      DEC   (HL)                    ; BEEP_LEN, and if zero disable
      JR    NZ, CTC_CH0_ISR_EXIT    ; interrupt.

      LD    A, CTC_CH_CTRL
      OUT   (CTC_CH0), A

CTC_CH0_ISR_EXIT:
      EXX                           ; Swap registers back
      EX    AF, AF'
      EI                            ; Re-enable interrupts

      RETI


;---------------------------------------------------------------------
;     CTC CHANNEL 1 ISR - DISPLAY UPDATE                             :
;                                                                    :
; DESCRIPTION                                                        :
;     The display is made up of 3 rows of 8x 16 segment displays.    :
;     Each iteration of this ISR cycles to the next display row
;     after shifting out the data corresponding to the currently
;     selected row.
;---------------------------------------------------------------------
#data RAM
DISP_CONTROL:           .DB   0

#code ROM
#local
CTC_CH1_ISR::
      EX    AF, AF'                 ; Swap to shadow registers
      EXX

;---- Pre-check: make sure the row counter in the display control
;                byte always remains in the range 1-3. At boot, memory
;                is initialised to all zeroes, and at the end of the
;                ISR the counter can overflow from 3 to 0. This check
;                will take care of both situations.
      LD    HL, DISP_CONTROL
      LD    A, (HL)

      AND   0x03
      JR    NZ, BUF_OFFSET

      INC   (HL)                    ; If count == 0, inc to 1
      LD    A, (HL)                 ; Read back from memory
      AND   0x03                    ; Prep A with new row count

BUF_OFFSET:
      DEC   A                       ; Index row count to zero
      LD    B, A                    ; B is num of times to add offset
      LD    HL, DISP_ROW0 + 7       ; Set pointer at end of first buf
      LD    DE, DISP_BUF_SZ         ; Offset value to be added

      CP    0                       ; Add offset?
      JR    Z, DO_ROW

ADD_OFFSET:
      ADD   HL, DE                  ; Yes - add DE to HL B times
      DJNZ  ADD_OFFSET

DO_ROW:
;---- Start shifting character data. Columns are numbered 0..7 from
;     left to right (reading direction), and by design the first bytes
;     to be shifted are for column 7.
;
;     Each character is stored as two contiguous bytes in CHAR_ROM so
;     the OTIR instruction can be used to do a two byte transfer op
;     from ROM to the display driver data register.
;
;     After text data is shifted, one final byte to control the DPs is
;     shifted.
      LD    C, DISP_DATA            ; Display peripheral I/O address
      LD    B, DISP_BUF_SZ          ; Outer loop counter

DO_ROW_NEXT:
      LD    D, 0
      LD    E, (HL)                 ; Load char value from buffer

      DEC   HL                      ; Dec buffer pointer and save
      PUSH  HL

      LD    HL, CHAR_ROM_BASE       ; Set pointer to start of CHAR_ROM
      SLA   E                       ; Double DE
      RL    D
      ADD   HL, DE                  ; HL + DE = char position in ROM

      PUSH  BC                      ; Save B

      LD    B, 2                    ; Inner loop counter
      OTIR                          ; Transfer two bytes

      POP   BC                      ; Restore B
      POP   HL                      ; Restore buffer pointer

      DJNZ  DO_ROW_NEXT             ; Next column

      ; TODO: Shift dot points

CTC_CH1_ISR_EXIT:
      LD    HL, DISP_CONTROL        ; Load display control byte
      LD    A, (HL)
      LD    C, A                    ; Keep a copy

      INC   A                       ; Increment row counter
      AND   0x03                    ; Mask out upper bits
      LD    B, A                    ; B is new row counter

      LD    A, C                    ; Make a new control byte
      AND   0xFC                    ; Remove row counter bits
      OR    B                       ; OR in new row counter bits
      LD    (HL), A                 ; Store back to memory

      EXX                           ; Swap registers back
      EX    AF, AF'
      EI

      RETI
#endlocal

;---------------------------------------------------------------------
;     CTC CHANNEL 2 ISR - READ BUTTONS                               :
;                                                                    :
; DESCRIPTION                                                        :
;     Reads button state, masks out invalid buttons and serviced     :
;     button presses, debounces.                                     :
;                                                                    :
;     Result is placed in to global BTN_STATE where it can be read   :
;     by current process.                                            :
;---------------------------------------------------------------------
#data RAM
BTN_DEBOUNCE:           .DB   0

#code ROM
CTC_CH2_ISR:
      EX    AF, AF'                 ; Swap to shadow registers
      EXX

      IN    A, (BTN_REG)            ; Read in button state
      CPL                           ; Buttons pull down, make positive

      LD    HL, BTN_MASK            ; Mask out invalid buttons
      AND   (HL)
      LD    B, A                    ; B is valid buttons only

      LD    HL, BTN_ACK             ; Make mask to hide serviced btns
      AND   (HL)
      LD    C, A                    ; C is mask

      XOR   B                       ; Remove svcd btns, leave unsvcd
      LD    B, A                    ; B is now unserviced buttons only
      OR    C                       ; Make mask to clear old ACKs

      AND   (HL)                    ; Clear ACKs from released btns
      LD    (HL), A

      LD    HL, BTN_DEBOUNCE        ; De-bounce button presses
      LD    A, (HL)
      AND   B
      LD    (BTN_STATE), A
      LD    (HL), B

      EXX                           ; Swap registers back
      EX    AF, AF'
      EI                            ; Re-enable interrupts

      RETI


;---------------------------------------------------------------------
;     CTC CHANNEL 1 ISR - ...                                        :
;                                                                    :
; DESCRIPTION                                                        :
;---------------------------------------------------------------------
#data RAM

#code ROM
CTC_CH3_ISR:
      EI
      RETI

#end
