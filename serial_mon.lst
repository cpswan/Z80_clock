              	; --------------------------------------
              	; zasm: assemble "serial_mon.s"
              	; date: 2020-03-10 16:29:55
              	; --------------------------------------


              	#target ROM
              	
              	#include "platform.inc"
              	;---- Oscillator frequencies (in Hz)
              	;     * FSYS is the primary system oscillator which drives the CPU.
              	;     * FCTC is a secondary oscillator external to the CTC which can
              	;       be prescaled and is fed in to the TRG1 input.
              	;     * FUART is the frequency fed into the SIO clock inputs for baud
              	;       rate generation.
8D80:         	FSYS                    .equ  6000000
8000:         	FCTC                    .equ  4096000
8000:         	FUART                   .equ  7372800
              	
              	;---- Memory sizes (in bytes)
              	;     Define the start (base) and size of ROMs and RAM.
              	#if defined(serial_loading)
              	ROM_BASE                .equ  0x6000
              	ROM_SZ                  .equ  6144
              	
              	RAM_BASE                .equ  0x7800
              	RAM_SZ                  .equ  1792
              	#else
0000:         	ROM_BASE                .equ  0
6000:         	ROM_SZ                  .equ  24576
              	
6000:         	RAM_BASE                .equ  0x6000
2000:         	RAM_SZ                  .equ  8192
              	#endif
              	
C000:         	TZ_ROM_BASE             .equ  0xC000
2000:         	TZ_ROM_SZ               .equ  8192
              	
E000:         	CHAR_ROM_BASE           .equ  0xE000
2000:         	CHAR_ROM_SZ             .equ  8192
              	
              	;---- Vector interrupt page number
              	;     Forms the most significant byte of the interrupt vector address
              	;     for Mode 2 interrupts.
0001:         	VECTOR_INT_PG           .equ  (ROM_BASE+0x100)>>8
              	
              	; END platform.inc
              	#include "sio.inc"
00FC:         	SIO_BASE                .equ  0xFC
00FC:         	SIO_A_DATA              .equ  SIO_BASE
00FD:         	SIO_B_DATA              .equ  SIO_BASE + 1
00FE:         	SIO_A_CTL               .equ  SIO_BASE + 2
00FF:         	SIO_B_CTL               .equ  SIO_BASE + 3
              	
0000:         	SIO_RR0_RX_AVAIL        .equ  0
0001:         	SIO_RR0_INT_PEND        .equ  0x1
0002:         	SIO_RR0_TX_EMPTY        .equ  0x2
0003:         	SIO_RR0_DCD             .equ  0x3
0004:         	SIO_RR0_SYNC_HUNT       .equ  0x4
0005:         	SIO_RR0_CTS             .equ  0x5
0006:         	SIO_RR0_TX_URUN         .equ  0x6
0007:         	SIO_RR0_BREAK           .equ  0x7
              	
0001:         	SIO_WR0_REG1            .equ  0x1
0002:         	SIO_WR0_REG2            .equ  0x2
0003:         	SIO_WR0_REG3            .equ  0x3
0004:         	SIO_WR0_REG4            .equ  0x4
0005:         	SIO_WR0_REG5            .equ  0x5
0006:         	SIO_WR0_REG6            .equ  0x6
0007:         	SIO_WR0_REG7            .equ  0x7
0008:         	SIO_WR0_CMD_ABT         .equ  0x1 << 3
0010:         	SIO_WR0_CMD_RST_EXT     .equ  0x2 << 3
0018:         	SIO_WR0_CMD_CH_RST      .equ  0x3 << 3
0020:         	SIO_WR0_CMD_EN_INT_RX   .equ  0x4 << 3
0028:         	SIO_WR0_CMD_RST_TXINT   .equ  0x5 << 3
0030:         	SIO_WR0_CMD_ERR_RST     .equ  0x6 << 3
0038:         	SIO_WR0_CMD_RTN_INT     .equ  0x7 << 3
0040:         	SIO_WR0_CRC_RST_RX      .equ  0x1 << 6
0080:         	SIO_WR0_CRC_RST_TX      .equ  0x2 << 6
00C0:         	SIO_WR0_CRC_RST_EOM     .equ  0x3 << 6
              	
0001:         	SIO_WR1_EXT_INT         .equ  0x1
0002:         	SIO_WR1_TX_INT          .equ  0x2
0004:         	SIO_WR1_STAT_VECT       .equ  0x4
0008:         	SIO_WR1_RX_INT_1ST      .equ  0x1 << 3
0010:         	SIO_WR1_RX_INT_ALL_PAV  .equ  0x2 << 3
0018:         	SIO_WR1_RX_INT_ALL      .equ  0x3 << 3
0020:         	SIO_WR1_WT_RDY_RX       .equ  0x20
0040:         	SIO_WR1_RDY_FUNC        .equ  0x40
0080:         	SIO_WR1_WT_RDY          .equ  0x80
              	
0001:         	SIO_WR3_RX_EN           .equ  0x1
0002:         	SIO_WR3_SYNC_INH        .equ  0x2
0004:         	SIO_WR3_ADDR_SRCH       .equ  0x4
0008:         	SIO_WR3_RX_CRC_EN       .equ  0x8
0010:         	SIO_WR3_HUNT_PH         .equ  0x10
0020:         	SIO_WR3_AUTO_EN         .equ  0x20
0040:         	SIO_WR3_RX_7            .equ  0x1 << 6
0080:         	SIO_WR3_RX_6            .equ  0x2 << 6
00C0:         	SIO_WR3_RX_8            .equ  0x3 << 6
              	
0001:         	SIO_WR4_PAR_EN          .equ  0x1
0002:         	SIO_WR4_PAR_EVN         .equ  0x2
0004:         	SIO_WR4_STOP_1          .equ  0x1 << 2
0008:         	SIO_WR4_STOP_1_5        .equ  0x2 << 2
000C:         	SIO_WR4_STOP_2          .equ  0x3 << 2
0010:         	SIO_WR4_SYNC_16         .equ  0x1 << 4
0020:         	SIO_WR4_SDLC            .equ  0x2 << 4
0030:         	SIO_WR4_EXT_SYNC        .equ  0x3 << 4
0040:         	SIO_WR4_1_16_CLK        .equ  0x1 << 6
0080:         	SIO_WR4_1_32_CLK        .equ  0x2 << 6
00C0:         	SIO_WR4_1_64_CLK        .equ  0x3 << 6
              	
0001:         	SIO_WR5_TX_CRC          .equ  0x1
0002:         	SIO_WR5_RTS             .equ  0x2
0004:         	SIO_WR5_CRC16           .equ  0x4
0008:         	SIO_WR5_TX_EN           .equ  0x8
0010:         	SIO_WR5_SND_BRK         .equ  0x10
0020:         	SIO_WR5_TX_7            .equ  0x1 << 5
0040:         	SIO_WR5_TX_6            .equ  0x2 << 5
0060:         	SIO_WR5_TX_8            .equ  0x3 << 5
0080:         	SIO_WR5_DTR             .equ  0x80
              	
              	; END sio.inc
              	
00DE:         	DEBUG_PORT              .equ  0xDE
              	
0000:         	SIO_A_WR1               .equ  0
00C1:         	SIO_A_WR3               .equ  0 | SIO_WR3_RX_8 | SIO_WR3_RX_EN
00C4:         	SIO_A_WR4               .equ  0 | SIO_WR4_1_64_CLK | SIO_WR4_STOP_1
00E8:         	SIO_A_WR5               .equ  0 | SIO_WR5_DTR | SIO_WR5_TX_8 | SIO_WR5_TX_EN
              	
0001:         	VECTOR_INT_PG           .equ  0x01
01F0:         	SIO_INT_VECT_BASE       .equ  VECTOR_INT_PG << 8 | (SIO_BASE << 2 & 0xFF)
              	
              	
              	assert_rts .macro
              	      push  AF
              	      ld    A, SIO_WR0_REG5
              	      out   (SIO_A_CTL), A
              	      ld    A, SIO_A_WR5 | SIO_WR5_RTS
              	      out   (SIO_A_CTL), A
              	      pop   AF
              	      .endm
              	
              	clear_rts .macro
              	      push  AF
              	      ld    A, SIO_WR0_REG5
              	      out   (SIO_A_CTL), A
              	      ld    A, SIO_A_WR5
              	      out   (SIO_A_CTL), A
              	      pop   AF
              	      .endm
              	
              	break .macro val
              	      ld    A, &val
              	      out   (DEBUG_PORT), A
              	      halt
              	      .endm
              	
              	
7F00:         	#data RAM, 0x7F00, 256
              	
0000:         	#code ROM, 0, 8192
              	;---- Restart vectors
              	      .org 0
0000: C30001  	      jp    main
              	
0003: FFFFFFFF	      .org 0x08
0007: FF      	
0008: C30860  	      jp    RAM_BASE+$
000B: FFFFFFFF	      .org 0x10
000F: FF      	
0010: C31060  	      jp    RAM_BASE+$
0013: FFFFFFFF	      .org 0x18
0017: FF      	
0018: C31860  	      jp    RAM_BASE+$
001B: FFFFFFFF	      .org 0x20
001F: FF      	
0020: C32060  	      jp    RAM_BASE+$
0023: FFFFFFFF	      .org 0x28
0027: FF      	
0028: C32860  	      jp    RAM_BASE+$
002B: FFFFFFFF	      .org 0x30
002F: FF      	
0030: C33060  	      jp    RAM_BASE+$
0033: FFFFFFFF	      .org 0x38
0037: FF      	
0038: C33860  	      jp    RAM_BASE+$
              	
003B: FFFFFFFF	      .org 0x66
003F: FF...   	
0066:         	nmi_vector:
0066: C36660  	      jp    RAM_BASE+$
              	
0069: FFFFFFFF	      .align 0x100
006D: FF...   	
              	#data RAM
              	
              	#code ROM
0100:         	main:
0100: F3      	      di                            ; Maskable ints not used
              	
0101: 310080  	      ld    SP, RAM_BASE+RAM_SZ     ; Stack starts at top of RAM
              	
              	;---- Configure SIO Channel A
              	      ; Channel A reset
0104: 0EFE    	      ld    C, SIO_A_CTL
0106: 3E18    	      ld    A, SIO_WR0_CMD_CH_RST
0108: ED79    	      out   (C), A
              	
              	      ; Channel B WR1 - Status affects vector bit
010A: 0EFF    	      ld    C, SIO_B_CTL
010C: 3E01    	      ld    A, SIO_WR0_REG1
010E: 0604    	      ld    B, SIO_WR1_STAT_VECT
0110: ED79    	      out   (C), A
0112: ED41    	      out   (C), B
              	
              	      ; Channel B WR2 - Interrupt vector
0114: 3E02    	      ld    A, SIO_WR0_REG2
0116: 06F0    	      ld    B, SIO_INT_VECT_BASE & 0xFF
0118: ED79    	      out   (C), A
011A: ED41    	      out   (C), B
              	
              	      ; Channel A WR4 - parity, async mode, clock rate
011C: 0EFE    	      ld    C, SIO_A_CTL
011E: 3E14    	      ld    A, SIO_WR0_REG4 | SIO_WR0_CMD_RST_EXT
0120: 06C4    	      ld    B, SIO_A_WR4
0122: ED79    	      out   (C), A
0124: ED41    	      out   (C), B
              	
              	      ; Channel A WR5 - TX enable, 8 bit, set DTR/, clear RTS/
0126: 3E05    	      ld    A, SIO_WR0_REG5
0128: 06E8    	      ld    B, SIO_A_WR5
012A: ED79    	      out   (C), A
012C: ED41    	      out   (C), B
              	
              	      ; Channel A WR3 - RX enable, 8 bit
012E: 3E03    	      ld    A, SIO_WR0_REG3
0130: 06C1    	      ld    B, SIO_A_WR3
0132: ED79    	      out   (C), A
0134: ED41    	      out   (C), B
              	
              	      ; Channel A WR1
0136: 3E11    	      ld    A, SIO_WR0_REG1 | SIO_WR0_CMD_RST_EXT
0138: 0600    	      ld    B, SIO_A_WR1
013A: ED79    	      out   (C), A
013C: ED41    	      out   (C), B
              	
              	;----
013E: 3E00    	      ld    A, 0                    ; Zeroise RAM
0140: 01FE00  	      ld    BC, RAM_size-2          ; -2 to keep ret addr on stack
0143: 21007F  	      ld    HL, RAM
              	
0146: CD1D03  	      call  memset
              	
0149:         	main_loop:
0149: CD0002  	      call  rx_task
              	
014C: 18FB    	      jr    main_loop
              	
              	
              	#data RAM
7F00: 00      	rx_flags:               .db 0       ; Flags for RX task
0000:         	RX_CMD:                 .equ  0     ; Command currently executing
              	
7F01: 00      	rx_command:             .db 0       ; Command number that is executing
7F02: 00      	rx_ctr:                 .db 0       ; Number of bytes RX'd to buffer
7F03: 0000    	rx_BC:                  .dw 0       ; Working copy of BC
7F05: 0000    	rx_HL:                  .dw 0       ; Working copy of HL
              	
7F07: 00000000	      .align 16
7F0B: 00...   	
7F10: 00000000	rx_buf:                 .ds 16      ; RX buffer
7F14: 00...   	
              	
              	#code ROM
014E: FFFFFFFF	      .align 0x100
0152: FF...   	
0200:         	rx_task:
              	#local
0200: DBFE    	      in    A, (SIO_A_CTL)          ; Any chars waiting?
0202: CB47    	      bit   SIO_RR0_RX_AVAIL, A
0204: C8      	      ret   Z                       ; No if Z, return
              	
0205: DBFC    	      in    A, (SIO_A_DATA)         ; Get waiting byte
0207: 47      	      ld    B, A                    ; Keep a copy for later
              	
              	      ; Check for errors
0208: 3E01    	      ld    A, SIO_WR0_REG1         ; Setup RR1
020A: D3FE    	      out   (SIO_A_CTL), A
020C: DBFE    	      in    A, (SIO_A_CTL)          ; Read RR1
020E: E670    	      and   A, 0x70                 ; Error bits are mask 01110000
0210: 2804    	      jr    Z, continue             ; Errors if NZ, otherwise continue
              	
0212: 78      	      ld    A, B
0213: D3DE    	      out   (DEBUG_PORT), A         ; Output error conds and halt
0215: 76      	      halt
              	
0216:         	continue:
0216: 3E38    	      ld    A, SIO_WR0_CMD_RTN_INT  ; Return from interrupt
0218: D3FE    	      out   (SIO_A_CTL), A
              	
021A: 78      	      ld    A, B
021B: 21007F  	      ld    HL, rx_flags            ; Currently executing a command?
021E: CB46    	      bit   RX_CMD, (HL)
0220: 2803    	      jr    Z, new_command          ; No if Z, start new command
              	
0222: 3A017F  	      ld    A, (rx_command)         ; Load command number into A
              	
0225:         	new_command:
0225: FE03    	      cp    A, 0x03                 ; Load into memory command
0227: 281B    	      jr    Z, write_cmd
0229: FE04    	      cp    A, 0x04                 ; Execute
022B: 285C    	      jr    Z, exec_cmd
              	
              	      ; Invalid command, reset state
022D:         	end_command:
022D: AF      	      xor   A, A
022E: 32017F  	      ld    (rx_command), A
0231: 21007F  	      ld    HL, rx_flags
0234: CB86    	      res   RX_CMD, (HL)
              	
0236: 18C8    	      jr    rx_task
              	
0238:         	start_command:
0238: 32017F  	      ld    (rx_command), A         ; Set command number
023B: CBC6    	      set   RX_CMD, (HL)            ; Set command executing flag
023D: AF      	      xor   A, A
023E: 32027F  	      ld    (rx_ctr), A             ; Zeroise buffer counter
              	
0241: C30002  	      jp    rx_task
              	
              	
0244:         	write_cmd:
0244: CB46    	      bit   RX_CMD, (HL)            ; Command executing?
0246: 28F0    	      jr    Z, start_command        ; No if Z, start
              	
0248: 3A027F  	      ld    A, (rx_ctr)             ; Received all header bytes?
024B: FE04    	      cp    A, 0x04
024D: 201C    	      jr    NZ, write_cmd_hdr_byte  ; No if NZ, store into buffer
              	
              	      ; Place bytes into memory from here
024F: 78      	      ld    A, B                    ; Restore RX'd byte
0250: ED4B037F	      ld    BC, (rx_BC)             ; Load working BC and HL
0254: 2A057F  	      ld    HL, (rx_HL)
              	
0257: 77      	      ld    (HL), A                 ; Store RX'd byte
              	
0258: 0B      	      dec   BC
0259: 23      	      inc   HL
              	
025A: ED43037F	      ld    (rx_BC), BC
025E: 22057F  	      ld    (rx_HL), HL
              	
0261: 78      	      ld    A, B                    ; BC == 0?
0262: B1      	      or    A, C
0263: 209B    	      jr    NZ, rx_task             ; No if NZ, more bytes to come
              	
0265: 3E21    	      ld    A, '!'                  ; Send command complete to host
0267: D3FC    	      out   (SIO_A_DATA), A
              	
0269: 18C2    	      jr    end_command
              	
026B:         	write_cmd_hdr_byte:
026B: 21107F  	      ld    HL, rx_buf              ; Increment HL by rx_ctr
026E: 85      	      add   A, L
026F: 6F      	      ld    L, A
              	
0270: 70      	      ld    (HL), B                 ; Store B into (HL)
              	
0271: 21027F  	      ld    HL, rx_ctr              ; Increment rx_ctr
0274: 34      	      inc   (HL)
0275: 7E      	      ld    A, (HL)
              	
0276: FE04    	      cp    A, 0x04                 ; Received 4 header bytes?
0278: 2086    	      jr    NZ, rx_task             ; No if NZ
              	
027A: 2A107F  	      ld    HL, (rx_buf)            ; Xfer working BC out of rx_buf
027D: 22037F  	      ld    (rx_BC), HL
0280: 2A127F  	      ld    HL, (rx_buf+2)          ; Xfer working HL out of rx_buf
0283: 22057F  	      ld    (rx_HL), HL
              	
0286: C30002  	      jp    rx_task
              	
              	
0289:         	exec_cmd:
0289: CB46    	      bit   RX_CMD, (HL)            ; Command executing?
028B: 28AB    	      jr    Z, start_command        ; No if Z, start
              	
028D: 3A027F  	      ld    A, (rx_ctr)             ; Increment HL by rx_ctr
0290: 21107F  	      ld    HL, rx_buf
0293: 85      	      add   A, L
0294: 6F      	      ld    L, A
              	
0295: 70      	      ld    (HL), B                 ; Store B into (HL)
              	
0296: 21027F  	      ld    HL, rx_ctr              ; Increment rx_ctr
0299: 34      	      inc   (HL)
029A: 7E      	      ld    A, (HL)
029B: D3DE    	      out   (DEBUG_PORT), A
              	
029D: FE02    	      cp    A, 0x02                 ; Received 2 header bytes?
029F: C20002  	      jp    NZ, rx_task             ; No if NZ
              	
02A2: 2A107F  	      ld    HL, (rx_buf)            ; Load HL and jump
              	
02A5: 3E2B    	      ld    A, '+'                  ; Send command complete to host
02A7: D3FC    	      out   (SIO_A_DATA), A
              	
              	      ; Wait until all TX buffers are completely empty, then reset
              	      ; both SIO channels, then jump to exec address.
02A9:         	exec_cmd_wait_tx:
02A9: 3E01    	      ld    A, SIO_WR0_REG1         ; Setup RR1
02AB: D3FE    	      out   (SIO_A_CTL), A
02AD: DBFE    	      in    A, (SIO_A_CTL)          ; Read RR1
02AF: CB47    	      bit   0, A                    ; Is bit 0 set?
02B1: 28F6    	      jr    Z, exec_cmd_wait_tx     ; No, wait some more
              	
02B3: 3E18    	      ld    A, SIO_WR0_CMD_CH_RST   ; SIO channel A and B reset
02B5: D3FE    	      out   (SIO_A_CTL), A
02B7: D3FF    	      out   (SIO_B_CTL), A
              	
02B9: E9      	      jp    (HL)                    ; Execute
              	#endlocal
              	
              	
              	#code ROM
02BA: FFFFFFFF	      .align 0x100
02BE: FF...   	
              	
              	#include "c_lib.s"
              	#data RAM
              	
              	#code ROM
              	      .align 0x100
              	;---------------------------------------------------------------------
              	;     memcpy                                                         :
              	;                                                                    :
              	; Description                                                        :
              	;     Copy block of memory.                                          :
              	;                                                                    :
              	;     Copies the values of BC bytes from the location pointed to by  :
              	;     HL directly to the memory block pointed to by DE.              :
              	;                                                                    :
              	; Parameters                                                         :
              	;     BC  Number of bytes to copy                                    :
              	;     DE  Pointer to the destination                                 :
              	;     HL  Pointer to the source of data to be copied                 :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;                                                                    :
              	; Destroys                                                           :
              	;     A                                                              :
              	;---------------------------------------------------------------------
0300:         	memcpy:
0300: 78      	      ld    A, B                    ; BC == 0?
0301: B1      	      or    A, C
0302: C8      	      ret   Z                       ; Yes if Z, return
              	
0303: EDB0    	      ldir                          ; while (BC != 0) {
              	                                    ;   (DE) <- (HL)
              	                                    ;   DE++, HL++, BC--
              	                                    ; }
0305: C9      	      ret
              	
              	;---------------------------------------------------------------------
              	;     strncpy                                                        :
              	;                                                                    :
              	; Description                                                        :
              	;     Copy characters from string.                                   :
              	;                                                                    :
              	;     Copies the first BC characters from HL to DE. If the end of    :
              	;     the source string (which is signaled by a null-character) is   :
              	;     found before BC characters have been copied, DE is padded with :
              	;     zeros until a total of BC characters have been written to it.  :
              	;
              	;     No null-character is implicitly appended at the end of DE if   ;
              	;     HL is longer than BC. Thus, in this case, DE shall not be      ;
              	;     considered a null terminated string.                           ;
              	;                                                                    :
              	; Parameters                                                         :
              	;     BC  Maximum number of characters to be copied                  :
              	;     DE  Pointer to the destination                                 :
              	;     HL  String to be copied                                        :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;                                                                    :
              	; Destroys                                                           :
              	;     A                                                              :
              	;---------------------------------------------------------------------
0306:         	strncpy:
              	#local
0306: 78      	      ld    A, B                    ; BC == 0?
0307: B1      	      or    A, C
0308: C8      	      ret   Z                       ; Yes if Z, return
              	
0309: 7E      	      ld    A, (HL)                 ; Load char from source
030A: FE00    	      cp    A, 0                    ; Is it a zero?
030C: 2806    	      jr    Z, zero_fill            ; Yes if Z, zero fill from here
              	
030E: 12      	      ld    (DE), A                 ; No, store char to dest
              	
030F: 0B      	      dec   BC                      ; Dec byte count
0310: 13      	      inc   DE                      ; Inc dest pointer
0311: 23      	      inc   HL                      ; Inc source pointer
              	
0312: 18F2    	      jr    strncpy                 ; Next char
              	
0314:         	zero_fill:
0314: AF      	      xor   A, A                    ; Store 0 into DE
0315: 12      	      ld    (DE), A
              	
0316: 0B      	      dec   BC                      ; Dec byte count
0317: 13      	      inc   DE                      ; Inc dest pointer
              	
0318: 78      	      ld    A, B                    ; BC == 0?
0319: B1      	      or    A, C
031A: 20F8    	      jr    NZ, zero_fill           ; No if NZ, fill next char
              	
031C: C9      	      ret
              	#endlocal
              	
              	;---------------------------------------------------------------------
              	;     memset                                                         :
              	;                                                                    :
              	; Description                                                        :
              	;     Fill block of memory.                                          :
              	;                                                                    :
              	;     Sets the first BC bytes of the block of memory pointed by HL   :
              	;     to the specified value in A.                                   :
              	;                                                                    :
              	; Parameters                                                         :
              	;     A   Value to be set                                            :
              	;     BC  Number of bytes to be set to the value of A                :
              	;     HL  Pointer to the block of memory to fill                     :
              	;                                                                    :
              	; Returns                                                            :
              	;     Nothing                                                        :
              	;                                                                    :
              	; Destroys                                                           :
              	;     D                                                              :
              	;---------------------------------------------------------------------
031D:         	memset:
              	#local
031D: 57      	      ld    D, A
              	
031E:         	next:
031E: 78      	      ld    A, B                    ; BC == 0?
031F: B1      	      or    A, C
0320: C8      	      ret   Z                       ; Yes if Z, return
              	
0321: 72      	      ld    (HL), D                 ; Set
              	
0322: 0B      	      dec   BC                      ; Dec byte count
0323: 23      	      inc   HL                      ; Inc dest pointer
              	
0324: 18F8    	      jr    next
              	#endlocal


; +++ segments +++

#CODE ROM      = $0000 =     0,  size = $2000 =  8192
#DATA RAM      = $7F00 = 32512,  size = $0100 =   256

; +++ global symbols +++

CHAR_ROM_BASE       = $E000 = 57344          platform.inc:30 (unused)
CHAR_ROM_SZ         = $2000 =  8192          platform.inc:31 (unused)
DEBUG_PORT          = $00DE =   222          serial_mon.s:6
FCTC                = $8000 =4096000          platform.inc:8 (unused)
FSYS                = $8D80 =6000000          platform.inc:7 (unused)
FUART               = $8000 =7372800          platform.inc:9 (unused)
RAM                 = $7F00 = 32512  RAM     platform.inc:38
RAM_BASE            = $6000 = 24576          platform.inc:23
RAM_SZ              = $2000 =  8192          platform.inc:24
RAM_end             = $8000 = 32768  RAM     platform.inc:38 (unused)
RAM_size            = $0100 =   256  RAM     platform.inc:38
ROM                 = $0000 =     0  ROM     sio.inc:1 (unused)
ROM_BASE            = $0000 =     0          platform.inc:20
ROM_SZ              = $6000 = 24576          platform.inc:21 (unused)
ROM_end             = $2000 =  8192  ROM     sio.inc:1 (unused)
ROM_size            = $2000 =  8192  ROM     sio.inc:1 (unused)
RX_CMD              = $0000 =     0  RAM     serial_mon.s:136
SIO_A_CTL           = $00FE =   254          sio.inc:4
SIO_A_DATA          = $00FC =   252          sio.inc:2
SIO_A_WR1           = $0000 =     0          serial_mon.s:8
SIO_A_WR3           = $00C1 =   193          serial_mon.s:9
SIO_A_WR4           = $00C4 =   196          serial_mon.s:10
SIO_A_WR5           = $00E8 =   232          serial_mon.s:11
SIO_BASE            = $00FC =   252          sio.inc:1
SIO_B_CTL           = $00FF =   255          sio.inc:5
SIO_B_DATA          = $00FD =   253          sio.inc:3 (unused)
SIO_INT_VECT_BASE   = $01F0 =   496          serial_mon.s:14
SIO_RR0_BREAK       = $0007 =     7          sio.inc:14 (unused)
SIO_RR0_CTS         = $0005 =     5          sio.inc:12 (unused)
SIO_RR0_DCD         = $0003 =     3          sio.inc:10 (unused)
SIO_RR0_INT_PEND    = $0001 =     1          sio.inc:8 (unused)
SIO_RR0_RX_AVAIL    = $0000 =     0          sio.inc:7
SIO_RR0_SYNC_HUNT   = $0004 =     4          sio.inc:11 (unused)
SIO_RR0_TX_EMPTY    = $0002 =     2          sio.inc:9 (unused)
SIO_RR0_TX_URUN     = $0006 =     6          sio.inc:13 (unused)
SIO_WR0_CMD_ABT     = $0008 =     8          sio.inc:23 (unused)
SIO_WR0_CMD_CH_RST  = $0018 =    24          sio.inc:25
SIO_WR0_CMD_EN_INT_RX = $0020 =    32          sio.inc:26 (unused)
SIO_WR0_CMD_ERR_RST = $0030 =    48          sio.inc:28 (unused)
SIO_WR0_CMD_RST_EXT = $0010 =    16          sio.inc:24
SIO_WR0_CMD_RST_TXINT = $0028 =    40          sio.inc:27 (unused)
SIO_WR0_CMD_RTN_INT = $0038 =    56          sio.inc:29
SIO_WR0_CRC_RST_EOM = $00C0 =   192          sio.inc:32 (unused)
SIO_WR0_CRC_RST_RX  = $0040 =    64          sio.inc:30 (unused)
SIO_WR0_CRC_RST_TX  = $0080 =   128          sio.inc:31 (unused)
SIO_WR0_REG1        = $0001 =     1          sio.inc:16
SIO_WR0_REG2        = $0002 =     2          sio.inc:17
SIO_WR0_REG3        = $0003 =     3          sio.inc:18
SIO_WR0_REG4        = $0004 =     4          sio.inc:19
SIO_WR0_REG5        = $0005 =     5          sio.inc:20
SIO_WR0_REG6        = $0006 =     6          sio.inc:21 (unused)
SIO_WR0_REG7        = $0007 =     7          sio.inc:22 (unused)
SIO_WR1_EXT_INT     = $0001 =     1          sio.inc:34 (unused)
SIO_WR1_RDY_FUNC    = $0040 =    64          sio.inc:41 (unused)
SIO_WR1_RX_INT_1ST  = $0008 =     8          sio.inc:37 (unused)
SIO_WR1_RX_INT_ALL  = $0018 =    24          sio.inc:39 (unused)
SIO_WR1_RX_INT_ALL_PAV = $0010 =    16          sio.inc:38 (unused)
SIO_WR1_STAT_VECT   = $0004 =     4          sio.inc:36
SIO_WR1_TX_INT      = $0002 =     2          sio.inc:35 (unused)
SIO_WR1_WT_RDY      = $0080 =   128          sio.inc:42 (unused)
SIO_WR1_WT_RDY_RX   = $0020 =    32          sio.inc:40 (unused)
SIO_WR3_ADDR_SRCH   = $0004 =     4          sio.inc:46 (unused)
SIO_WR3_AUTO_EN     = $0020 =    32          sio.inc:49 (unused)
SIO_WR3_HUNT_PH     = $0010 =    16          sio.inc:48 (unused)
SIO_WR3_RX_6        = $0080 =   128          sio.inc:51 (unused)
SIO_WR3_RX_7        = $0040 =    64          sio.inc:50 (unused)
SIO_WR3_RX_8        = $00C0 =   192          sio.inc:52
SIO_WR3_RX_CRC_EN   = $0008 =     8          sio.inc:47 (unused)
SIO_WR3_RX_EN       = $0001 =     1          sio.inc:44
SIO_WR3_SYNC_INH    = $0002 =     2          sio.inc:45 (unused)
SIO_WR4_1_16_CLK    = $0040 =    64          sio.inc:62 (unused)
SIO_WR4_1_32_CLK    = $0080 =   128          sio.inc:63 (unused)
SIO_WR4_1_64_CLK    = $00C0 =   192          sio.inc:64
SIO_WR4_EXT_SYNC    = $0030 =    48          sio.inc:61 (unused)
SIO_WR4_PAR_EN      = $0001 =     1          sio.inc:54 (unused)
SIO_WR4_PAR_EVN     = $0002 =     2          sio.inc:55 (unused)
SIO_WR4_SDLC        = $0020 =    32          sio.inc:60 (unused)
SIO_WR4_STOP_1      = $0004 =     4          sio.inc:56
SIO_WR4_STOP_1_5    = $0008 =     8          sio.inc:57 (unused)
SIO_WR4_STOP_2      = $000C =    12          sio.inc:58 (unused)
SIO_WR4_SYNC_16     = $0010 =    16          sio.inc:59 (unused)
SIO_WR5_CRC16       = $0004 =     4          sio.inc:68 (unused)
SIO_WR5_DTR         = $0080 =   128          sio.inc:74
SIO_WR5_RTS         = $0002 =     2          sio.inc:67 (unused)
SIO_WR5_SND_BRK     = $0010 =    16          sio.inc:70 (unused)
SIO_WR5_TX_6        = $0040 =    64          sio.inc:72 (unused)
SIO_WR5_TX_7        = $0020 =    32          sio.inc:71 (unused)
SIO_WR5_TX_8        = $0060 =    96          sio.inc:73
SIO_WR5_TX_CRC      = $0001 =     1          sio.inc:66 (unused)
SIO_WR5_TX_EN       = $0008 =     8          sio.inc:69
TZ_ROM_BASE         = $C000 = 49152          platform.inc:27 (unused)
TZ_ROM_SZ           = $2000 =  8192          platform.inc:28 (unused)
VECTOR_INT_PG       = $0001 =     1          serial_mon.s:13
main                = $0100 =   256  ROM     serial_mon.s:72
main_loop           = $0149 =   329  ROM     serial_mon.s:128
memcpy              = $0300 =   768  ROM     c_lib.s:25 (unused)
memset              = $031D =   797  ROM     c_lib.s:114
nmi_vector          = $0066 =   102  ROM     serial_mon.s:65 (unused)
rx_BC               = $7F03 = 32515  RAM     serial_mon.s:140
rx_HL               = $7F05 = 32517  RAM     serial_mon.s:141
rx_buf              = $7F10 = 32528  RAM     serial_mon.s:144
rx_command          = $7F01 = 32513  RAM     serial_mon.s:138
rx_ctr              = $7F02 = 32514  RAM     serial_mon.s:139
rx_flags            = $7F00 = 32512  RAM     serial_mon.s:135
rx_task             = $0200 =   512  ROM     serial_mon.s:148
strncpy             = $0306 =   774  ROM     c_lib.s:62

; +++ local symbols +++

continue           = $0216 =   534  ROM     serial_mon.s:168
end_command        = $022D =   557  ROM     serial_mon.s:186
exec_cmd           = $0289 =   649  ROM     serial_mon.s:255
exec_cmd_wait_tx   = $02A9 =   681  ROM     serial_mon.s:281
new_command        = $0225 =   549  ROM     serial_mon.s:179
start_command      = $0238 =   568  ROM     serial_mon.s:194
write_cmd          = $0244 =   580  ROM     serial_mon.s:203
write_cmd_hdr_byte = $026B =   619  ROM     serial_mon.s:233

; +++ local symbols +++

zero_fill = $0314 =   788  ROM     c_lib.s:80

; +++ local symbols +++

next    = $031E =   798  ROM     c_lib.s:118


total time: 0.0095 sec.
no errors
